From a50c1c52b71738fafb3f4b992048e74a3cea6659 Mon Sep 17 00:00:00 2001
From: Danct12 <danct12@disroot.org>
Date: Tue, 27 Jun 2023 22:40:37 +0000
Subject: [PATCH 3/4] drivers: staging: Import Segfault's BES2600 driver

---
 drivers/staging/Kconfig                       |    2 +
 drivers/staging/Makefile                      |    1 +
 drivers/staging/bes2600/Kconfig               |    8 +
 drivers/staging/bes2600/Makefile              |   37 +
 drivers/staging/bes2600/ap.c                  | 1474 ++++++++++
 drivers/staging/bes2600/ap.h                  |   49 +
 drivers/staging/bes2600/bes2600.h             |  553 ++++
 drivers/staging/bes2600/bes2600_cfgvendor.c   |  122 +
 drivers/staging/bes2600/bes2600_cfgvendor.h   |  218 ++
 drivers/staging/bes2600/bes2600_driver_mode.h |   26 +
 drivers/staging/bes2600/bes2600_factory.c     |  883 ++++++
 drivers/staging/bes2600/bes2600_factory.h     |  209 ++
 drivers/staging/bes2600/bes2600_log.c         |  152 +
 drivers/staging/bes2600/bes2600_log.h         |  161 ++
 drivers/staging/bes2600/bes2600_plat.h        |   36 +
 drivers/staging/bes2600/bes2600_sdio.c        | 1901 +++++++++++++
 drivers/staging/bes2600/bes_chardev.c         | 1080 +++++++
 drivers/staging/bes2600/bes_chardev.h         |   70 +
 drivers/staging/bes2600/bes_fw.c              |  976 +++++++
 drivers/staging/bes2600/bes_fw_common.c       |   99 +
 drivers/staging/bes2600/bes_fw_common.h       |  101 +
 drivers/staging/bes2600/bes_pwr.h             |  138 +
 drivers/staging/bes2600/bh.c                  |  787 +++++
 drivers/staging/bes2600/bh.h                  |   45 +
 drivers/staging/bes2600/debug.c               |  655 +++++
 drivers/staging/bes2600/debug.h               |  112 +
 drivers/staging/bes2600/epta_coex.c           |  580 ++++
 drivers/staging/bes2600/epta_coex.h           |   82 +
 drivers/staging/bes2600/epta_request.c        |  650 +++++
 drivers/staging/bes2600/epta_request.h        |   52 +
 drivers/staging/bes2600/fwio.c                |   33 +
 drivers/staging/bes2600/fwio.h                |   36 +
 drivers/staging/bes2600/ht.h                  |   43 +
 drivers/staging/bes2600/hwio.c                |  263 ++
 drivers/staging/bes2600/hwio.h                |  283 ++
 drivers/staging/bes2600/itp.h                 |   60 +
 drivers/staging/bes2600/main.c                |  681 +++++
 drivers/staging/bes2600/pm.c                  |  411 +++
 drivers/staging/bes2600/pm.h                  |   35 +
 drivers/staging/bes2600/queue.c               |  788 +++++
 drivers/staging/bes2600/queue.h               |  157 +
 drivers/staging/bes2600/sbus.h                |   84 +
 drivers/staging/bes2600/scan.c                |  658 +++++
 drivers/staging/bes2600/scan.h                |   56 +
 drivers/staging/bes2600/sta.c                 | 2526 +++++++++++++++++
 drivers/staging/bes2600/sta.h                 |  125 +
 drivers/staging/bes2600/tx_loop.c             |  530 ++++
 drivers/staging/bes2600/tx_loop.h             |   33 +
 drivers/staging/bes2600/txrx.c                | 1483 ++++++++++
 drivers/staging/bes2600/txrx.h                |   93 +
 drivers/staging/bes2600/txrx_opt.c            |  443 +++
 drivers/staging/bes2600/txrx_opt.h            |   29 +
 drivers/staging/bes2600/wsm.c                 | 2516 ++++++++++++++++
 drivers/staging/bes2600/wsm.h                 | 2091 ++++++++++++++
 54 files changed, 24716 insertions(+)
 create mode 100644 drivers/staging/bes2600/Kconfig
 create mode 100644 drivers/staging/bes2600/Makefile
 create mode 100755 drivers/staging/bes2600/ap.c
 create mode 100755 drivers/staging/bes2600/ap.h
 create mode 100755 drivers/staging/bes2600/bes2600.h
 create mode 100755 drivers/staging/bes2600/bes2600_cfgvendor.c
 create mode 100755 drivers/staging/bes2600/bes2600_cfgvendor.h
 create mode 100755 drivers/staging/bes2600/bes2600_driver_mode.h
 create mode 100755 drivers/staging/bes2600/bes2600_factory.c
 create mode 100755 drivers/staging/bes2600/bes2600_factory.h
 create mode 100755 drivers/staging/bes2600/bes2600_log.c
 create mode 100755 drivers/staging/bes2600/bes2600_log.h
 create mode 100755 drivers/staging/bes2600/bes2600_plat.h
 create mode 100755 drivers/staging/bes2600/bes2600_sdio.c
 create mode 100755 drivers/staging/bes2600/bes_chardev.c
 create mode 100755 drivers/staging/bes2600/bes_chardev.h
 create mode 100755 drivers/staging/bes2600/bes_fw.c
 create mode 100755 drivers/staging/bes2600/bes_fw_common.c
 create mode 100755 drivers/staging/bes2600/bes_fw_common.h
 create mode 100755 drivers/staging/bes2600/bes_pwr.h
 create mode 100755 drivers/staging/bes2600/bh.c
 create mode 100755 drivers/staging/bes2600/bh.h
 create mode 100755 drivers/staging/bes2600/debug.c
 create mode 100755 drivers/staging/bes2600/debug.h
 create mode 100755 drivers/staging/bes2600/epta_coex.c
 create mode 100755 drivers/staging/bes2600/epta_coex.h
 create mode 100755 drivers/staging/bes2600/epta_request.c
 create mode 100755 drivers/staging/bes2600/epta_request.h
 create mode 100755 drivers/staging/bes2600/fwio.c
 create mode 100755 drivers/staging/bes2600/fwio.h
 create mode 100755 drivers/staging/bes2600/ht.h
 create mode 100755 drivers/staging/bes2600/hwio.c
 create mode 100755 drivers/staging/bes2600/hwio.h
 create mode 100755 drivers/staging/bes2600/itp.h
 create mode 100755 drivers/staging/bes2600/main.c
 create mode 100755 drivers/staging/bes2600/pm.c
 create mode 100755 drivers/staging/bes2600/pm.h
 create mode 100755 drivers/staging/bes2600/queue.c
 create mode 100755 drivers/staging/bes2600/queue.h
 create mode 100755 drivers/staging/bes2600/sbus.h
 create mode 100755 drivers/staging/bes2600/scan.c
 create mode 100755 drivers/staging/bes2600/scan.h
 create mode 100755 drivers/staging/bes2600/sta.c
 create mode 100755 drivers/staging/bes2600/sta.h
 create mode 100755 drivers/staging/bes2600/tx_loop.c
 create mode 100755 drivers/staging/bes2600/tx_loop.h
 create mode 100755 drivers/staging/bes2600/txrx.c
 create mode 100755 drivers/staging/bes2600/txrx.h
 create mode 100755 drivers/staging/bes2600/txrx_opt.c
 create mode 100755 drivers/staging/bes2600/txrx_opt.h
 create mode 100755 drivers/staging/bes2600/wsm.c
 create mode 100755 drivers/staging/bes2600/wsm.h

diff --git a/drivers/staging/Kconfig b/drivers/staging/Kconfig
index f9aef39cac2e..c4b969a6952f 100644
--- a/drivers/staging/Kconfig
+++ b/drivers/staging/Kconfig
@@ -78,4 +78,6 @@ source "drivers/staging/qlge/Kconfig"
 
 source "drivers/staging/vme_user/Kconfig"
 
+source "drivers/staging/bes2600/Kconfig"
+
 endif # STAGING
diff --git a/drivers/staging/Makefile b/drivers/staging/Makefile
index ffa70dda481d..1a4ab6cf7c76 100644
--- a/drivers/staging/Makefile
+++ b/drivers/staging/Makefile
@@ -28,3 +28,4 @@ obj-$(CONFIG_PI433)		+= pi433/
 obj-$(CONFIG_XIL_AXIS_FIFO)	+= axis-fifo/
 obj-$(CONFIG_FIELDBUS_DEV)     += fieldbus/
 obj-$(CONFIG_QLGE)		+= qlge/
+obj-$(CONFIG_BES2600)		+= bes2600/
diff --git a/drivers/staging/bes2600/Kconfig b/drivers/staging/bes2600/Kconfig
new file mode 100644
index 000000000000..11f134213d59
--- /dev/null
+++ b/drivers/staging/bes2600/Kconfig
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+config BES2600
+	tristate "Bestechnic BES2600 Wireless LAN NIC driver"
+	depends on WLAN && MMC && CFG80211 && MAC80211
+	help
+	This option enables support for BES2600 Wi-Fi chip, this wifi
+	chip can be found on the PineTab2.
+	If built as a module, it will be called bes2600.
diff --git a/drivers/staging/bes2600/Makefile b/drivers/staging/bes2600/Makefile
new file mode 100644
index 000000000000..a6a6bd2ed9c7
--- /dev/null
+++ b/drivers/staging/bes2600/Makefile
@@ -0,0 +1,37 @@
+# SPDX-License-Identifier: GPL-2.0
+VERSION := bes2600_0.3.10_2022.1125
+obj-$(CONFIG_BES2600) += bes2600.o
+
+bes2600-y    += ap.o \
+                bes2600_cfgvendor.o \
+                bes2600_factory.o \
+                bes2600_log.o \
+                bes2600_sdio.o \
+                bes_chardev.o \
+                bes_fw.o \
+                bes_fw_common.o \
+                bh.o \
+                debug.o \
+                epta_coex.o \
+                epta_request.o \
+                fwio.o \
+                hwio.o \
+                main.o \
+                pm.o \
+                queue.o \
+                scan.o \
+                sta.o \
+                tx_loop.o \
+                txrx.o \
+                txrx_opt.o \
+                wsm.o
+
+ccflags-y += -DBES2600_DRV_VERSION=\"$(VERSION)\"
+
+.PHONY: modules clean
+
+modules:
+	@$(MAKE) -C $(KERNEL) M=$(CURDIR) modules
+
+clean:
+	@$(MAKE) -C $(KERNEL) M=$(CURDIR) clean
diff --git a/drivers/staging/bes2600/ap.c b/drivers/staging/bes2600/ap.c
new file mode 100755
index 000000000000..40520c760276
--- /dev/null
+++ b/drivers/staging/bes2600/ap.c
@@ -0,0 +1,1474 @@
+/*
+ * mac80211 STA and AP API for mac80211 BES2600 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include "bes2600.h"
+#include "sta.h"
+#include "ap.h"
+#include "bh.h"
+#include "net/mac80211.h"
+#include <linux/umh.h>
+#include "epta_request.h"
+#include "epta_coex.h"
+#include "txrx_opt.h"
+
+#define HT_INFO_OFFSET 4
+#define HT_INFO_MASK 0x0011
+#define HT_INFO_IE_LEN 22
+
+#define BES2600_ENABLE_ARP_FILTER_OFFLOAD	3
+#define BES2600_FASTPS_IDLE_TIME		0
+#define BES2600_KEEP_ALIVE_PERIOD		(20)
+#define BES2600_LINK_ID_GC_TIMEOUT		((unsigned long)(10 * HZ))
+
+#define ERP_INFO_BYTE_OFFSET 2
+
+static int bes2600_upload_beacon(struct bes2600_vif *priv);
+static int bes2600_upload_pspoll(struct bes2600_vif *priv);
+static int bes2600_upload_null(struct bes2600_vif *priv);
+static int bes2600_upload_qosnull(struct bes2600_vif *priv);
+static int bes2600_start_ap(struct bes2600_vif *priv);
+static int bes2600_update_beaconing(struct bes2600_vif *priv);
+/*
+static int bes2600_enable_beaconing(struct bes2600_vif *priv,
+				   bool enable);
+*/
+static void __bes2600_sta_notify(struct bes2600_vif *priv,
+				enum sta_notify_cmd notify_cmd,
+				int link_id);
+
+/* ******************************************************************** */
+/* AP API								*/
+
+int bes2600_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta)
+{
+	struct bes2600_sta_priv *sta_priv =
+			(struct bes2600_sta_priv *)&sta->drv_priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct bes2600_link_entry *entry;
+	struct sk_buff *skb;
+	struct bes2600_common *hw_priv = hw->priv;
+
+	WARN_ON(priv->if_id == CW12XX_GENERIC_IF_ID);
+
+	bes2600_info(BES2600_DBG_AP, "%s mode:%u, MFP:%u\n",
+		__FUNCTION__, priv->mode, sta->mfp);
+
+	if (priv->mode == NL80211_IFTYPE_STATION)
+		priv->pmf = sta->mfp;
+
+	if (priv->mode != NL80211_IFTYPE_AP)
+		return 0;
+
+	sta_priv->priv = priv;
+	sta_priv->link_id = bes2600_find_link_id(priv, sta->addr);
+	if (WARN_ON(!sta_priv->link_id)) {
+		/* Impossible error */
+		wiphy_info(priv->hw->wiphy,
+			"[AP] No more link IDs available.\n");
+		return -ENOENT;
+	}
+
+	entry = &priv->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&priv->ps_state_lock);
+	if ((sta->uapsd_queues & IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK) ==
+					IEEE80211_WMM_IE_STA_QOSINFO_AC_MASK)
+		priv->sta_asleep_mask |= BIT(sta_priv->link_id);
+	entry->status = BES2600_LINK_HARD;
+	while ((skb = skb_dequeue(&entry->rx_queue)))
+		ieee80211_rx_irqsafe(priv->hw, skb);
+	spin_unlock_bh(&priv->ps_state_lock);
+	hw_priv->connected_sta_cnt++;
+	if(hw_priv->connected_sta_cnt>1) {
+			wsm_lock_tx(hw_priv);
+			WARN_ON(wsm_set_block_ack_policy(hw_priv,
+					BES2600_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+					BES2600_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+					priv->if_id));
+			wsm_unlock_tx(hw_priv);
+	}
+
+	return 0;
+}
+
+int bes2600_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_sta_priv *sta_priv =
+			(struct bes2600_sta_priv *)&sta->drv_priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct bes2600_link_entry *entry;
+
+	WARN_ON(priv->if_id == CW12XX_GENERIC_IF_ID);
+
+	bes2600_info(BES2600_DBG_AP, "%s mode:%u\n", __FUNCTION__, priv->mode);
+
+	if (priv->mode == NL80211_IFTYPE_STATION)
+		priv->pmf = false;
+
+	if (priv->mode != NL80211_IFTYPE_AP || !sta_priv->link_id)
+		return 0;
+
+	entry = &priv->link_id_db[sta_priv->link_id - 1];
+	spin_lock_bh(&priv->ps_state_lock);
+	entry->status = BES2600_LINK_RESERVE;
+	entry->timestamp = jiffies;
+	wsm_lock_tx_async(hw_priv);
+	if (queue_work(hw_priv->workqueue, &priv->link_id_work) <= 0)
+		wsm_unlock_tx(hw_priv);
+	spin_unlock_bh(&priv->ps_state_lock);
+	flush_workqueue(hw_priv->workqueue);
+	hw_priv->connected_sta_cnt--;
+	if(hw_priv->connected_sta_cnt <= 1) {
+		if ((priv->if_id != 1) ||
+			((priv->if_id == 1) && hw_priv->is_go_thru_go_neg)) {
+			wsm_lock_tx(hw_priv);
+			WARN_ON(wsm_set_block_ack_policy(hw_priv,
+						BES2600_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+						BES2600_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+						priv->if_id));
+			wsm_unlock_tx(hw_priv);
+		}
+	}
+
+	return 0;
+}
+
+static void __bes2600_sta_notify(struct bes2600_vif *priv,
+				enum sta_notify_cmd notify_cmd,
+				int link_id)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	u32 bit, prev;
+
+	/* Zero link id means "for all link IDs" */
+	if (link_id)
+		bit = BIT(link_id);
+	else if (WARN_ON_ONCE(notify_cmd != STA_NOTIFY_AWAKE))
+		bit = 0;
+	else
+		bit = priv->link_id_map;
+	prev = priv->sta_asleep_mask & bit;
+
+	switch (notify_cmd) {
+	case STA_NOTIFY_SLEEP:
+		if (!prev) {
+			if (priv->buffered_multicasts &&
+					!priv->sta_asleep_mask)
+				queue_work(hw_priv->workqueue,
+					&priv->multicast_start_work);
+			priv->sta_asleep_mask |= bit;
+		}
+		break;
+	case STA_NOTIFY_AWAKE:
+		if (prev) {
+			priv->sta_asleep_mask &= ~bit;
+			priv->pspoll_mask &= ~bit;
+			if (priv->tx_multicast && link_id &&
+					!priv->sta_asleep_mask)
+				queue_work(hw_priv->workqueue,
+					&priv->multicast_stop_work);
+			bes2600_bh_wakeup(hw_priv);
+		}
+		break;
+	}
+}
+
+void bes2600_sta_notify(struct ieee80211_hw *dev,
+		       struct ieee80211_vif *vif,
+		       enum sta_notify_cmd notify_cmd,
+		       struct ieee80211_sta *sta)
+{
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct bes2600_sta_priv *sta_priv =
+		(struct bes2600_sta_priv *)&sta->drv_priv;
+
+	WARN_ON(priv->if_id == CW12XX_GENERIC_IF_ID);
+	spin_lock_bh(&priv->ps_state_lock);
+	__bes2600_sta_notify(priv, notify_cmd, sta_priv->link_id);
+	spin_unlock_bh(&priv->ps_state_lock);
+}
+
+static void bes2600_ps_notify(struct bes2600_vif *priv,
+		      int link_id, bool ps)
+{
+	if (link_id > CW1250_MAX_STA_IN_AP_MODE)
+		return;
+
+	bes2600_dbg(BES2600_DBG_TXRX, "%s for LinkId: %d. STAs asleep: %.8X\n",
+			ps ? "Stop" : "Start",
+			link_id, priv->sta_asleep_mask);
+
+	/* TODO:COMBO: __bes2600_sta_notify changed. */
+	__bes2600_sta_notify(priv,
+		ps ? STA_NOTIFY_SLEEP : STA_NOTIFY_AWAKE, link_id);
+}
+
+static int bes2600_set_tim_impl(struct bes2600_vif *priv, bool aid0_bit_set)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct sk_buff *skb;
+	struct wsm_update_ie update_ie = {
+		.what = WSM_UPDATE_IE_BEACON,
+		.count = 1,
+	};
+	u16 tim_offset, tim_length;
+
+	bes2600_dbg(BES2600_DBG_AP, "[AP] %s mcast: %s.\n",
+		__func__, aid0_bit_set ? "ena" : "dis");
+
+	skb = ieee80211_beacon_get_tim(priv->hw, priv->vif,
+			&tim_offset, &tim_length, 0);
+	if (!skb) {
+		if (!__bes2600_flush(hw_priv, true, priv->if_id))
+			wsm_unlock_tx(hw_priv);
+		return -ENOENT;
+	}
+
+	if (tim_offset && tim_length >= 6) {
+		/* Ignore DTIM count from mac80211:
+		 * firmware handles DTIM internally. */
+		skb->data[tim_offset + 2] = 0;
+
+		/* Set/reset aid0 bit */
+		if (aid0_bit_set)
+			skb->data[tim_offset + 4] |= 1;
+		else
+			skb->data[tim_offset + 4] &= ~1;
+	}
+
+	update_ie.ies = &skb->data[tim_offset];
+	update_ie.length = tim_length;
+	WARN_ON(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+
+	dev_kfree_skb(skb);
+
+	return 0;
+}
+
+void bes2600_set_tim_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, set_tim_work);
+	(void)bes2600_set_tim_impl(priv, priv->aid0_bit_set);
+}
+
+int bes2600_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,
+		   bool set)
+{
+	struct bes2600_sta_priv *sta_priv =
+		(struct bes2600_sta_priv *)&sta->drv_priv;
+	struct bes2600_vif *priv = sta_priv->priv;
+
+	WARN_ON(priv->if_id == CW12XX_GENERIC_IF_ID);
+	WARN_ON(priv->mode != NL80211_IFTYPE_AP);
+	queue_work(priv->hw_priv->workqueue, &priv->set_tim_work);
+	return 0;
+}
+
+void bes2600_set_cts_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, set_cts_work.work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	u8 erp_ie[3] = {WLAN_EID_ERP_INFO, 0x1, 0};
+	struct wsm_update_ie update_ie = {
+		.what = WSM_UPDATE_IE_BEACON,
+		.count = 1,
+		.ies = erp_ie,
+		.length = 3,
+	};
+	u32 erp_info;
+	__le32 use_cts_prot;
+	down(&hw_priv->conf_lock);
+	erp_info = priv->erp_info;
+	up(&hw_priv->conf_lock);
+	use_cts_prot =
+		erp_info & WLAN_ERP_USE_PROTECTION ?
+		__cpu_to_le32(1) : 0;
+
+	erp_ie[ERP_INFO_BYTE_OFFSET] = erp_info;
+
+	bes2600_dbg(BES2600_DBG_AP, "[STA] ERP information 0x%x\n", erp_info);
+
+	/* TODO:COMBO: If 2 interfaces are on the same channel they share
+	the same ERP values */
+	WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_NON_ERP_PROTECTION,
+				&use_cts_prot, sizeof(use_cts_prot),
+				priv->if_id));
+	/* If STA Mode update_ie is not required */
+	if (priv->mode != NL80211_IFTYPE_STATION) {
+		WARN_ON(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+	}
+
+	return;
+}
+
+static int bes2600_set_btcoexinfo(struct bes2600_vif *priv)
+{
+	struct wsm_override_internal_txrate arg;
+	int ret = 0;
+
+	if (priv->mode == NL80211_IFTYPE_STATION) {
+		/* Plumb PSPOLL and NULL template */
+		WARN_ON(bes2600_upload_pspoll(priv));
+		WARN_ON(bes2600_upload_null(priv));
+	} else {
+		return 0;
+	}
+
+	memset(&arg, 0, sizeof(struct wsm_override_internal_txrate));
+
+	if (!priv->vif->p2p) {
+		/* STATION mode */
+		if (priv->bss_params.operationalRateSet & ~0xF) {
+			bes2600_dbg(BES2600_DBG_AP, "[STA] STA has ERP rates\n");
+			/* G or BG mode */
+			arg.internalTxRate = (__ffs(
+			priv->bss_params.operationalRateSet & ~0xF));
+		} else {
+			bes2600_dbg(BES2600_DBG_AP, "[STA] STA has non ERP rates\n");
+			/* B only mode */
+			arg.internalTxRate = (__ffs(
+			priv->association_mode.basicRateSet));
+		}
+		arg.nonErpInternalTxRate = (__ffs(
+			priv->association_mode.basicRateSet));
+	} else {
+		/* P2P mode */
+		arg.internalTxRate = (__ffs(
+			priv->bss_params.operationalRateSet & ~0xF));
+		arg.nonErpInternalTxRate = (__ffs(
+			priv->bss_params.operationalRateSet & ~0xF));
+	}
+
+	bes2600_dbg(BES2600_DBG_AP, "[STA] BTCOEX_INFO"
+		"MODE %d, internalTxRate : %x, nonErpInternalTxRate: %x\n",
+		priv->mode,
+		arg.internalTxRate,
+		arg.nonErpInternalTxRate);
+
+	ret = WARN_ON(wsm_write_mib(cw12xx_vifpriv_to_hwpriv(priv),
+		WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+		&arg, sizeof(arg), priv->if_id));
+
+	return ret;
+}
+
+void bes2600_bss_info_changed(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *info,
+			     u64 changed)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct ieee80211_conf *conf = &dev->conf;
+	const u8 override_fpsm_timeout = BES2600_FASTPS_IDLE_TIME;
+
+	if (priv->if_id == CW12XX_GENERIC_IF_ID)
+		return;
+	bes2600_info(BES2600_DBG_AP, "BSS CHANGED:	%08llx\n", changed);
+	down(&hw_priv->conf_lock);
+	if (changed & BSS_CHANGED_BSSID) {
+		memcpy(priv->bssid, info->bssid, ETH_ALEN);
+		bes2600_setup_mac_pvif(priv);
+	}
+
+	/* TODO: BSS_CHANGED_IBSS */
+	if (changed & BSS_CHANGED_ARP_FILTER) {
+
+		struct wsm_arp_ipv4_filter filter = {0};
+		int i;
+		bes2600_dbg(BES2600_DBG_AP, "[STA] BSS_CHANGED_ARP_FILTER cnt: %d",
+			    vif->cfg.arp_addr_cnt);
+
+		if (vif->cfg.arp_addr_cnt > 0) {
+			bwifi_change_current_status(hw_priv, BWIFI_STATUS_GOT_IP);
+		}
+
+		/* Currently only one IP address is supported by firmware.
+		 * In case of more IPs arp filtering will be disabled. */
+		if (vif->cfg.arp_addr_cnt > 0 &&
+		    vif->cfg.arp_addr_cnt <= WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES) {
+			for (i = 0; i < vif->cfg.arp_addr_cnt; i++) {
+				filter.ipv4Address[i] = vif->cfg.arp_addr_list[i];
+				bes2600_dbg(BES2600_DBG_AP, "[STA] addr[%d]: 0x%X\n",
+					  i, filter.ipv4Address[i]);
+			}
+			if (vif->type == NL80211_IFTYPE_STATION)
+			        filter.enable = (u32)BES2600_ENABLE_ARP_FILTER_OFFLOAD;
+			else if (priv->join_status == BES2600_JOIN_STATUS_AP)
+			        filter.enable = (u32)(1<<1);
+			else
+			        filter.enable = 0;
+		} else
+			filter.enable = 0;
+
+		bes2600_dbg(BES2600_DBG_AP, "[STA] arp ip filter enable: %d\n",
+			  __le32_to_cpu(filter.enable));
+
+		if (filter.enable)
+			bes2600_set_arpreply(dev, vif);
+
+		priv->filter4 = filter;
+
+		if (filter.enable &&
+			(priv->join_status == BES2600_JOIN_STATUS_STA)) {
+			/* Firmware requires that value for this 1-byte field must
+			 * be specified in units of 500us. Values above the 128ms
+			 * threshold are not supported. */
+			if (conf->dynamic_ps_timeout >= 0x80)
+				priv->powersave_mode.fastPsmIdlePeriod = 0xFF;
+			else
+				priv->powersave_mode.fastPsmIdlePeriod =
+					conf->dynamic_ps_timeout << 1;
+
+			/* override fast psm idle time */
+			if (override_fpsm_timeout) {
+				priv->powersave_mode.fastPsmIdlePeriod =
+					override_fpsm_timeout << 1;
+			}
+
+			if (priv->setbssparams_done) {
+				if (priv->user_power_set_true)
+					priv->powersave_mode.pmMode = priv->user_pm_mode;
+				else if (!priv->power_set_true)
+					priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+			} else
+				priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+			priv->power_set_true = 0;
+			priv->user_power_set_true = 0;
+
+			if(!vif->cfg.ps) {
+				bes2600_pwr_set_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_PS_ACTIVE);
+			}
+		}
+
+		bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_GET_IP);
+	}
+
+	if (changed & BSS_CHANGED_BEACON) {
+		bes2600_dbg(BES2600_DBG_AP, "BSS_CHANGED_BEACON\n");
+		WARN_ON(bes2600_upload_beacon(priv));
+		WARN_ON(bes2600_update_beaconing(priv));
+	}
+
+	if (changed & BSS_CHANGED_BEACON_ENABLED) {
+		bes2600_dbg(BES2600_DBG_AP, "BSS_CHANGED_BEACON_ENABLED dummy\n");
+		priv->enable_beacon = info->enable_beacon;
+	}
+
+	if (changed & BSS_CHANGED_BEACON_INT) {
+		bes2600_dbg(BES2600_DBG_AP, "CHANGED_BEACON_INT\n");
+		/* Restart AP only when connected */
+		if (priv->join_status == BES2600_JOIN_STATUS_AP)
+			WARN_ON(bes2600_update_beaconing(priv));
+	}
+
+	if (changed & BSS_CHANGED_ASSOC) {
+		wsm_lock_tx(hw_priv);
+		priv->wep_default_key_id = -1;
+		wsm_unlock_tx(hw_priv);
+
+		if (!vif->cfg.assoc /* && !info->ibss_joined */) {
+			priv->cqm_link_loss_count = 100;
+			priv->cqm_beacon_loss_count = 50;
+			priv->cqm_tx_failure_thold = 0;
+		}
+		priv->cqm_tx_failure_count = 0;
+	}
+
+	if (changed &
+	    (BSS_CHANGED_ASSOC |
+	     BSS_CHANGED_BASIC_RATES |
+	     BSS_CHANGED_ERP_PREAMBLE |
+	     BSS_CHANGED_HT |
+	     BSS_CHANGED_ERP_SLOT)) {
+		int is_combo = 0;
+		int i;
+		struct bes2600_vif *tmp_priv;
+		bes2600_info(BES2600_DBG_AP, "BSS_CHANGED_ASSOC assoc: %d.\n", vif->cfg.assoc);
+		if (vif->cfg.assoc) { /* TODO: ibss_joined */
+			struct ieee80211_sta *sta = NULL;
+			if (info->dtim_period)
+				priv->join_dtim_period = info->dtim_period;
+			priv->beacon_int = info->beacon_int;
+
+			/* Associated: kill join timeout */
+			if(changed & BSS_CHANGED_ASSOC) {
+				cancel_delayed_work_sync(&priv->join_timeout);
+				bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_JOIN);
+				bes2600_pwr_set_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_GET_IP);
+				txrx_opt_timer_init(priv->hw_priv);
+			}
+
+			rcu_read_lock();
+			if (info->bssid)
+				sta = ieee80211_find_sta(vif, info->bssid);
+			if (sta) {
+				/* TODO:COMBO:Change this once
+				* mac80211 changes are available */
+				enum nl80211_channel_type ch_type;
+				BUG_ON(!hw_priv->channel);
+				hw_priv->ht_info.ht_cap = sta->deflink.ht_cap;
+				priv->bss_params.operationalRateSet =
+					__cpu_to_le32(
+					bes2600_rate_mask_to_wsm(hw_priv,
+					sta->deflink.supp_rates[
+						hw_priv->channel->band]));
+				rcu_read_unlock();
+				ch_type = cfg80211_get_chandef_type(&info->chandef);
+				bes2600_dbg(BES2600_DBG_AP, "[STA] ch %d, type: %d, HT oper mode: %d\n",
+					  hw_priv->channel->hw_value,
+					  ch_type, info->ht_operation_mode);
+				if ((changed & BSS_CHANGED_ASSOC) &&
+					priv->join_status == BES2600_JOIN_STATUS_STA) {
+					struct wsm_switch_channel channel;
+
+					hw_priv->ht_info.channel_type = ch_type;
+					channel.channelMode = hw_priv->ht_info.channel_type << 4;
+					channel.channelSwitchCount = 0;
+					channel.newChannelNumber = hw_priv->channel->hw_value;
+					wsm_switch_channel(hw_priv, &channel, priv->if_id);
+					bes2600_info(BES2600_DBG_AP, "channel type changed to %d !!!\n", hw_priv->ht_info.channel_type);
+				}
+				if (hw_priv->ht_info.operation_mode != info->ht_operation_mode)
+					hw_priv->ht_info.operation_mode = info->ht_operation_mode;
+
+				if (changed & BSS_CHANGED_ASSOC) {
+					if (hw_priv->channel->band != NL80211_BAND_2GHZ)
+						bwifi_change_current_status(hw_priv, BWIFI_STATUS_CONNECTED_5G);
+					else
+						bwifi_change_current_status(hw_priv, BWIFI_STATUS_CONNECTED);
+				}
+			} else {
+				rcu_read_unlock();
+
+				memset(&hw_priv->ht_info, 0, sizeof(hw_priv->ht_info));
+				priv->bss_params.operationalRateSet = -1;
+			}
+			//rcu_read_unlock();
+			priv->htcap = (sta && bes2600_is_ht(&hw_priv->ht_info));
+			bes2600_for_each_vif(hw_priv, tmp_priv, i) {
+				if ((i == (CW12XX_MAX_VIFS - 1)) || !tmp_priv)
+					continue;
+				if (tmp_priv->join_status >= BES2600_JOIN_STATUS_STA)
+					is_combo++;
+			}
+
+			if (is_combo > 1) {
+				hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+				hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+				bes2600_info(BES2600_DBG_AP, "ASSOC is_combo %d\n",hw_priv->vif0_throttle);
+			} else if ((priv->join_status == BES2600_JOIN_STATUS_STA) &&
+					priv->htcap) {
+				hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11N_THROTTLE;
+				hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11N_THROTTLE;
+				bes2600_info(BES2600_DBG_AP, "ASSOC HTCAP 11N %d\n",hw_priv->vif0_throttle);
+			} else {
+				hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+				hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+				bes2600_info(BES2600_DBG_AP, "ASSOC not_combo 11BG %d\n",hw_priv->vif0_throttle);
+			}
+
+			if (sta) {
+				__le32 val = 0;
+				if (hw_priv->ht_info.operation_mode &
+				IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT) {
+					bes2600_info(BES2600_DBG_AP, "[STA]"
+						" Non-GF STA present\n");
+					/* Non Green field capable STA */
+					val = __cpu_to_le32(BIT(1));
+				}
+				WARN_ON(wsm_write_mib(hw_priv,
+					WSM_MID_ID_SET_HT_PROTECTION,
+					&val, sizeof(val), priv->if_id));
+			}
+
+			priv->association_mode.greenfieldMode =
+				bes2600_ht_greenfield(&hw_priv->ht_info);
+			priv->association_mode.flags =
+				WSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES |
+				WSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE |
+				WSM_ASSOCIATION_MODE_USE_HT_MODE |
+				WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET |
+				WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING;
+			priv->association_mode.preambleType =
+				info->use_short_preamble ?
+				WSM_JOIN_PREAMBLE_SHORT :
+				WSM_JOIN_PREAMBLE_LONG;
+			priv->association_mode.basicRateSet = __cpu_to_le32(
+				bes2600_rate_mask_to_wsm(hw_priv,
+				info->basic_rates));
+			priv->association_mode.mpduStartSpacing =
+				bes2600_ht_ampdu_density(&hw_priv->ht_info);
+
+			priv->bss_params.beaconLostCount =
+					priv->cqm_beacon_loss_count ?
+					priv->cqm_beacon_loss_count :
+					priv->cqm_link_loss_count;
+
+			priv->bss_params.aid = vif->cfg.aid;
+
+			if (priv->join_dtim_period < 1)
+				priv->join_dtim_period = 1;
+
+			bes2600_dbg(BES2600_DBG_AP, "[STA] DTIM %d, interval: %d\n",
+				priv->join_dtim_period, priv->beacon_int);
+			bes2600_dbg(BES2600_DBG_AP, "[STA] Preamble: %d, " \
+				"Greenfield: %d, Aid: %d, " \
+				"Rates: 0x%.8X, Basic: 0x%.8X\n",
+				priv->association_mode.preambleType,
+				priv->association_mode.greenfieldMode,
+				priv->bss_params.aid,
+				priv->bss_params.operationalRateSet,
+				priv->association_mode.basicRateSet);
+			WARN_ON(wsm_set_association_mode(hw_priv,
+				&priv->association_mode, priv->if_id));
+			WARN_ON(wsm_keep_alive_period(hw_priv,
+				BES2600_KEEP_ALIVE_PERIOD /* sec */,
+				priv->if_id));
+			WARN_ON(wsm_set_bss_params(hw_priv, &priv->bss_params,
+				priv->if_id));
+			priv->setbssparams_done = true;
+			WARN_ON(wsm_set_beacon_wakeup_period(hw_priv,
+				    priv->beacon_int * priv->join_dtim_period >
+				    MAX_BEACON_SKIP_TIME_MS ? 1 :
+				    priv->join_dtim_period, 0, priv->if_id));
+			if (priv->htcap) {
+				wsm_lock_tx(hw_priv);
+				/* Statically enabling block ack for TX/RX */
+				WARN_ON(wsm_set_block_ack_policy(hw_priv,
+					hw_priv->ba_tid_mask, hw_priv->ba_tid_mask,
+						priv->if_id));
+				wsm_unlock_tx(hw_priv);
+			}
+
+			if (priv->vif->p2p) {
+				bes2600_dbg(BES2600_DBG_AP,
+					"[STA] Setting p2p powersave "
+					"configuration.\n");
+				WARN_ON(wsm_set_p2p_ps_modeinfo(hw_priv,
+					&priv->p2p_ps_modeinfo, priv->if_id));
+			}
+
+			if (priv->mode == NL80211_IFTYPE_STATION)
+				WARN_ON(bes2600_upload_qosnull(priv));
+
+			if (hw_priv->is_BT_Present)
+				WARN_ON(bes2600_set_btcoexinfo(priv));
+
+			atomic_set(&priv->connect_in_process, 0);
+			if (priv->delayed_unjoin) {
+				priv->delayed_unjoin = false;
+				bes2600_info(BES2600_DBG_AP, "queue delayed unjoin work for connect\n");
+				if (queue_work(hw_priv->workqueue, &priv->unjoin_work) <= 0)
+					wsm_unlock_tx(hw_priv);
+			}
+
+#if 0
+			/* It's better to override internal TX rete; otherwise
+			 * device sends RTS at too high rate. However device
+			 * can't receive CTS at 1 and 2 Mbps. Well, 5.5 is a
+			 * good choice for RTS/CTS, but that means PS poll
+			 * will be sent at the same rate - impact on link
+			 * budget. Not sure what is better.. */
+
+			/* Update: internal rate selection algorythm is not
+			 * bad: if device is not receiving CTS at high rate,
+			 * it drops RTS rate.
+			 * So, conclusion: if-0 the code. Keep code just for
+			 * information:
+			 * Do not touch WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE! */
+
+			/* ~3 is a bug in device: RTS/CTS is not working at
+			 * low rates */
+
+			__le32 internal_tx_rate = __cpu_to_le32(__ffs(
+				priv->association_mode.basicRateSet & ~3));
+			WARN_ON(wsm_write_mib(priv,
+				WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+				&internal_tx_rate,
+				sizeof(internal_tx_rate)));
+#endif
+		} else {
+			if (changed & BSS_CHANGED_ASSOC)
+				bwifi_change_current_status(hw_priv, BWIFI_STATUS_DISCONNECTED);
+			memset(&hw_priv->ht_info, 0,
+				sizeof(hw_priv->ht_info));
+			memset(&priv->association_mode, 0,
+				sizeof(priv->association_mode));
+			memset(&priv->bss_params, 0, sizeof(priv->bss_params));
+		}
+	}
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_CTS_PROT)) {
+		u32 prev_erp_info = priv->erp_info;
+
+		if (priv->join_status == BES2600_JOIN_STATUS_AP) {
+			if (info->use_cts_prot)
+				priv->erp_info |= WLAN_ERP_USE_PROTECTION;
+			else if (!(prev_erp_info & WLAN_ERP_NON_ERP_PRESENT))
+				priv->erp_info &= ~WLAN_ERP_USE_PROTECTION;
+
+			if (prev_erp_info != priv->erp_info)
+				queue_delayed_work(hw_priv->workqueue,
+						&priv->set_cts_work, 0*HZ);
+		}
+	}
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_ERP_SLOT)) {
+		__le32 slot_time = info->use_short_slot ?
+			__cpu_to_le32(9) : __cpu_to_le32(20);
+		bes2600_dbg(BES2600_DBG_AP, "[STA] Slot time :%d us.\n",
+			__le32_to_cpu(slot_time));
+		WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_SLOT_TIME,
+			&slot_time, sizeof(slot_time), priv->if_id));
+	}
+
+	if (changed & (BSS_CHANGED_ASSOC | BSS_CHANGED_CQM)) {
+		struct wsm_rcpi_rssi_threshold threshold = {
+			.rollingAverageCount = 8,
+		};
+
+		bes2600_dbg(BES2600_DBG_AP, "[CQM] RSSI threshold "
+			"subscribe: %d +- %d\n",
+			info->cqm_rssi_thold, info->cqm_rssi_hyst);
+		if (info->cqm_rssi_thold || info->cqm_rssi_hyst) {
+			/* RSSI subscription enabled */
+			/* TODO: It's not a correct way of setting threshold.
+			 * Upper and lower must be set equal here and adjusted
+			 * in callback. However current implementation is much
+			 * more relaible and stable. */
+			if (priv->cqm_use_rssi) {
+				threshold.upperThreshold =
+					info->cqm_rssi_thold +
+					info->cqm_rssi_hyst;
+				threshold.lowerThreshold =
+					info->cqm_rssi_thold;
+			} else {
+				/* convert RSSI to RCPI
+				 * RCPI = (RSSI + 110) * 2 */
+				threshold.upperThreshold =
+					(info->cqm_rssi_thold +
+					 info->cqm_rssi_hyst + 110) * 2;
+				threshold.lowerThreshold =
+					(info->cqm_rssi_thold + 110) * 2;
+			}
+			threshold.rssiRcpiMode |=
+				WSM_RCPI_RSSI_THRESHOLD_ENABLE;
+		} else {
+			/* There is a bug in FW, see sta.c. We have to enable
+			 * dummy subscription to get correct RSSI values. */
+			threshold.rssiRcpiMode |=
+				WSM_RCPI_RSSI_THRESHOLD_ENABLE |
+				WSM_RCPI_RSSI_DONT_USE_UPPER |
+				WSM_RCPI_RSSI_DONT_USE_LOWER;
+		}
+		WARN_ON(wsm_set_rcpi_rssi_threshold(hw_priv, &threshold,
+					priv->if_id));
+	}
+
+	if (changed & BSS_CHANGED_BANDWIDTH) {
+		enum nl80211_channel_type ch_type = cfg80211_get_chandef_type(&info->chandef);
+
+		if (vif->cfg.assoc &&
+		    hw_priv->ht_info.channel_type != ch_type &&
+		    priv->join_status == BES2600_JOIN_STATUS_STA) {
+			struct wsm_switch_channel channel;
+
+			hw_priv->ht_info.channel_type = ch_type;
+			channel.channelMode = hw_priv->ht_info.channel_type << 4;
+			channel.channelSwitchCount = 0;
+			channel.newChannelNumber = hw_priv->channel->hw_value;
+			wsm_switch_channel(hw_priv, &channel, priv->if_id);
+			bes2600_info(BES2600_DBG_AP, "channel type changed to %d !!!\n", hw_priv->ht_info.channel_type);
+		}
+	}
+
+	if (changed & BSS_CHANGED_PS) {
+		if (vif->cfg.ps == false)
+			priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+		else if (conf->dynamic_ps_timeout <= 0)
+			priv->powersave_mode.pmMode = WSM_PSM_PS;
+		else
+			priv->powersave_mode.pmMode = WSM_PSM_FAST_PS;
+
+		/* set/clear ps active power busy event */
+		if(priv->join_status == BES2600_JOIN_STATUS_STA) {
+			if(!vif->cfg.ps) {
+				bes2600_pwr_set_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_PS_ACTIVE);
+			} else {
+				bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_PS_ACTIVE);
+			}
+		}
+
+		bes2600_info(BES2600_DBG_AP, "[STA] Aid: %d, Joined: %s, Powersave: %s\n",
+			priv->bss_params.aid,
+			priv->join_status == BES2600_JOIN_STATUS_STA ? "yes" : "no",
+			priv->powersave_mode.pmMode == WSM_PSM_ACTIVE ? "WSM_PSM_ACTIVE" :
+			priv->powersave_mode.pmMode == WSM_PSM_PS ? "WSM_PSM_PS" :
+			priv->powersave_mode.pmMode == WSM_PSM_FAST_PS ? "WSM_PSM_FAST_PS" :
+			"UNKNOWN");
+
+		/* Firmware requires that value for this 1-byte field must
+		 * be specified in units of 500us. Values above the 128ms
+		 * threshold are not supported. */
+		if (conf->dynamic_ps_timeout >= 0x80)
+			priv->powersave_mode.fastPsmIdlePeriod = 0xFF;
+		else
+			priv->powersave_mode.fastPsmIdlePeriod =
+					conf->dynamic_ps_timeout << 1;
+
+		/* override fast psm idle time */
+		if (override_fpsm_timeout) {
+			priv->powersave_mode.fastPsmIdlePeriod =
+				override_fpsm_timeout << 1;
+		}
+
+		if (priv->join_status == BES2600_JOIN_STATUS_STA &&
+		    priv->bss_params.aid &&
+		    priv->setbssparams_done &&
+		    priv->filter4.enable &&
+		    priv->powersave_mode.pmMode == WSM_PSM_ACTIVE) {
+			bes2600_set_pm(priv, &priv->powersave_mode);
+		} else {
+			priv->power_set_true = 1;
+		}
+	}
+
+	up(&hw_priv->conf_lock);
+}
+
+void bes2600_multicast_start_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, multicast_start_work);
+	long tmo = priv->join_dtim_period *
+			(priv->beacon_int + 20) * HZ / 1024;
+
+	cancel_work_sync(&priv->multicast_stop_work);
+
+	if (!priv->aid0_bit_set) {
+		wsm_lock_tx(priv->hw_priv);
+		bes2600_set_tim_impl(priv, true);
+		priv->aid0_bit_set = true;
+		mod_timer(&priv->mcast_timeout, jiffies + tmo);
+		wsm_unlock_tx(priv->hw_priv);
+	}
+}
+
+void bes2600_multicast_stop_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, multicast_stop_work);
+
+	if (priv->aid0_bit_set) {
+		del_timer_sync(&priv->mcast_timeout);
+		wsm_lock_tx(priv->hw_priv);
+		priv->aid0_bit_set = false;
+		bes2600_set_tim_impl(priv, false);
+		wsm_unlock_tx(priv->hw_priv);
+	}
+}
+
+void bes2600_mcast_timeout(struct timer_list *t)
+{
+	struct bes2600_vif *priv = from_timer(priv, t, mcast_timeout);
+
+	wiphy_warn(priv->hw->wiphy,
+		"Multicast delivery timeout.\n");
+	spin_lock_bh(&priv->ps_state_lock);
+	priv->tx_multicast = priv->aid0_bit_set &&
+			priv->buffered_multicasts;
+	if (priv->tx_multicast)
+		bes2600_bh_wakeup(cw12xx_vifpriv_to_hwpriv(priv));
+	spin_unlock_bh(&priv->ps_state_lock);
+}
+
+int bes2600_ampdu_action(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif,
+			struct ieee80211_ampdu_params *params)
+{
+	/* Aggregation is implemented fully in firmware,
+	 * including block ack negotiation.
+	 * In case of AMPDU aggregation in RX direction
+	 * re-ordering of packets takes place on host. mac80211
+	 * needs the ADDBA Request to setup reodering.mac80211 also
+	 * sends ADDBA Response which is discarded in the driver as
+	 * FW generates the ADDBA Response on its own.*/
+	int ret;
+
+	switch (params->action) {
+	case IEEE80211_AMPDU_RX_START:
+	case IEEE80211_AMPDU_RX_STOP:
+		/* Just return OK to mac80211 */
+		ret = 0;
+		break;
+	default:
+		ret = -ENOTSUPP;
+	}
+	return ret;
+}
+
+/* ******************************************************************** */
+/* WSM callback								*/
+void bes2600_suspend_resume(struct bes2600_vif *priv,
+			   struct wsm_suspend_resume *arg)
+{
+	struct bes2600_common *hw_priv =
+		cw12xx_vifpriv_to_hwpriv(priv);
+
+	bes2600_dbg(BES2600_DBG_AP, "[AP] %s: %s\n",
+			arg->stop ? "stop" : "start",
+			arg->multicast ? "broadcast" : "unicast");
+
+	if (arg->multicast) {
+		bool cancel_tmo = false;
+		spin_lock_bh(&priv->ps_state_lock);
+		if (arg->stop) {
+			priv->tx_multicast = false;
+		} else {
+			/* Firmware sends this indication every DTIM if there
+			 * is a STA in powersave connected. There is no reason
+			 * to suspend, following wakeup will consume much more
+			 * power than it could be saved. */
+			u32 timeout = priv->join_dtim_period *
+				(priv->beacon_int + 20) * HZ / 1024;
+			timeout = jiffies_to_msecs(timeout);
+			bes2600_pwr_set_busy_event_with_timeout_async(hw_priv,
+				BES_PWR_LOCK_ON_MUL_REQ, timeout);
+
+			priv->tx_multicast = priv->aid0_bit_set &&
+					priv->buffered_multicasts;
+			if (priv->tx_multicast) {
+				cancel_tmo = true;
+				bes2600_bh_wakeup(hw_priv);
+			}
+		}
+		spin_unlock_bh(&priv->ps_state_lock);
+		if (cancel_tmo)
+			del_timer_sync(&priv->mcast_timeout);
+	} else {
+		spin_lock_bh(&priv->ps_state_lock);
+		bes2600_ps_notify(priv, arg->link_id, arg->stop);
+		spin_unlock_bh(&priv->ps_state_lock);
+		if (!arg->stop)
+			bes2600_bh_wakeup(hw_priv);
+	}
+	return;
+}
+
+/* ******************************************************************** */
+/* AP privates								*/
+
+static int bes2600_upload_beacon(struct bes2600_vif *priv)
+{
+	int ret = 0;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_BEACON,
+	};
+	struct ieee80211_mgmt *mgmt;
+	u8 *erp_inf, *ies, *ht_info;
+	u32 ies_len;
+
+	if (priv->vif->p2p ||
+		hw_priv->channel->band == NL80211_BAND_5GHZ)
+		frame.rate = WSM_TRANSMIT_RATE_6;
+
+	frame.skb = ieee80211_beacon_get(priv->hw, priv->vif, 0);
+	if (WARN_ON(!frame.skb))
+		return -ENOMEM;
+
+	mgmt = (void *)frame.skb->data;
+	ies = mgmt->u.beacon.variable;
+	ies_len = frame.skb->len - (u32)(ies - (u8 *)mgmt);
+
+	ht_info = (u8 *)cfg80211_find_ie( WLAN_EID_HT_OPERATION, ies, ies_len);
+        if (ht_info) {
+		/* Enable RIFS*/
+		ht_info[3] |= 8;
+        }
+
+	erp_inf = (u8 *)cfg80211_find_ie(WLAN_EID_ERP_INFO, ies, ies_len);
+	if (erp_inf) {
+		if (erp_inf[ERP_INFO_BYTE_OFFSET]
+				& WLAN_ERP_BARKER_PREAMBLE)
+			priv->erp_info |= WLAN_ERP_BARKER_PREAMBLE;
+		else
+			priv->erp_info &= ~WLAN_ERP_BARKER_PREAMBLE;
+
+		if (erp_inf[ERP_INFO_BYTE_OFFSET]
+				& WLAN_ERP_NON_ERP_PRESENT) {
+			priv->erp_info |= WLAN_ERP_USE_PROTECTION;
+			priv->erp_info |= WLAN_ERP_NON_ERP_PRESENT;
+		} else {
+			priv->erp_info &= ~WLAN_ERP_USE_PROTECTION;
+			priv->erp_info &= ~WLAN_ERP_NON_ERP_PRESENT;
+		}
+	}
+
+	ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+	if (!ret) {
+		/* TODO: Distille probe resp; remove TIM
+		 * and other beacon-specific IEs */
+		*(__le16 *)frame.skb->data =
+			__cpu_to_le16(IEEE80211_FTYPE_MGMT |
+				      IEEE80211_STYPE_PROBE_RESP);
+		frame.frame_type = WSM_FRAME_TYPE_PROBE_RESPONSE;
+		/* TODO: Ideally probe response template should separately
+		   configured by supplicant through openmac. This is a
+		   temporary work-around known to fail p2p group info
+		   attribute related tests
+		   */
+		if (0 /* priv->vif->p2p */)
+			ret = wsm_set_probe_responder(priv, true);
+		else {
+			ret = wsm_set_template_frame(hw_priv, &frame,
+					priv->if_id);
+			WARN_ON(wsm_set_probe_responder(priv, false));
+		}
+	}
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+
+static int bes2600_upload_pspoll(struct bes2600_vif *priv)
+{
+	int ret = 0;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PS_POLL,
+		.rate = 0xFF,
+	};
+
+
+	frame.skb = ieee80211_pspoll_get(priv->hw, priv->vif);
+	if (WARN_ON(!frame.skb))
+		return -ENOMEM;
+
+	ret = wsm_set_template_frame(cw12xx_vifpriv_to_hwpriv(priv), &frame,
+				priv->if_id);
+
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+
+static int bes2600_upload_null(struct bes2600_vif *priv)
+{
+	int ret = 0;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_NULL,
+		.rate = 0xFF,
+	};
+
+	frame.skb = ieee80211_nullfunc_get(priv->hw, priv->vif, 0, false);
+	if (WARN_ON(!frame.skb))
+		return -ENOMEM;
+
+	ret = wsm_set_template_frame(cw12xx_vifpriv_to_hwpriv(priv),
+				&frame, priv->if_id);
+
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+
+static int bes2600_upload_qosnull(struct bes2600_vif *priv)
+{
+	int ret = 0;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_QOS_NULL,
+		.rate = 0xFF,
+	};
+
+	frame.skb = ieee80211_nullfunc_get(priv->hw, priv->vif, 0, true);
+	if (WARN_ON(!frame.skb))
+		return -ENOMEM;
+
+	ret = wsm_set_template_frame(hw_priv, &frame, priv->if_id);
+
+	dev_kfree_skb(frame.skb);
+
+	return ret;
+}
+
+static int start_dhcpd(void)
+{
+	volatile int result=0;
+	char cmdPath[]="/bin/bash";
+	char* cmdArgv[]={cmdPath, "-c", "/usr/bin/start_dhcpd > /tmp/log", NULL};
+	char* cmdEnvp[]={"HOME=/", "PATH=/sbin:/bin:/usr/bin:/usr/sbin", NULL};
+
+	result=call_usermodehelper(cmdPath,cmdArgv,cmdEnvp, UMH_WAIT_EXEC);
+	bes2600_info(BES2600_DBG_AP, "testDriver1 _init exec! The result of call_usermodehelper is %d\n",result);
+	bes2600_info(BES2600_DBG_AP, "testDriver1 _init exec! The process is \"%s\",pid is %d\n",current->comm,current->pid);
+
+	return 0;
+}
+
+
+static int bes2600_start_ap(struct bes2600_vif *priv)
+{
+	int ret;
+	const u8 *ssidie;
+	struct sk_buff *skb;
+	int offset;
+	struct ieee80211_bss_conf *conf = &priv->vif->bss_conf;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_start start = {
+		.mode = priv->vif->p2p ?
+				WSM_START_MODE_P2P_GO : WSM_START_MODE_AP,
+		/* TODO:COMBO:Change once mac80211 support is available */
+		.band = (hw_priv->channel->band == NL80211_BAND_5GHZ) ?
+				WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.channelNumber = hw_priv->channel->hw_value,
+		.beaconInterval = conf->beacon_int,
+		.DTIMPeriod = conf->dtim_period,
+		.preambleType = conf->use_short_preamble ?
+				WSM_JOIN_PREAMBLE_SHORT :
+				WSM_JOIN_PREAMBLE_LONG,
+		.probeDelay = 100,
+		.basicRateSet = bes2600_rate_mask_to_wsm(hw_priv,
+				conf->basic_rates),
+		.CTWindow = priv->if_id ? 0xFFFFFFFF : 0, /* it makes addr1's byte4 ^0x80 in firmware,
+			which matches with driver's addr2 */
+	};
+
+	struct wsm_switch_channel channel = {
+		.channelMode = (cfg80211_get_chandef_type(&conf->chandef)) << 4,
+		.channelSwitchCount = 0,
+		.newChannelNumber = hw_priv->channel->hw_value,
+	};
+
+	struct wsm_inactivity inactivity = {
+		.min_inactivity = 9,
+		.max_inactivity = 1,
+	};
+
+	if (priv->vif->p2p) {
+		start_dhcpd();
+		hw_priv->ht_info.channel_type = cfg80211_get_chandef_type(&conf->chandef);
+	}
+
+	if (priv->if_id)
+		start.mode |= WSM_FLAG_MAC_INSTANCE_1;
+	else
+		start.mode &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+	hw_priv->connected_sta_cnt = 0;
+
+	/* Get SSID */
+	skb = ieee80211_beacon_get(priv->hw, priv->vif, 0);
+	if (WARN_ON(!skb))
+		return -ENOMEM;
+
+	offset = offsetof(struct ieee80211_mgmt, u.beacon.variable);
+	ssidie = cfg80211_find_ie(WLAN_EID_SSID, skb->data + offset,
+				  skb->len - offset);
+
+	memset(priv->ssid, 0, sizeof(priv->ssid));
+	if (ssidie) {
+		priv->ssid_length = ssidie[1];
+		if (WARN_ON(priv->ssid_length > sizeof(priv->ssid)))
+			priv->ssid_length = sizeof(priv->ssid);
+		memcpy(priv->ssid, &ssidie[2], priv->ssid_length);
+	} else {
+		priv->ssid_length = 0;
+	}
+	dev_kfree_skb(skb);
+
+	priv->beacon_int = conf->beacon_int;
+	priv->join_dtim_period = conf->dtim_period;
+
+	start.ssidLength = priv->ssid_length;
+	memcpy(&start.ssid[0], priv->ssid, start.ssidLength);
+
+	memset(&priv->link_id_db, 0, sizeof(priv->link_id_db));
+
+	bes2600_info(BES2600_DBG_AP, "[AP] ch: %d(%d), bcn: %d(%d), "
+		"brt: 0x%.8X, ssid: %.*s.\n",
+		start.channelNumber, start.band,
+		start.beaconInterval, start.DTIMPeriod,
+		start.basicRateSet,
+		start.ssidLength, start.ssid);
+	ret = WARN_ON(wsm_start(hw_priv, &start, priv->if_id));
+	if (!ret)
+		ret = wsm_switch_channel(hw_priv, &channel, priv->if_id);
+
+	if (!ret && priv->vif->p2p) {
+		bes2600_dbg(BES2600_DBG_AP, "[AP] Setting p2p powersave "
+			"configuration.\n");
+		WARN_ON(wsm_set_p2p_ps_modeinfo(hw_priv,
+			&priv->p2p_ps_modeinfo, priv->if_id));
+	}
+
+	/*Set Inactivity time*/
+	if (!(strstr(&start.ssid[0], "6.1.12"))) {
+		wsm_set_inactivity(hw_priv, &inactivity, priv->if_id);
+	}
+	if (!ret) {
+		if ((priv->if_id ==2) && !hw_priv->is_go_thru_go_neg)
+			WARN_ON(wsm_set_block_ack_policy(hw_priv,
+				BES2600_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+				BES2600_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID,
+				priv->if_id));
+		else
+		WARN_ON(wsm_set_block_ack_policy(hw_priv,
+			BES2600_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+			BES2600_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID,
+			priv->if_id));
+		priv->join_status = BES2600_JOIN_STATUS_AP;
+		bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_AP);
+		/* bes2600_update_filtering(priv); */
+	}
+	hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+	hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+	bes2600_info(BES2600_DBG_AP, "AP/GO mode BG THROTTLE %d\n", hw_priv->vif0_throttle);
+	return ret;
+}
+
+static int bes2600_update_beaconing(struct bes2600_vif *priv)
+{
+	struct ieee80211_bss_conf *conf = &priv->vif->bss_conf;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_reset reset = {
+		.link_id = 0,
+		.reset_statistics = true,
+	};
+
+	if (priv->mode == NL80211_IFTYPE_AP) {
+		/* TODO: check if changed channel, band */
+		if (priv->join_status != BES2600_JOIN_STATUS_AP ||
+		    priv->beacon_int != conf->beacon_int) {
+			bes2600_dbg(BES2600_DBG_AP, "ap restarting\n");
+			wsm_lock_tx(hw_priv);
+			if (priv->join_status != BES2600_JOIN_STATUS_PASSIVE)
+				WARN_ON(wsm_reset(hw_priv, &reset,
+						  priv->if_id));
+			priv->join_status = BES2600_JOIN_STATUS_PASSIVE;
+			WARN_ON(bes2600_start_ap(priv));
+			wsm_unlock_tx(hw_priv);
+		} else
+			bes2600_dbg(BES2600_DBG_AP, "ap started join_status: %d\n",
+				  priv->join_status);
+	}
+	return 0;
+}
+
+int bes2600_find_link_id(struct bes2600_vif *priv, const u8 *mac)
+{
+	int i, ret = 0;
+	spin_lock_bh(&priv->ps_state_lock);
+
+	for (i = 0; i < CW1250_MAX_STA_IN_AP_MODE; ++i) {
+		if (!memcmp(mac, priv->link_id_db[i].mac, ETH_ALEN) &&
+				priv->link_id_db[i].status) {
+			priv->link_id_db[i].timestamp = jiffies;
+			ret = i + 1;
+			break;
+		}
+	}
+	spin_unlock_bh(&priv->ps_state_lock);
+	return ret;
+}
+
+int bes2600_alloc_link_id(struct bes2600_vif *priv, const u8 *mac)
+{
+	int i, ret = 0;
+	unsigned long max_inactivity = 0;
+	unsigned long now = jiffies;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	spin_lock_bh(&priv->ps_state_lock);
+	for (i = 0; i < CW1250_MAX_STA_IN_AP_MODE; ++i) {
+		if (!priv->link_id_db[i].status) {
+			ret = i + 1;
+			break;
+		} else if (priv->link_id_db[i].status != BES2600_LINK_HARD &&
+			!hw_priv->tx_queue_stats.link_map_cache[i + 1]) {
+
+			unsigned long inactivity =
+					now - priv->link_id_db[i].timestamp;
+			if (inactivity < max_inactivity)
+				continue;
+			max_inactivity = inactivity;
+			ret = i + 1;
+		}
+	}
+	if (ret) {
+		struct bes2600_link_entry *entry = &priv->link_id_db[ret - 1];
+		bes2600_dbg(BES2600_DBG_AP, "[AP] STA added, link_id: %d\n",
+			ret);
+		entry->status = BES2600_LINK_RESERVE;
+		memcpy(&entry->mac, mac, ETH_ALEN);
+		memset(&entry->buffered, 0, BES2600_MAX_TID);
+		skb_queue_head_init(&entry->rx_queue);
+		wsm_lock_tx_async(hw_priv);
+		if (queue_work(hw_priv->workqueue, &priv->link_id_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+	} else {
+		wiphy_info(priv->hw->wiphy,
+			"[AP] Early: no more link IDs available.\n");
+	}
+
+	spin_unlock_bh(&priv->ps_state_lock);
+	return ret;
+}
+
+void bes2600_link_id_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, link_id_work);
+	struct bes2600_common *hw_priv = priv->hw_priv;
+
+	wsm_flush_tx(hw_priv);
+	bes2600_link_id_gc_work(&priv->link_id_gc_work.work);
+	wsm_unlock_tx(hw_priv);
+}
+
+void bes2600_link_id_gc_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, link_id_gc_work.work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_map_link map_link = {
+		.link_id = 0,
+	};
+	unsigned long now = jiffies;
+	unsigned long next_gc = -1;
+	long ttl;
+	bool need_reset;
+	u32 mask;
+	int i;
+
+	if (priv->join_status != BES2600_JOIN_STATUS_AP)
+		return;
+
+	wsm_lock_tx(hw_priv);
+	spin_lock_bh(&priv->ps_state_lock);
+	for (i = 0; i < CW1250_MAX_STA_IN_AP_MODE; ++i) {
+		need_reset = false;
+		mask = BIT(i + 1);
+		if (priv->link_id_db[i].status == BES2600_LINK_RESERVE ||
+			(priv->link_id_db[i].status == BES2600_LINK_HARD &&
+			 !(priv->link_id_map & mask))) {
+			if (priv->link_id_map & mask) {
+				priv->sta_asleep_mask &= ~mask;
+				priv->pspoll_mask &= ~mask;
+				need_reset = true;
+			}
+			priv->link_id_map |= mask;
+			if (priv->link_id_db[i].status != BES2600_LINK_HARD)
+				priv->link_id_db[i].status = BES2600_LINK_SOFT;
+			memcpy(map_link.mac_addr, priv->link_id_db[i].mac,
+					ETH_ALEN);
+			spin_unlock_bh(&priv->ps_state_lock);
+			if (need_reset) {
+				WARN_ON(cw12xx_unmap_link(priv, i + 1));
+			}
+			map_link.link_id = i + 1;
+			WARN_ON(wsm_map_link(hw_priv, &map_link, priv->if_id));
+			next_gc = min(next_gc, BES2600_LINK_ID_GC_TIMEOUT);
+			spin_lock_bh(&priv->ps_state_lock);
+		} else if (priv->link_id_db[i].status == BES2600_LINK_SOFT) {
+			ttl = priv->link_id_db[i].timestamp - now +
+					BES2600_LINK_ID_GC_TIMEOUT;
+			if (ttl <= 0) {
+				need_reset = true;
+				priv->link_id_db[i].status = BES2600_LINK_OFF;
+				priv->link_id_map &= ~mask;
+				priv->sta_asleep_mask &= ~mask;
+				priv->pspoll_mask &= ~mask;
+				memset(map_link.mac_addr, 0, ETH_ALEN);
+				spin_unlock_bh(&priv->ps_state_lock);
+				WARN_ON(cw12xx_unmap_link(priv, i + 1));
+				spin_lock_bh(&priv->ps_state_lock);
+			} else {
+				next_gc = min_t(unsigned long, next_gc, ttl);
+			}
+		}
+		if (need_reset) {
+			skb_queue_purge(&priv->link_id_db[i].rx_queue);
+			bes2600_dbg(BES2600_DBG_AP, "[AP] STA removed, link_id: %d\n",
+					i + 1);
+		}
+	}
+	spin_unlock_bh(&priv->ps_state_lock);
+	if (next_gc != -1)
+		queue_delayed_work(hw_priv->workqueue,
+				&priv->link_id_gc_work, next_gc);
+	wsm_unlock_tx(hw_priv);
+}
+
+int cw12xx_unmap_link(struct bes2600_vif *priv, int link_id)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	int ret = 0;
+
+	if (is_hardware_cw1250(hw_priv) || is_hardware_cw1260(hw_priv)) {
+		struct wsm_map_link maplink = {
+			.link_id = link_id,
+			.unmap = true,
+		};
+		if (link_id)
+			memcpy(&maplink.mac_addr[0],
+				priv->link_id_db[link_id - 1].mac, ETH_ALEN);
+		return wsm_map_link(hw_priv, &maplink, priv->if_id);
+	} else {
+		struct wsm_reset reset = {
+			.link_id = link_id,
+			.reset_statistics = true,
+		};
+		ret = wsm_reset(hw_priv, &reset, priv->if_id);
+		return ret;
+	}
+}
+
+void bes2600_ht_info_update_work(struct work_struct *work)
+{
+        struct sk_buff *skb;
+        struct ieee80211_mgmt *mgmt;
+        u8 *ht_info, *ies;
+        u32 ies_len;
+        struct bes2600_vif *priv =
+                container_of(work, struct bes2600_vif, ht_info_update_work);
+        struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+        struct wsm_update_ie update_ie = {
+                .what = WSM_UPDATE_IE_BEACON,
+                .count = 1,
+        };
+
+        skb = ieee80211_beacon_get(priv->hw, priv->vif, 0);
+	if (WARN_ON(!skb))
+		return;
+
+        mgmt = (void *)skb->data;
+        ies = mgmt->u.beacon.variable;
+        ies_len = skb->len - (u32)(ies - (u8 *)mgmt);
+        ht_info= (u8 *)cfg80211_find_ie( WLAN_EID_HT_OPERATION, ies, ies_len);
+        if(ht_info && priv->ht_info == HT_INFO_MASK) {
+
+        ht_info[HT_INFO_OFFSET] |= 0x11;
+        update_ie.ies = ht_info;
+        update_ie.length = HT_INFO_IE_LEN;
+
+        WARN_ON(wsm_update_ie(hw_priv, &update_ie, priv->if_id));
+
+
+        }
+	dev_kfree_skb(skb);
+}
diff --git a/drivers/staging/bes2600/ap.h b/drivers/staging/bes2600/ap.h
new file mode 100755
index 000000000000..b776d8ad91d8
--- /dev/null
+++ b/drivers/staging/bes2600/ap.h
@@ -0,0 +1,49 @@
+/*
+ * mac80211 STA and AP API for mac80211 BES2600 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/version.h>
+#ifndef AP_H_INCLUDED
+#define AP_H_INCLUDED
+
+#define BES2600_NOA_NOTIFICATION_DELAY 10
+
+int bes2600_set_tim(struct ieee80211_hw *dev, struct ieee80211_sta *sta,
+		   bool set);
+int bes2600_sta_add(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		   struct ieee80211_sta *sta);
+int bes2600_sta_remove(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		      struct ieee80211_sta *sta);
+void bes2600_sta_notify(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+		       enum sta_notify_cmd notify_cmd,
+		       struct ieee80211_sta *sta);
+void bes2600_bss_info_changed(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif,
+			     struct ieee80211_bss_conf *info,
+			     u64 changed);
+
+int bes2600_ampdu_action(struct ieee80211_hw *hw,
+			struct ieee80211_vif *vif,
+			struct ieee80211_ampdu_params *params);
+
+void bes2600_suspend_resume(struct bes2600_vif *priv,
+			  struct wsm_suspend_resume *arg);
+void bes2600_set_tim_work(struct work_struct *work);
+void bes2600_set_cts_work(struct work_struct *work);
+void bes2600_multicast_start_work(struct work_struct *work);
+void bes2600_multicast_stop_work(struct work_struct *work);
+void bes2600_mcast_timeout(struct timer_list *t);
+int bes2600_find_link_id(struct bes2600_vif *priv, const u8 *mac);
+int bes2600_alloc_link_id(struct bes2600_vif *priv, const u8 *mac);
+void bes2600_link_id_work(struct work_struct *work);
+void bes2600_link_id_gc_work(struct work_struct *work);
+int cw12xx_unmap_link(struct bes2600_vif *priv, int link_id);
+void bes2600_ht_info_update_work(struct work_struct *work);
+
+#endif
diff --git a/drivers/staging/bes2600/bes2600.h b/drivers/staging/bes2600/bes2600.h
new file mode 100755
index 000000000000..c6361c10b26a
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600.h
@@ -0,0 +1,553 @@
+/*
+ * Common private data for BES2600 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * Based on the mac80211 Prism54 code, which is
+ * Copyright (c) 2006, Michael Wu <flamingice@sourmilk.net>
+ *
+ * Based on the islsm (softmac prism54) driver, which is:
+ * Copyright 2004-2006 Jean-Baptiste Note <jbnote@gmail.com>, et al.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_H
+#define BES2600_H
+
+#include <linux/wait.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+#include <linux/sched.h>
+#include <linux/atomic.h>
+#include <linux/usb.h>
+#include <net/mac80211.h>
+#define CW12XX_MAX_VIFS			(3)
+#define CW12XX_GENERIC_IF_ID		(2)
+#define CW12XX_HOST_VIF0_11N_THROTTLE	(63)
+#define CW12XX_HOST_VIF1_11N_THROTTLE	(63)
+#define CW12XX_HOST_VIF0_11BG_THROTTLE	(15)
+#define CW12XX_HOST_VIF1_11BG_THROTTLE	(15)
+#define CW12XX_MAX_QUEUE_SZ		(128)
+
+#define IEEE80211_FCTL_WEP      0x4000
+#define IEEE80211_QOS_DATAGRP   0x0080
+#define WSM_KEY_MAX_IDX		20
+
+#include "queue.h"
+#include "wsm.h"
+#include "scan.h"
+#include "txrx.h"
+#include "ht.h"
+#include "pm.h"
+#include "fwio.h"
+#include "bes2600_log.h"
+#include "bes_pwr.h"
+#include "tx_loop.h"
+
+/* extern */ struct sbus_ops;
+/* extern */ struct task_struct;
+/* extern */ struct bes2600_debug_priv;
+/* extern */ struct bes2600_debug_common;
+/* extern */ struct firmware;
+
+#define txrx_printk(...)
+
+#define BES2600_MAX_CTRL_FRAME_LEN	(0x1000)
+
+#define CW1250_MAX_STA_IN_AP_MODE	(14)
+#define WLAN_LINK_ID_MAX		(CW1250_MAX_STA_IN_AP_MODE + 3)
+
+#define BES2600_MAX_STA_IN_AP_MODE	(5)
+#define BES2600_MAX_REQUEUE_ATTEMPTS	(5)
+#define BES2600_LINK_ID_UNMAPPED		(15)
+
+#define BES2600_MAX_TID			(8)
+
+#define BES2600_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID         (0x3F)
+#define BES2600_RX_BLOCK_ACK_ENABLED_FOR_ALL_TID         (0x3F)
+#define BES2600_RX_BLOCK_ACK_ENABLED_FOR_BE_TID \
+	(BES2600_TX_BLOCK_ACK_ENABLED_FOR_ALL_TID & 0x01)
+#define BES2600_TX_BLOCK_ACK_DISABLED_FOR_ALL_TID	(0)
+#define BES2600_RX_BLOCK_ACK_DISABLED_FOR_ALL_TID	(0)
+
+#define BES2600_BLOCK_ACK_CNT		(30)
+#define BES2600_BLOCK_ACK_THLD		(800)
+#define BES2600_BLOCK_ACK_HIST		(3)
+#define BES2600_BLOCK_ACK_INTERVAL	(1 * HZ / BES2600_BLOCK_ACK_HIST)
+#define CW12XX_ALL_IFS			(-1)
+
+#define IEEE80211_FCTL_WEP      0x4000
+#define IEEE80211_QOS_DATAGRP   0x0080
+
+#define BSS_LOSS_CK_THR		1
+#define BSS_LOSS_CK_INV		2000
+#define BSS_LOSS_CFM_THR	1
+#define BSS_LOSS_CFM_INV	200
+
+/* Please keep order */
+enum bes2600_join_status {
+	BES2600_JOIN_STATUS_PASSIVE = 0,
+	BES2600_JOIN_STATUS_MONITOR,
+	BES2600_JOIN_STATUS_STA,
+	BES2600_JOIN_STATUS_AP,
+};
+
+enum bes2600_link_status {
+	BES2600_LINK_OFF,
+	BES2600_LINK_RESERVE,
+	BES2600_LINK_SOFT,
+	BES2600_LINK_HARD,
+};
+
+enum bes2600_bss_loss_status {
+	BES2600_BSS_LOSS_NONE,
+	BES2600_BSS_LOSS_CHECKING,
+	BES2600_BSS_LOSS_CONFIRMING,
+	BES2600_BSS_LOSS_CONFIRMED,
+};
+
+struct bes2600_link_entry {
+	unsigned long			timestamp;
+	enum bes2600_link_status	status;
+	u8				mac[ETH_ALEN];
+	u8				buffered[BES2600_MAX_TID];
+	struct sk_buff_head		rx_queue;
+};
+
+struct bes2600_common {
+	struct bes2600_debug_common	*debug;
+	struct bes2600_queue		tx_queue[4];
+	struct bes2600_queue_stats	tx_queue_stats;
+
+	struct ieee80211_hw		*hw;
+	struct mac_address		addresses[CW12XX_MAX_VIFS];
+
+	/*Will be a pointer to a list of VIFs - Dynamically allocated */
+	struct ieee80211_vif		*vif_list[CW12XX_MAX_VIFS];
+	atomic_t			num_vifs;
+	atomic_t			netdevice_start;
+	spinlock_t			vif_list_lock;
+	u32				if_id_slot;
+	struct device			*pdev;
+	struct workqueue_struct		*workqueue;
+
+	struct semaphore		conf_lock;
+
+	const struct sbus_ops		*sbus_ops;
+	struct sbus_priv		*sbus_priv;
+
+	/* HW/FW type (HIF_...) */
+	int				hw_type;
+	int				hw_revision;
+	int				fw_revision;
+
+	/* firmware/hardware info */
+	unsigned int tx_hdr_len;
+
+	/* Radio data */
+	int output_power;
+	int noise;
+
+	/* calibration, output power limit and rssi<->dBm conversation data */
+
+	/* BBP/MAC state */
+	const struct firmware		*sdd;
+	struct ieee80211_rate		*rates;
+	struct ieee80211_rate		*mcs_rates;
+	u8 mac_addr[ETH_ALEN];
+	/*TODO:COMBO: To be made per VIFF after mac80211 support */
+	struct ieee80211_channel	*channel;
+	int				channel_switch_in_progress;
+	wait_queue_head_t		channel_switch_done;
+	u8				long_frame_max_tx_count;
+	u8				short_frame_max_tx_count;
+	/* TODO:COMBO: According to Hong aggregation will happen per VIFF.
+	* Keeping in common structure for the time being. Will be moved to VIFF
+	* after the mechanism is clear */
+	u8				ba_tid_mask;
+	int				ba_acc; /*TODO: Same as above */
+	int				ba_cnt; /*TODO: Same as above */
+	int				ba_cnt_rx; /*TODO: Same as above */
+	int				ba_acc_rx; /*TODO: Same as above */
+	int				ba_hist; /*TODO: Same as above */
+	struct timer_list		ba_timer;/*TODO: Same as above */
+	spinlock_t			ba_lock; /*TODO: Same as above */
+	bool				ba_ena; /*TODO: Same as above */
+	struct work_struct              ba_work; /*TODO: Same as above */
+	bool				is_BT_Present;
+	bool				is_go_thru_go_neg;
+	u8				conf_listen_interval;
+
+	/* BH */
+	atomic_t			bh_rx;
+	atomic_t			bh_tx;
+	atomic_t			bh_term;
+	atomic_t			bh_suspend;
+
+	struct workqueue_struct         *bh_workqueue;
+	struct work_struct              bh_work;
+
+	int				bh_error;
+	wait_queue_head_t		bh_wq;
+	wait_queue_head_t		bh_evt_wq;
+	int				buf_id_tx;	/* byte */
+	int				buf_id_rx;	/* byte */
+	int				wsm_rx_seq[2];	/* idx 0: Normal tx/rx, idx 1: special cmd */
+	int				wsm_tx_seq[2];	/* idx 0: Normal tx/rx, idx 1: special cmd */
+	int				wsm_tx_pending[2];	/* idx 0: Normal tx/rx, idx 1: special cmd */
+	struct timer_list		mcu_mon_timer;
+	struct timer_list		lmac_mon_timer;
+	int				hw_bufs_used;
+	int				hw_bufs_used_vif[CW12XX_MAX_VIFS];
+	struct sk_buff			*skb_cache;
+	/* Keep bes2600 awake (WUP = 1) 1 second after each scan to avoid
+	 * FW issue with sleeping/waking up. */
+	atomic_t			recent_scan;
+
+	/* WSM */
+	struct wsm_caps			wsm_caps;
+	struct semaphore		wsm_cmd_sema;
+	struct wsm_buf			wsm_cmd_buf;
+	struct wsm_cmd			wsm_cmd;
+	wait_queue_head_t		wsm_cmd_wq;
+	wait_queue_head_t		wsm_startup_done;
+	struct wsm_cbc			wsm_cbc;
+	atomic_t			tx_lock;
+	u32				pending_frame_id;
+
+	/* WSM debug */
+	int				wsm_enable_wsm_dumps;
+	u32				wsm_dump_max_size;
+
+	/* Scan status */
+	struct bes2600_scan scan;
+
+	/* TX/RX */
+	unsigned long		rx_timestamp;
+
+	/* Scan Timestamp */
+	unsigned long		scan_timestamp;
+
+	/* WSM events */
+	spinlock_t		event_queue_lock;
+	struct list_head	event_queue;
+	struct work_struct	event_handler;
+
+	/* TX rate policy cache */
+	struct tx_policy_cache tx_policy_cache;
+	struct work_struct tx_policy_upload_work;
+
+	/* cryptographic engine information */
+
+	/* bit field of glowing LEDs */
+	u16 softled_state;
+
+	/* statistics */
+	struct ieee80211_low_level_stats stats;
+
+	struct bes2600_ht_info		ht_info;
+	int				tx_burst_idx;
+
+	struct ieee80211_iface_limit		if_limits1[2];
+	struct ieee80211_iface_limit		if_limits2[2];
+	struct ieee80211_iface_limit		if_limits3[2];
+	struct ieee80211_iface_combination	if_combs[3];
+
+	struct semaphore		wsm_oper_lock;
+	struct delayed_work		rem_chan_timeout;
+	MIB_TXRX_OPT_PARAM		txrx_opt_param;
+	u32 					rtsvalue;
+	spinlock_t				rtsvalue_lock;
+	struct timer_list		txrx_opt_timer;
+	struct work_struct		dynamic_opt_txrx_work;
+	atomic_t			remain_on_channel;
+	int				roc_if_id;
+	u64				roc_cookie;
+	wait_queue_head_t		offchannel_wq;
+	u16				offchannel_done;
+	u16				prev_channel;
+	int				if_id_selected;
+	u32				key_map;
+	struct wsm_add_key		keys[WSM_KEY_MAX_INDEX + 1];
+	u8      connected_sta_cnt;
+	u16     vif0_throttle;
+	u16     vif1_throttle;
+	int     scan_switch_if_id;
+
+	/* member for coexistence */
+	struct work_struct coex_work;
+	struct list_head coex_event_list;
+	spinlock_t coex_event_lock;
+
+	/* member for low power */
+	struct bes2600_pwr_t bes_power;
+
+	/* member for tx loop */
+	struct bes2600_tx_loop tx_loop;
+};
+
+/* Virtual Interface State. One copy per VIF */
+struct bes2600_vif {
+	atomic_t			enabled;
+	spinlock_t			vif_lock;
+	int				if_id;
+	/*TODO: Split into Common and VIF parts */
+	struct bes2600_debug_priv	*debug;
+	/* BBP/MAC state */
+	u8 bssid[ETH_ALEN];
+	struct wsm_edca_params		edca;
+	struct wsm_tx_queue_params	tx_queue_params;
+	struct wsm_association_mode	association_mode;
+	struct wsm_set_bss_params	bss_params;
+	struct wsm_set_pm		powersave_mode;
+	struct wsm_set_pm		firmware_ps_mode;
+	int				power_set_true;
+	int				user_power_set_true;
+	u8				user_pm_mode;
+	int				cqm_rssi_thold;
+	unsigned			cqm_rssi_hyst;
+	unsigned			cqm_tx_failure_thold;
+	unsigned			cqm_tx_failure_count;
+	unsigned			cmq_tx_success_count;
+	bool				cqm_use_rssi;
+	int				cqm_link_loss_count;
+	int				cqm_beacon_loss_count;
+	int				mode;
+	bool				enable_beacon;
+	int				beacon_int;
+	size_t				ssid_length;
+	u8				ssid[IEEE80211_MAX_SSID_LEN];
+	bool				listening;
+	struct wsm_rx_filter		rx_filter;
+	struct wsm_beacon_filter_table	bf_table;
+	struct wsm_beacon_filter_control bf_control;
+	struct wsm_multicast_filter	multicast_filter;
+	bool				has_multicast_subscription;
+	struct wsm_broadcast_addr_filter	broadcast_filter;
+	bool				disable_beacon_filter;
+	struct wsm_arp_ipv4_filter      filter4;
+	struct work_struct		update_filtering_work;
+	struct work_struct		set_beacon_wakeup_period_work;
+	struct bes2600_pm_state_vif	pm_state_vif;
+	/*TODO: Add support in mac80211 for psmode info per VIF */
+	struct wsm_p2p_ps_modeinfo	p2p_ps_modeinfo;
+	struct wsm_uapsd_info		uapsd_info;
+	bool				setbssparams_done;
+	u32				listen_interval;
+	u32				erp_info;
+	bool				powersave_enabled;
+
+	/* WSM Join */
+	enum bes2600_join_status	join_status;
+	u8			join_bssid[ETH_ALEN];
+	struct work_struct	join_work;
+	struct delayed_work	join_timeout;
+	struct work_struct	unjoin_work;
+	struct work_struct	offchannel_work;
+	int			join_dtim_period;
+	bool			delayed_unjoin;
+	atomic_t		connect_in_process;
+
+	/* Security */
+	s8			wep_default_key_id;
+	struct work_struct	wep_key_work;
+        unsigned long           rx_timestamp;
+        u32                     cipherType;
+
+
+	/* AP powersave */
+	u32			link_id_map;
+	u32			max_sta_ap_mode;
+	u32			link_id_after_dtim;
+	u32			link_id_uapsd;
+	u32			link_id_max;
+	u32			wsm_key_max_idx;
+	struct bes2600_link_entry link_id_db[CW1250_MAX_STA_IN_AP_MODE];
+	struct work_struct	link_id_work;
+	struct delayed_work	link_id_gc_work;
+	u32			sta_asleep_mask;
+	u32			pspoll_mask;
+	bool			aid0_bit_set;
+	spinlock_t		ps_state_lock;
+	bool			buffered_multicasts;
+	bool			tx_multicast;
+	struct work_struct	set_tim_work;
+	struct delayed_work	set_cts_work;
+	struct work_struct	multicast_start_work;
+	struct work_struct	multicast_stop_work;
+	struct timer_list	mcast_timeout;
+
+	/* CQM Implementation */
+	struct delayed_work	bss_loss_work;
+	struct delayed_work	connection_loss_work;
+	struct work_struct	tx_failure_work;
+	int			delayed_link_loss;
+	spinlock_t		bss_loss_lock;
+	int			bss_loss_status;
+	int			bss_loss_confirm_id;
+
+	struct ieee80211_vif	*vif;
+	struct bes2600_common	*hw_priv;
+	struct ieee80211_hw	*hw;
+
+	/* ROC implementation */
+	struct delayed_work		pending_offchanneltx_work;
+	bool			htcap;
+        u16                     ht_info;
+        struct work_struct      ht_info_update_work;
+	bool pmf;
+
+    u32 hw_value;
+    /* dot11CountersTable */
+    u32 dot11TransmittedFragmentCount;
+    u32 dot11MulticastTransmittedFrameCount;
+    u32 dot11FailedCount;
+    u32 dot11RetryCount;
+    u32 dot11MultipleRetryCount;
+    u32 dot11FrameDuplicateCount;
+    u32 dot11ReceivedFragmentCount;
+    u32 dot11RxReorderLeakCount;
+    u32 dot11ReceivedBytes;
+    u32 dot11ReceivedDataBytes;
+    u32 dot11MulticastReceivedFrameCount;
+    u32 dot11TransmittedFrameCount;
+    u32 dot11TransmittedBytes;
+    u32 dot11TransmittedDataBytes;
+    u32 dot11Txbps;
+    u32 dot11Rxbps;
+};
+struct bes2600_sta_priv {
+	int link_id;
+	struct bes2600_vif *priv;
+};
+enum bes2600_data_filterid {
+	IPV4ADDR_FILTER_ID = 0,
+};
+
+static inline
+struct bes2600_common *cw12xx_vifpriv_to_hwpriv(struct bes2600_vif *priv)
+{
+	return priv->hw_priv;
+}
+
+
+static inline
+struct bes2600_vif *cw12xx_get_vif_from_ieee80211(struct ieee80211_vif *vif)
+{
+	return  (struct bes2600_vif *)vif->drv_priv;
+}
+
+static inline
+struct bes2600_vif *cw12xx_hwpriv_to_vifpriv(struct bes2600_common *hw_priv,
+						int if_id)
+{
+	struct bes2600_vif *vif;
+
+	if (WARN_ON((-1 == if_id) || (if_id > CW12XX_MAX_VIFS)))
+		return NULL;
+	/* TODO:COMBO: During scanning frames can be received
+	 * on interface ID 3 */
+	spin_lock(&hw_priv->vif_list_lock);
+	if (!hw_priv->vif_list[if_id]) {
+		spin_unlock(&hw_priv->vif_list_lock);
+		return NULL;
+	}
+
+	vif = cw12xx_get_vif_from_ieee80211(hw_priv->vif_list[if_id]);
+	WARN_ON(!vif);
+	if (vif)
+		spin_lock(&vif->vif_lock);
+	spin_unlock(&hw_priv->vif_list_lock);
+	return vif;
+}
+
+static inline
+struct bes2600_vif *__cw12xx_hwpriv_to_vifpriv(struct bes2600_common *hw_priv,
+					      int if_id)
+{
+	WARN_ON((-1 == if_id) || (if_id > CW12XX_MAX_VIFS));
+	/* TODO:COMBO: During scanning frames can be received
+	 * on interface ID 3 */
+	if (!hw_priv->vif_list[if_id]) {
+		return NULL;
+	}
+
+	return cw12xx_get_vif_from_ieee80211(hw_priv->vif_list[if_id]);
+}
+
+static inline
+struct bes2600_vif *cw12xx_get_activevif(struct bes2600_common *hw_priv)
+{
+	return cw12xx_hwpriv_to_vifpriv(hw_priv, ffs(hw_priv->if_id_slot)-1);
+}
+
+static inline bool is_hardware_cw1250(struct bes2600_common *hw_priv)
+{
+	return (hw_priv->hw_revision == BES2600_HW_REV_CUT20);
+}
+
+static inline bool is_hardware_cw1260(struct bes2600_common *hw_priv)
+{
+	return (hw_priv->hw_revision == BES2600_HW_REV_CUT10);
+}
+
+static inline int cw12xx_get_nr_hw_ifaces(struct bes2600_common *hw_priv)
+{
+	switch(hw_priv->hw_revision) {
+		case BES2600_HW_REV_CUT10:
+		case BES2600_HW_REV_CUT11:
+		case BES2600_HW_REV_CUT20:
+		case BES2600_HW_REV_CUT22:
+			return 1;
+		case CW1250_HW_REV_CUT10:
+			return 3;
+		default:
+			return 1;
+	}
+}
+
+/* interfaces for the drivers */
+int bes2600_core_probe(const struct sbus_ops *sbus_ops,
+		      struct sbus_priv *sbus,
+		      struct device *pdev,
+		      struct bes2600_common **pself);
+void bes2600_core_release(struct bes2600_common *self);
+
+static inline void bes2600_tx_queues_lock(struct bes2600_common *hw_priv)
+{
+	int i;
+	for (i = 0; i < 4; ++i)
+		bes2600_queue_lock(&hw_priv->tx_queue[i]);
+}
+
+static inline void bes2600_tx_queues_unlock(struct bes2600_common *hw_priv)
+{
+	int i;
+	for (i = 0; i < 4; ++i)
+		bes2600_queue_unlock(&hw_priv->tx_queue[i]);
+}
+
+/* Datastructure for LLC-SNAP HDR */
+#define P80211_OUI_LEN  3
+
+struct ieee80211_snap_hdr {
+        u8    dsap;   /* always 0xAA */
+        u8    ssap;   /* always 0xAA */
+        u8    ctrl;   /* always 0x03 */
+        u8    oui[P80211_OUI_LEN];    /* organizational universal id */
+} __packed;
+
+#define bes2600_for_each_vif(_hw_priv, _priv, _i)			\
+for (									\
+	_i = 0;								\
+	(_i < CW12XX_MAX_VIFS) && \
+	(_priv = hw_priv->vif_list[_i] ? 				\
+	cw12xx_get_vif_from_ieee80211(hw_priv->vif_list[_i]) : NULL);	\
+	_i++								\
+)
+
+#endif /* BES2600_H */
diff --git a/drivers/staging/bes2600/bes2600_cfgvendor.c b/drivers/staging/bes2600/bes2600_cfgvendor.c
new file mode 100755
index 000000000000..5d7e37314128
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_cfgvendor.c
@@ -0,0 +1,122 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <net/mac80211.h>
+#include <net/cfg80211.h>
+#include <linux/ctype.h>
+#include <linux/rtnetlink.h>
+#include <net/netlink.h>
+#include <linux/netlink.h>
+#include "bes2600_cfgvendor.h"
+
+void bes2600_reg_notifier(struct wiphy *wiphy,
+                              struct regulatory_request *request)
+{
+	const struct ieee80211_regdomain *tmp = NULL;
+
+	/* If wiphy->regd is not cleared, reopening the SoftAP after the sta disconnects from an AP will fail */
+	if(request->initiator == NL80211_REGDOM_SET_BY_CORE &&
+	   !(wiphy->regulatory_flags & REGULATORY_CUSTOM_REG)) {
+		tmp = rtnl_dereference(wiphy->regd);
+		if(tmp) {
+			rcu_assign_pointer(wiphy->regd, NULL);
+			kfree_rcu((struct ieee80211_regdomain *)tmp, rcu_head);
+			bes2600_info(BES2600_DBG_ANDROID, "clear regdom when sta disconnects from an ap.\n");
+		}
+	}
+}
+
+static int bes2600_set_country_code(struct wiphy *wiphy,
+	struct wireless_dev *wdev, const void  *data, int len)
+{
+#define CNTRY_BUF_SZ	4	/* Country string is 3 bytes + NUL */
+	int rem, type;
+	char country_code[CNTRY_BUF_SZ] = {0};
+	const struct nlattr *iter;
+
+	nla_for_each_attr(iter, data, len, rem) {
+		type = nla_type(iter);
+		switch (type) {
+			case ANDR_WIFI_ATTRIBUTE_COUNTRY:
+				memcpy(country_code, nla_data(iter),
+					MIN(nla_len(iter), CNTRY_BUF_SZ));
+				break;
+			default:
+				return -EINVAL;
+		}
+	}
+
+	/* check whether the country is valid or not */
+	if(!isalpha(country_code[0]) ||
+	   !isalpha(country_code[1])) {
+		return -EINVAL;
+	}
+
+	/* notify cfg80211 to update database */
+	return regulatory_hint(wiphy, country_code);
+}
+
+static const struct wiphy_vendor_command bes2600_own_commands[] = {
+	{
+		{
+		.vendor_id = OUI_GOOGLE,
+		.subcmd = WIFI_SUBCMD_SET_COUNTRY_CODE
+		},
+		.flags = WIPHY_VENDOR_CMD_NEED_WDEV | WIPHY_VENDOR_CMD_NEED_NETDEV,
+		.doit = bes2600_set_country_code,
+		.policy = VENDOR_CMD_RAW_DATA,
+
+	},
+};
+
+static const struct  nl80211_vendor_cmd_info bes2600_own_events[] = {
+	{ OUI_GOOGLE, GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS },
+	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_FOUND },
+	{ OUI_GOOGLE, GSCAN_EVENT_SCAN_RESULTS_AVAILABLE },
+	{ OUI_GOOGLE, GSCAN_EVENT_FULL_SCAN_RESULTS },
+	{ OUI_GOOGLE, RTT_EVENT_COMPLETE },
+	{ OUI_GOOGLE, GOOGLE_RSSI_MONITOR_EVENT },
+	{ OUI_GOOGLE, GSCAN_EVENT_COMPLETE_SCAN },
+	{ OUI_GOOGLE, GSCAN_EVENT_HOTLIST_RESULTS_LOST }
+
+};
+
+
+int bes2600_set_vendor_command(struct wiphy *wiphy)
+{
+
+	wiphy->vendor_commands = bes2600_own_commands;
+	wiphy->n_vendor_commands = ARRAY_SIZE(bes2600_own_commands);
+	wiphy->vendor_events	= bes2600_own_events;
+	wiphy->n_vendor_events	= ARRAY_SIZE(bes2600_own_events);
+
+	return 0;
+}
+
+int bes2600_vendor_command_detach(struct wiphy *wiphy)
+{
+
+	wiphy->vendor_commands  = NULL;
+	wiphy->vendor_events    = NULL;
+	wiphy->n_vendor_commands = 0;
+	wiphy->n_vendor_events  = 0;
+
+	return 0;
+}
+
+
+
+
diff --git a/drivers/staging/bes2600/bes2600_cfgvendor.h b/drivers/staging/bes2600/bes2600_cfgvendor.h
new file mode 100755
index 000000000000..66d400d12316
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_cfgvendor.h
@@ -0,0 +1,218 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef BES2600_CFGVENDOR_H
+#define BES2600_CFGVENDOR_H
+
+#include "bes2600.h"
+#include "txrx.h"
+#include "sbus.h"
+#include "fwio.h"
+#include "hwio.h"
+#include "bh.h"
+#include "sta.h"
+#include "ap.h"
+#include "scan.h"
+#include "debug.h"
+#include "pm.h"
+
+#define OUI_GOOGLE  0x001A11
+#define GSCAN_BATCH_NO_THR_SET    101
+#define FALSE		0
+#define FAIL	(-1)
+#define MIN(x, y) (((x) < (y)) ? (x) : (y))
+
+typedef enum bes2600_own_event {
+    BES2600_RESERVED1,
+    BES2600_RESERVED2,
+    GSCAN_EVENT_SIGNIFICANT_CHANGE_RESULTS ,
+    GSCAN_EVENT_HOTLIST_RESULTS_FOUND,
+    GSCAN_EVENT_SCAN_RESULTS_AVAILABLE,
+    GSCAN_EVENT_FULL_SCAN_RESULTS,
+    RTT_EVENT_COMPLETE,
+    GSCAN_EVENT_COMPLETE_SCAN,
+    GSCAN_EVENT_HOTLIST_RESULTS_LOST,
+    GSCAN_EVENT_EPNO_EVENT,
+    GOOGLE_DEBUG_RING_EVENT,
+    GOOGLE_DEBUG_MEM_DUMP_EVENT,
+    GSCAN_EVENT_ANQPO_HOTSPOT_MATCH,
+    GOOGLE_RSSI_MONITOR_EVENT
+} bes2600_own_event_t;
+
+enum andr_wifi_feature_set_attr {
+	ANDR_WIFI_ATTRIBUTE_NUM_FEATURE_SET,
+	ANDR_WIFI_ATTRIBUTE_FEATURE_SET,
+	ANDR_WIFI_ATTRIBUTE_RANDOM_MAC_OUI,
+	ANDR_WIFI_ATTRIBUTE_NODFS_SET,
+	ANDR_WIFI_ATTRIBUTE_COUNTRY,
+	ANDR_WIFI_ATTRIBUTE_ND_OFFLOAD_VALUE
+	// Add more attribute here
+};
+
+typedef enum {
+    /* don't use 0 as a valid subcommand */
+    VENDOR_NL80211_SUBCMD_UNSPECIFIED,
+
+    /* define all vendor startup commands between 0x0 and 0x0FFF */
+    VENDOR_NL80211_SUBCMD_RANGE_START = 0x0001,
+    VENDOR_NL80211_SUBCMD_RANGE_END   = 0x0FFF,
+
+    /* define all GScan related commands between 0x1000 and 0x10FF */
+    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START = 0x1000,
+    ANDROID_NL80211_SUBCMD_GSCAN_RANGE_END   = 0x10FF,
+
+    /* define all NearbyDiscovery related commands between 0x1100 and 0x11FF */
+    ANDROID_NL80211_SUBCMD_NBD_RANGE_START = 0x1100,
+    ANDROID_NL80211_SUBCMD_NBD_RANGE_END   = 0x11FF,
+
+    /* define all RTT related commands between 0x1100 and 0x11FF */
+    ANDROID_NL80211_SUBCMD_RTT_RANGE_START = 0x1100,
+    ANDROID_NL80211_SUBCMD_RTT_RANGE_END   = 0x11FF,
+
+    ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START = 0x1200,
+    ANDROID_NL80211_SUBCMD_LSTATS_RANGE_END   = 0x12FF,
+
+    /* define all Logger related commands between 0x1400 and 0x14FF */
+    ANDROID_NL80211_SUBCMD_DEBUG_RANGE_START = 0x1400,
+    ANDROID_NL80211_SUBCMD_DEBUG_RANGE_END   = 0x14FF,
+
+    /* define all wifi offload related commands between 0x1600 and 0x16FF */
+    ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_START = 0x1600,
+    ANDROID_NL80211_SUBCMD_WIFI_OFFLOAD_RANGE_END   = 0x16FF,
+
+    /* define all NAN related commands between 0x1700 and 0x17FF */
+    ANDROID_NL80211_SUBCMD_NAN_RANGE_START = 0x1700,
+    ANDROID_NL80211_SUBCMD_NAN_RANGE_END   = 0x17FF,
+
+    /* define all Android Packet Filter related commands between 0x1800 and 0x18FF */
+    ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START = 0x1800,
+    ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_END   = 0x18FF,
+
+    /* This is reserved for future usage */
+
+} ANDROID_VENDOR_SUB_COMMAND;
+
+enum {
+    LSTATS_SUBCMD_GET_INFO = ANDROID_NL80211_SUBCMD_LSTATS_RANGE_START,
+	LSTATS_SUBCMD_SET_INFO,
+	LSTATS_SUBCMD_CLEAR_INFO,
+};
+
+enum bes2600_vendor_subcmd {
+    GSCAN_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_GSCAN_RANGE_START,
+
+    GSCAN_SUBCMD_SET_CONFIG,                            /* 0x1001 */
+
+    GSCAN_SUBCMD_SET_SCAN_CONFIG,                       /* 0x1002 */
+    GSCAN_SUBCMD_ENABLE_GSCAN,                          /* 0x1003 */
+    GSCAN_SUBCMD_GET_SCAN_RESULTS,                      /* 0x1004 */
+    GSCAN_SUBCMD_SCAN_RESULTS,                          /* 0x1005 */
+
+    GSCAN_SUBCMD_SET_HOTLIST,                           /* 0x1006 */
+
+    GSCAN_SUBCMD_SET_SIGNIFICANT_CHANGE_CONFIG,         /* 0x1007 */
+    GSCAN_SUBCMD_ENABLE_FULL_SCAN_RESULTS,              /* 0x1008 */
+    GSCAN_SUBCMD_GET_CHANNEL_LIST,                       /* 0x1009 */
+
+    WIFI_SUBCMD_GET_FEATURE_SET,                         /* 0x100A */
+    WIFI_SUBCMD_GET_FEATURE_SET_MATRIX,                  /* 0x100B */
+    WIFI_SUBCMD_SET_PNO_RANDOM_MAC_OUI,                  /* 0x100C */
+    WIFI_SUBCMD_NODFS_SET,                               /* 0x100D */
+    WIFI_SUBCMD_SET_COUNTRY_CODE,                             /* 0x100E */
+    /* Add more sub commands here */
+    GSCAN_SUBCMD_SET_EPNO_SSID,                          /* 0x100F */
+
+    WIFI_SUBCMD_SET_SSID_WHITE_LIST,                    /* 0x1010 */
+    WIFI_SUBCMD_SET_ROAM_PARAMS,                        /* 0x1011 */
+    WIFI_SUBCMD_ENABLE_LAZY_ROAM,                       /* 0x1012 */
+    WIFI_SUBCMD_SET_BSSID_PREF,                         /* 0x1013 */
+    WIFI_SUBCMD_SET_BSSID_BLACKLIST,                     /* 0x1014 */
+
+    GSCAN_SUBCMD_ANQPO_CONFIG,                          /* 0x1015 */
+    WIFI_SUBCMD_SET_RSSI_MONITOR,                       /* 0x1016 */
+    WIFI_SUBCMD_CONFIG_ND_OFFLOAD,                      /* 0x1017 */
+    /* Add more sub commands here */
+
+    GSCAN_SUBCMD_MAX,
+
+	RTT_SUBCMD_SET_CONFIG = ANDROID_NL80211_SUBCMD_RTT_RANGE_START,
+	RTT_SUBCMD_CANCEL_CONFIG,
+	RTT_SUBCMD_GETCAPABILITY,
+
+    APF_SUBCMD_GET_CAPABILITIES = ANDROID_NL80211_SUBCMD_PKT_FILTER_RANGE_START,
+    APF_SUBCMD_SET_FILTER,
+
+    LOGGER_START_LOGGING = ANDROID_NL80211_SUBCMD_DEBUG_RANGE_START,
+    LOGGER_TRIGGER_MEM_DUMP,
+    LOGGER_GET_MEM_DUMP,
+    LOGGER_GET_VER,
+    LOGGER_GET_RING_STATUS,
+    LOGGER_GET_RING_DATA,
+    LOGGER_GET_FEATURE,
+    LOGGER_RESET_LOGGING,
+    LOGGER_TRIGGER_DRIVER_MEM_DUMP,
+    LOGGER_GET_DRIVER_MEM_DUMP,
+    LOGGER_START_PKT_FATE_MONITORING,
+    LOGGER_GET_TX_PKT_FATES,
+    LOGGER_GET_RX_PKT_FATES,
+
+	VENDOR_SUBCMD_MAX
+};
+
+typedef enum {
+    WIFI_SUCCESS = 0,
+    WIFI_ERROR_NONE = 0,
+    WIFI_ERROR_UNKNOWN = -1,
+    WIFI_ERROR_UNINITIALIZED = -2,
+    WIFI_ERROR_NOT_SUPPORTED = -3,
+    WIFI_ERROR_NOT_AVAILABLE = -4,              // Not available right now, but try later
+    WIFI_ERROR_INVALID_ARGS = -5,
+    WIFI_ERROR_INVALID_REQUEST_ID = -6,
+    WIFI_ERROR_TIMED_OUT = -7,
+    WIFI_ERROR_TOO_MANY_REQUESTS = -8,          // Too many instances of this request
+    WIFI_ERROR_OUT_OF_MEMORY = -9,
+    WIFI_ERROR_BUSY = -10,
+} wifi_error;
+
+enum _IFACE_ID {
+	IFACE_ID0, /*PRIMARY_ADAPTER*/
+	IFACE_ID1,
+	IFACE_ID2,
+	IFACE_ID3,
+	IFACE_ID4,
+	IFACE_ID5,
+	IFACE_ID6,
+	IFACE_ID7,
+	IFACE_ID_MAX,
+};
+
+typedef struct dhd_pno_gscan_capabilities {
+	int max_scan_cache_size;
+	int max_scan_buckets;
+	int max_ap_cache_per_scan;
+	int max_rssi_sample_size;
+	int max_scan_reporting_threshold;
+	int max_hotlist_aps;
+	int max_significant_wifi_change_aps;
+	int max_epno_ssid_crc32;
+	int max_epno_hidden_ssid;
+	int max_white_list_ssid;
+} dhd_pno_gscan_capabilities_t;
+
+typedef struct gscan_batch_params {
+	unsigned char bestn;
+	unsigned char mscan;
+	unsigned char buffer_threshold;
+} gscan_batch_params_t;
+
+void bes2600_reg_notifier(struct wiphy *wiphy, struct regulatory_request *request);
+int bes2600_set_vendor_command(struct wiphy *wiphy);
+int bes2600_vendor_command_detach(struct wiphy *wiphy);
+#endif
\ No newline at end of file
diff --git a/drivers/staging/bes2600/bes2600_driver_mode.h b/drivers/staging/bes2600/bes2600_driver_mode.h
new file mode 100755
index 000000000000..5c4f48e051ee
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_driver_mode.h
@@ -0,0 +1,26 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _BES2600_DRIVER_MODE_CMD_
+#define _BES2600_DRIVER_MODE_CMD_
+
+#ifdef CONFIG_FW_LOADER
+#define BES2600_LOAD_BOOT_NAME		"bes2600/best2002_fw_boot_sdio.bin"
+#define BES2600_LOAD_FW_NAME		"bes2600/best2002_fw_sdio.bin"
+#define BES2600_LOAD_NOSIGNAL_FW_NAME	"bes2600/best2002_fw_sdio_nosignal.bin"
+#define BES2600_LOAD_BTRF_FW_NAME	"bes2600/best2002_fw_sdio_btrf.bin"
+#else
+#define BES2600_LOAD_BOOT_NAME		"/lib/firmware/bes2600/best2002_fw_boot_sdio.bin"
+#define BES2600_LOAD_FW_NAME		"/lib/firmware/bes2600/best2002_fw_sdio.bin"
+#define BES2600_LOAD_NOSIGNAL_FW_NAME	"/lib/firmware/bes2600/best2002_fw_sdio_nosignal.bin"
+#define BES2600_LOAD_BTRF_FW_NAME	"/lib/firmware/bes2600/best2002_fw_sdio_btrf.bin"
+#endif
+
+#endif /* _BES2600_DRIVER_MODE_CMD_ */
diff --git a/drivers/staging/bes2600/bes2600_factory.c b/drivers/staging/bes2600/bes2600_factory.c
new file mode 100755
index 000000000000..3e7dded3242a
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_factory.c
@@ -0,0 +1,883 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/slab.h>
+#include <linux/mutex.h>
+#include <linux/crc32.h>
+#include <linux/version.h>
+#include "bes2600_factory.h"
+#include "bes2600_log.h"
+#include "bes_chardev.h"
+
+#define LE_CPU_TRANS(val, cvt)		(val = cvt(val))
+
+#define TRANS_LE16(val) LE_CPU_TRANS(val, __cpu_to_le16)
+#define TRANS_LE32(val) LE_CPU_TRANS(val, __cpu_to_le32)
+
+#define TRANS_CPU16(val) LE_CPU_TRANS(val, __le16_to_cpu)
+#define TRANS_CPU32(val) LE_CPU_TRANS(val, __le32_to_cpu)
+
+static DEFINE_MUTEX(factory_lock);
+
+/*
+ * It is only used for temporary storage.
+ * Every time get the factory, it will read from the
+ * file and overwrite the original value.
+ */
+static struct factory_t factory_cali_data;
+static struct factory_t *factory_p = NULL;
+
+void bes2600_factory_lock(void)
+{
+	mutex_lock(&factory_lock);
+}
+
+void bes2600_factory_unlock(void)
+{
+	mutex_unlock(&factory_lock);
+}
+
+u8* bes2600_factory_get_file_buffer(void)
+{
+	u8 *file_buffer = NULL;
+
+	file_buffer = kmalloc(FACTORY_MAX_SIZE, GFP_KERNEL);
+	if (!file_buffer) {
+		return NULL;
+	}
+
+	return file_buffer;
+}
+
+void bes2600_factory_free_file_buffer(u8 *file_buffer)
+{
+	if (file_buffer)
+		kfree(file_buffer);
+}
+
+static int bes2600_wifi_cali_table_save(u8 *file_buffer, struct factory_t *factory_save_p);
+
+static inline uint32_t factory_crc32(const uint8_t *data, uint32_t len)
+{
+	u32 crc_le = 0;
+	crc_le = crc32_le(0xffffffffL, (uint8_t *)data, len);
+	crc_le ^= 0xffffffffL;
+	return crc_le;
+}
+
+static int bes2600_factory_head_info_check(struct factory_t *factory_data)
+{
+	if (!factory_data) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s NULL pointer err\n", __func__);
+		return -1;
+	}
+
+	if (factory_data->head.magic != NVREC_DEV_MAGIC) {
+		return -EBADMSG;
+	}
+
+	if ((factory_data->head.version < NVREC_MINI_VERSION) ||
+		(factory_data->head.version > NVREC_CURRENT_VERSION)) {
+		bes2600_err(BES2600_DBG_FACTORY, "factory version error:%d", factory_data->head.version);
+		return -EBADMSG;
+	}
+
+	return 0;
+}
+
+static int bes2600_factory_crc_check(struct factory_t *factory_data)
+{
+	return 0;
+}
+
+/**
+ * factory_section_read_file - Read data of specified length from file
+ * @path:	path of the file
+ * @buffer:	storage of read data
+ *
+ * The maximum file length allowed is 600 bytes.
+ * This function does not do crc verification to take into 
+ * account different storage requirements.
+ * 
+ * Return: length on success, negative error code otherwise.
+ */
+static int factory_section_read_file(char *path, void *buffer)
+{
+	int ret = 0;
+	struct file *fp;
+
+	if (!path || !buffer) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s NULL pointer err\n", __func__);
+		return -1;
+	}
+
+	bes2600_info(BES2600_DBG_FACTORY, "reading %s \n", path);
+
+	fp = filp_open(path, O_RDONLY, 0); //S_IRUSR
+	if (IS_ERR(fp)) {
+		bes2600_info(BES2600_DBG_FACTORY, "BES2600 : can't open %s\n",path);
+		return -1;
+	}
+
+	if (fp->f_inode->i_size <= 0 || fp->f_inode->i_size > FACTORY_MAX_SIZE) {
+		bes2600_err(BES2600_DBG_FACTORY,
+			"bes2600_factory.txt size check failed, read_size: %lld max_size: %d\n",
+			fp->f_inode->i_size, FACTORY_MAX_SIZE);
+		filp_close(fp, NULL);
+		return -1;
+	}
+
+	ret = kernel_read(fp, buffer, fp->f_inode->i_size, &fp->f_pos);
+
+	filp_close(fp, NULL);
+
+	if (ret != fp->f_inode->i_size) {
+		bes2600_err(BES2600_DBG_FACTORY, "bes2600_factory.txt read fail\n");
+		ret = -1;
+	}
+
+	return ret;
+}
+
+/**
+ * factory_section_write_file - Write data of specified length to file
+ * @path:	path of the file
+ * @buffer:	storage of write data
+ * @size:	length of data to write
+ *
+ * Return: length on success, negative error code otherwise.
+ */
+static int factory_section_write_file(char *path, void *buffer, int size)
+{
+	int ret = 0;
+	struct file *fp;
+
+	bes2600_info(BES2600_DBG_FACTORY, "writing %s \n", path);
+
+	fp = filp_open(path, O_TRUNC | O_CREAT | O_RDWR, S_IRUSR);
+	if (IS_ERR(fp)) {
+		bes2600_info(BES2600_DBG_FACTORY, "BES2600 : can't open %s\n",path);
+		return -1;
+	}
+	ret = kernel_write(fp, buffer, size, &fp->f_pos);
+
+	filp_close(fp,NULL);
+
+	return ret;
+}
+
+static inline int factory_parse(uint8_t *source_buf, struct factory_t *factory)
+{
+	int ret = 0;
+
+	if (!source_buf || !factory) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s NULL pointer err\n", __func__);
+		return -1;
+	}
+
+	ret = sscanf(source_buf, STANDARD_FACTORY,\
+		&factory->head.magic,\
+		&factory->head.version,\
+		&factory->head.crc,\
+		&factory->data.iQ_offset,\
+		&factory->data.freq_cal,\
+		&factory->data.freq_cal_flags,\
+		&factory->data.tx_power_ch[0],\
+		&factory->data.tx_power_ch[1],\
+		&factory->data.tx_power_ch[2],\
+		&factory->data.tx_power_type,\
+		&factory->data.temperature,\
+		&factory->data.tx_power_ch_5G[0],\
+		&factory->data.tx_power_ch_5G[1],\
+		&factory->data.tx_power_ch_5G[2],\
+		&factory->data.tx_power_ch_5G[3],\
+		&factory->data.tx_power_ch_5G[4],\
+		&factory->data.tx_power_ch_5G[5],\
+		&factory->data.tx_power_ch_5G[6],\
+		&factory->data.tx_power_ch_5G[7],\
+		&factory->data.tx_power_ch_5G[8],\
+		&factory->data.tx_power_ch_5G[9],\
+		&factory->data.tx_power_ch_5G[10],\
+		&factory->data.tx_power_ch_5G[11],\
+		&factory->data.tx_power_ch_5G[12],\
+		&factory->data.tx_power_flags_5G,\
+		&factory->data.temperature_5G,\
+		&factory->data.bt_tx_power[0],\
+		&factory->data.bt_tx_power[1],\
+		&factory->data.bt_tx_power[2],\
+		&factory->data.bt_tx_power[3]);
+
+	if (ret != 30) {
+		bes2600_err(BES2600_DBG_FACTORY, "bes2600_factory.txt parse fail\n");
+		return -1;
+	}
+
+	return ret;
+}
+
+static int factory_section_read_and_check_file(u8 *file_buf, char* path)
+{
+	int ret = 0;
+
+	if (!file_buf || !path) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s NULL pointer err\n", __func__);
+		return -1;
+	}
+
+	ret = factory_section_read_file(path, file_buf);
+	if (ret < 0)
+		return ret;
+
+	memset(&factory_cali_data, 0, sizeof(struct factory_t));
+	ret = factory_parse(file_buf, &factory_cali_data);
+	if (ret < 0)
+		return ret;
+
+	ret = bes2600_factory_head_info_check(&factory_cali_data);
+	if (ret < 0)
+		return ret;
+
+	ret = bes2600_factory_crc_check(&factory_cali_data);
+	if (ret < 0)
+		return ret;
+
+	factory_p = &factory_cali_data;
+
+	bes2600_info(BES2600_DBG_FACTORY, "open wifi factory section success");
+
+	return 0;
+}
+
+static void factory_section_wifi_tx_power_check(struct factory_t *factory_data)
+{
+	int i;
+	bool inval_v = false;
+
+	if (!factory_data)
+		return ;
+
+	/* only check cali channel, 11n ch1, ch7, ch13 */
+	for (i = 0; i < ARRAY_SIZE(factory_data->data.tx_power_ch); ++i) {
+		if (factory_data->data.tx_power_ch[i] == 0x0 ||
+			factory_data->data.tx_power_ch[i] > 0x3fff) {
+			inval_v = true;
+		}
+	}
+
+	bes2600_warn_with_cond(inval_v, BES2600_DBG_FACTORY, "tx_power_ch_2g cali, inval calibration value\n");
+	bes2600_info_dump(BES2600_DBG_FACTORY, "tx_power_ch_2g dump:", factory_data->data.tx_power_ch,
+					sizeof(factory_data->data.tx_power_ch));
+
+}
+
+
+static void factory_section_wifi_tx_power_5G_check(struct factory_t *factory_data)
+{
+	int i;
+	bool inval_v = false;
+
+	if (!factory_data)
+		return ;
+
+	/* only check cali channel */
+	for (i = 0; i < ARRAY_SIZE(factory_data->data.tx_power_ch_5G); ++i) {
+		if (factory_data->data.tx_power_ch_5G[i] == 0x0 ||
+			factory_data->data.tx_power_ch_5G[i] > 0x3fff) {
+			inval_v = true;
+		}
+	}
+
+	bes2600_warn_with_cond(inval_v, BES2600_DBG_FACTORY, "tx_power_ch_5g cali, inval calibration value\n");
+	bes2600_info_dump(BES2600_DBG_FACTORY, "tx_power_ch_5g dump:", factory_data->data.tx_power_ch_5G,
+					sizeof(factory_data->data.tx_power_ch_5G));
+
+}
+
+static void factory_section_wifi_freq_cali_check(struct factory_t *factory_data)
+{
+	if (!factory_data)
+		return ;
+
+	if (factory_data->data.freq_cal == 0x0 ||
+		factory_data->data.freq_cal > 0x1ff) {
+			bes2600_warn(BES2600_DBG_FACTORY, "freq cali, inval calibration value\n");
+		}
+
+	bes2600_info_dump(BES2600_DBG_FACTORY, "wifi freq cali dump:", &factory_data->data.freq_cal,
+					sizeof(factory_data->data.freq_cal));
+
+}
+
+static void factory_section_bt_tx_power_check(struct factory_t *factory_data)
+{
+	int i;
+	bool inval_v = false;
+
+	if (!factory_data)
+		return ;
+
+	/* bt only check bdr & edr power, (bdr/edr: div, powerlevel) */
+	for (i = 0; i < ARRAY_SIZE(factory_data->data.bt_tx_power) - 1; i += 2) {
+		if (factory_data->data.bt_tx_power[i] != 0x05) {
+			inval_v = true;
+		}
+
+		if (factory_data->data.bt_tx_power[i + 1] == 0x0 ||
+			factory_data->data.bt_tx_power[i + 1] > 0x20) {
+			inval_v = true;
+		}
+	}
+
+	bes2600_warn_with_cond(inval_v, BES2600_DBG_FACTORY, "bt tx power cali, inval calibration value\n");
+	bes2600_info_dump(BES2600_DBG_FACTORY, "bt tx power cali dump:", factory_data->data.bt_tx_power,
+					sizeof(factory_data->data.bt_tx_power));
+
+}
+
+void factory_little_endian_cvrt(u8 *data)
+{
+	int i;
+	struct factory_t *trans_data = NULL;
+	if (!data)
+		return ;
+
+	trans_data = (struct factory_t *)data;
+
+	TRANS_LE16(trans_data->head.magic);
+	TRANS_LE16(trans_data->head.version);
+	TRANS_LE32(trans_data->head.crc);
+
+	TRANS_LE16(trans_data->data.freq_cal);
+	TRANS_LE32(trans_data->data.iQ_offset);
+
+	for (i = 0; i < ARRAY_SIZE(trans_data->data.tx_power_ch); i++)
+		TRANS_LE16(trans_data->data.tx_power_ch[i]);
+
+	TRANS_LE16(trans_data->data.temperature);
+
+	for (i = 0; i < ARRAY_SIZE(trans_data->data.bt_tx_power); i++)
+		TRANS_LE32(trans_data->data.bt_tx_power[i]);
+
+	for (i = 0; i < ARRAY_SIZE(trans_data->data.tx_power_ch_5G); i++)
+		TRANS_LE16(trans_data->data.tx_power_ch_5G[i]);
+
+	TRANS_LE16(trans_data->data.tx_power_flags_5G);
+	TRANS_LE16(trans_data->data.temperature_5G);
+
+}
+
+void bes2600_factory_data_check(u8* data)
+{
+	struct factory_t *factory_data = NULL;
+
+	if (!data)
+		return ;
+
+	factory_data = (struct factory_t *)data;
+
+	factory_section_wifi_tx_power_check(factory_data);
+	factory_section_wifi_tx_power_5G_check(factory_data);
+	factory_section_bt_tx_power_check(factory_data);
+	factory_section_wifi_freq_cali_check(factory_data);
+
+	/* In order to support manual value change, recalculate crc before sending */
+	factory_data->head.crc =
+		factory_crc32((uint8_t *)(&(factory_data->data)), sizeof(factory_data_t));
+
+}
+
+/*
+ * get factory data from file each time, and update factory_p.
+ */
+u8* bes2600_get_factory_cali_data(u8 *file_buffer, u32 *data_len, char *path)
+{
+	u8 *ret_p = NULL;
+
+	if (!file_buffer || !path || !data_len) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s NULL pointer\n", __func__);
+		return NULL;
+	}
+
+	/* reset factory_p */
+	factory_p = NULL;
+
+	*data_len = sizeof(struct factory_t);
+	if (factory_section_read_and_check_file(file_buffer, path) < 0) {
+		bes2600_err(BES2600_DBG_FACTORY, "read and check %s error\n", path);
+		*data_len = 0;
+		return NULL;
+	}
+
+	if (!factory_p) {
+		*data_len = 0;
+		return NULL;
+	}
+
+	ret_p = (u8 *)factory_p;
+
+	return ret_p;
+}
+
+/**
+ * When the calibration file does not exist, a new file is automatically created when
+ * the calibration value is written. After writing, update factory_p, if the update is successful,
+ * it means the writing is successful, otherwise it fails. At the same time, subsequent calibration
+ * values are saved on this basis to avoid duplicating file creation and flushing out previously saved values.
+ */
+static bool bes2600_factory_file_status_read(u8 *file_buffer)
+{
+	u8 *factory_temp = NULL;
+	uint32_t len;
+	bool ret = true;
+
+	factory_temp = bes2600_get_factory_cali_data(file_buffer, &len, FACTORY_PATH);
+	if (!factory_temp) {
+		bes2600_warn(BES2600_DBG_FACTORY, "get factory data fali, check whether the file exists\n");
+		ret = false;
+	}
+
+	return ret;
+}
+
+/* create a new factory.txt file, and set default value */
+static int bes2600_factory_cali_file_hdr_fill(struct factory_t **factory_head)
+{
+	u16 tx_power_type = 0xff;
+	int i;
+
+	if (!factory_head)
+		return -1;
+
+	*factory_head = &factory_cali_data;
+	memset(*factory_head, 0, sizeof(struct factory_t));
+	(*factory_head)->data.tx_power_type = tx_power_type;
+	(*factory_head)->head.magic = 0xba80;
+	(*factory_head)->head.version = 2;
+
+	(*factory_head)->data.freq_cal = 0xa0;
+
+	for (i = 0; i < 3; ++i) {
+		(*factory_head)->data.tx_power_ch[i] = 0x1400;
+	}
+
+	for (i = 0; i < 13; ++i) {
+		(*factory_head)->data.tx_power_ch_5G[i] = 0x1400;
+	}
+
+	(*factory_head)->data.bt_tx_power[0] = 0x05;
+	(*factory_head)->data.bt_tx_power[1] = 0x10;
+	(*factory_head)->data.bt_tx_power[2] = 0x05;
+	(*factory_head)->data.bt_tx_power[3] = 0x15;
+
+	return 0;
+}
+
+
+int16_t bes2600_wifi_power_cali_table_write(struct wifi_power_cali_save_t *data_cali)
+{
+	u16 mode, band, ch, power_cali, bandwidth;
+	int power_index = 0;
+	struct factory_t *factory_power_p = NULL;
+	u8 *file_buffer = NULL;
+	int16_t ret = 0;
+
+	if (!data_cali) {
+		bes2600_warn(BES2600_DBG_FACTORY, "%s: power cali save pointer is NULL\n", __func__);
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+	}
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	bes2600_factory_lock();
+
+	/**
+	 * When it returns true, it means that the factory file has been read.
+	 * When it returns false, it means that the factory file does not exist,
+	 * or the operation of reading the text file fails. At this time, a new factory file will be created.
+	 */
+	if (bes2600_factory_file_status_read(file_buffer)) {
+		factory_power_p = factory_p;
+	} else {
+		if (bes2600_factory_cali_file_hdr_fill(&factory_power_p)) {
+			bes2600_warn(BES2600_DBG_FACTORY, "%s, create bes2600_factory.txt fail.", __func__);
+			ret = -FACTORY_FACTORY_TXT_CREATE_FAIL;
+			goto err;
+		}
+	}
+
+	mode = data_cali->mode;
+	bandwidth = data_cali->bandwidth;
+	band = data_cali->band;
+	ch = data_cali->ch;
+	power_cali = data_cali->power_cali;
+
+	bes2600_dbg(BES2600_DBG_FACTORY, "%s: mode = %u, bandwidth = %u,, band = %u, ch = %u, power_cali = 0x%04x\n",
+				__func__, mode, bandwidth, band, ch, power_cali);
+
+	/* only in 802.11n 20M msc7 mode, the power calibration value is saved */
+	if (bandwidth != 0 || mode != WIFI_RF_11N_MODE) {
+		ret = -FACTORY_SAVE_MODE_ERR;
+		goto err;
+	}
+
+	/* powerlevel value range: 0 ~ 0x3fff */
+	if (power_cali == 0 || power_cali > 0x3fff) {
+		ret = -FACTORY_SAVE_POWER_ERR;
+		goto err;
+	}
+
+
+	if (band == BAND_2G4) {
+		switch (ch) {
+		case 1:
+			power_index = 0;
+			break;
+		case 7:
+			power_index = 1;
+			break;
+		case 13:
+			power_index = 2;
+			break;
+		default:
+			ret = -FACTORY_SAVE_CH_ERR;
+			goto err;
+			break;
+		}
+		factory_power_p->data.tx_power_ch[power_index] = power_cali;
+	} else if (band == BAND_5G) {
+		switch (ch) {
+		case 36:
+		case 38:
+		case 40:
+			power_index = 0;
+			break;
+		case 44:
+		case 46:
+		case 48:
+			power_index = 1;
+			break;
+		case 52:
+		case 54:
+		case 56:
+			power_index = 2;
+			break;
+		case 60:
+		case 62:
+		case 64:
+			power_index = 3;
+			break;
+		case 100:
+		case 102:
+		case 104:
+			power_index = 4;
+			break;
+		case 108:
+		case 110:
+		case 112:
+			power_index = 5;
+			break;
+		case 116:
+		case 114:
+		case 120:
+			power_index = 6;
+			break;
+		case 124:
+		case 126:
+		case 128:
+			power_index = 7;
+			break;
+		case 132:
+		case 134:
+		case 136:
+			power_index = 8;
+			break;
+		case 140:
+		case 142:
+		case 144:
+			power_index = 9;
+			break;
+		case 149:
+		case 151:
+		case 153:
+			power_index = 10;
+			break;
+		case 157:
+		case 159:
+		case 161:
+			power_index = 11;
+			break;
+		case 165:
+		case 169:
+			power_index = 12;
+			break;
+		default:
+			ret = -FACTORY_SAVE_CH_ERR;
+			goto err;
+			break;
+		}
+		factory_power_p->data.tx_power_ch_5G[power_index] = power_cali;
+	}
+
+	/* save to file */
+	if (bes2600_wifi_cali_table_save(file_buffer, factory_power_p)) {
+		ret = -FACTORY_SAVE_WRITE_ERR;
+		goto err;
+	}
+
+err:
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+	return ret;
+
+}
+
+int16_t bes2600_wifi_cali_freq_write(struct wifi_freq_cali_t *data_cali)
+{
+	u16 freq_cali;
+	struct factory_t *factory_freq_p = NULL;
+	u8 *file_buffer = NULL;
+	int16_t ret = 0;
+
+	if (!data_cali) {
+		bes2600_warn(BES2600_DBG_FACTORY, "%s: freq cali save pointer is NULL\n", __func__);
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+	}
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	bes2600_factory_lock();
+
+	/**
+	 * When it returns true, it means that the factory file has been read.
+	 * When it returns false, it means that the factory file does not exist,
+	 * or the operation of reading the text file fails. At this time, a new factory file will be created.
+	 */
+	if (bes2600_factory_file_status_read(file_buffer)) {
+		factory_freq_p = factory_p;
+	} else {
+		if (bes2600_factory_cali_file_hdr_fill(&factory_freq_p)) {
+			bes2600_warn(BES2600_DBG_FACTORY, "%s, create bes2600_factory.txt fail.", __func__);
+			ret = -FACTORY_FACTORY_TXT_CREATE_FAIL;
+			goto err;
+		}
+	}
+
+	freq_cali = data_cali->freq_cali;
+	data_cali->cali_flag = 1;
+
+	/* freqOffset value range: 0 ~ 0x1ff */
+	if (freq_cali == 0 || freq_cali > 0x1ff) {
+		ret = -FACTORY_SAVE_FREQ_ERR;
+		goto err;
+	}
+
+	factory_freq_p->data.freq_cal = freq_cali;
+	factory_freq_p->data.freq_cal_flags = (u8)(data_cali->cali_flag);
+	bes2600_dbg(BES2600_DBG_FACTORY, "%s: freq_cali = 0x%04x\n", __func__, data_cali->freq_cali);
+
+	/* save to file */
+	if (bes2600_wifi_cali_table_save(file_buffer, factory_freq_p)) {
+		ret = -FACTORY_SAVE_WRITE_ERR;
+		goto err;
+	}
+
+err:
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+	return ret;
+}
+
+int16_t vendor_set_power_cali_flag(struct wifi_power_cali_flag_t *cali_flag)
+{
+	struct factory_t *factory_power_flag_p = NULL;
+	u8 *file_buffer = NULL;
+	u16 calied_flag_5g = 1;
+	u16 calied_flag_2g = 0;
+	int16_t ret = 0;
+
+	if (!cali_flag) {
+		bes2600_warn(BES2600_DBG_FACTORY, "%s: power cali flag save pointer is NULL\n", __func__);
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+	}
+
+	if (cali_flag->band != BAND_2G4 && cali_flag->band != BAND_5G) {
+		bes2600_warn(BES2600_DBG_FACTORY, "%s: power cali flag save band err\n", __func__);
+		return -FACTORY_SET_POWER_CALI_FLAG_ERR;
+	}
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	bes2600_factory_lock();
+
+	if (bes2600_factory_file_status_read(file_buffer)) {
+		factory_power_flag_p = factory_p;
+	} else {
+		bes2600_warn(BES2600_DBG_FACTORY, "%s: factory cali data is not exist\n", __func__);
+		ret = -FACTORY_SAVE_FILE_NOT_EXIST;
+		goto err;
+	}
+
+	if (cali_flag->band == BAND_2G4) {
+		factory_power_flag_p->data.tx_power_type = calied_flag_2g;
+	} else {
+		factory_power_flag_p->data.tx_power_flags_5G = calied_flag_5g;
+	}
+
+	/* save to file */
+	if (bes2600_wifi_cali_table_save(file_buffer, factory_power_flag_p)) {
+		ret = -FACTORY_SET_POWER_CALI_FLAG_ERR;
+		goto err;
+	}
+
+err:
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+	return ret;
+
+}
+
+static inline int factory_build(uint8_t *dest_buf, struct factory_t *factory)
+{
+	return snprintf(dest_buf, FACTORY_MAX_SIZE, STANDARD_FACTORY,\
+		factory->head.magic,\
+		factory->head.version,\
+		factory->head.crc,\
+		factory->data.iQ_offset,\
+		factory->data.freq_cal,\
+		factory->data.freq_cal_flags,\
+		factory->data.tx_power_ch[0],\
+		factory->data.tx_power_ch[1],\
+		factory->data.tx_power_ch[2],\
+		factory->data.tx_power_type,\
+		factory->data.temperature,\
+		factory->data.tx_power_ch_5G[0],\
+		factory->data.tx_power_ch_5G[1],\
+		factory->data.tx_power_ch_5G[2],\
+		factory->data.tx_power_ch_5G[3],\
+		factory->data.tx_power_ch_5G[4],\
+		factory->data.tx_power_ch_5G[5],\
+		factory->data.tx_power_ch_5G[6],\
+		factory->data.tx_power_ch_5G[7],\
+		factory->data.tx_power_ch_5G[8],\
+		factory->data.tx_power_ch_5G[9],\
+		factory->data.tx_power_ch_5G[10],\
+		factory->data.tx_power_ch_5G[11],\
+		factory->data.tx_power_ch_5G[12],\
+		factory->data.tx_power_flags_5G,\
+		factory->data.temperature_5G,\
+		factory->data.bt_tx_power[0],\
+		factory->data.bt_tx_power[1],\
+		factory->data.bt_tx_power[2],\
+		factory->data.bt_tx_power[3]);
+}
+
+static int bes2600_wifi_cali_table_save(u8 *file_buffer, struct factory_t *factory_save_p)
+{
+	int ret = 0;
+	int w_size;
+
+	bes2600_info(BES2600_DBG_FACTORY, "enter %s\n", __func__);
+
+	if (!file_buffer) {
+		return -ENOMEM;
+	}
+
+	if (!factory_save_p) {
+		return -ENOENT;
+	}
+
+	/* All initialized to space */
+	memset(file_buffer, 32, FACTORY_MAX_SIZE);
+	file_buffer[FACTORY_MAX_SIZE - 1] = '\n';
+
+	factory_save_p->head.crc =
+		factory_crc32((uint8_t *)(&(factory_save_p->data)), sizeof(factory_data_t));
+
+	w_size = factory_build(file_buffer, factory_save_p);
+
+	if (w_size < 0 || w_size > FACTORY_MAX_SIZE) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s: build failed! ret = %d.", __func__, ret);
+		return -ETXTBSY;
+	}
+
+	ret = factory_section_write_file(FACTORY_PATH, file_buffer, w_size);
+	if(ret < 0) {
+		bes2600_err(BES2600_DBG_FACTORY, "%s: write failed! ret = %d.", __func__, ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+int16_t vendor_get_power_cali(struct wifi_get_power_cali_t *power_cali)
+{
+	u8 *file_buffer = NULL;
+	int16_t ret = 0;
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	bes2600_factory_lock();
+
+	if (!power_cali) {
+		ret = -FACTORY_GET_INPUT_NULL_POINTER;
+		goto err;
+	}
+
+	if (!bes2600_factory_file_status_read(file_buffer)) {
+		ret = -FACTORY_SAVE_FILE_NOT_EXIST;
+		goto err;
+	}
+
+	memcpy(power_cali->tx_power_ch, factory_p->data.tx_power_ch, sizeof(power_cali->tx_power_ch));
+	memcpy(power_cali->tx_power_ch_5G, factory_p->data.tx_power_ch_5G, sizeof(power_cali->tx_power_ch_5G));
+
+err:
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+	return ret;
+}
+
+
+int16_t vendor_get_freq_cali(struct wifi_freq_cali_t *vendor_freq)
+{
+	u8 *file_buffer = NULL;
+	int16_t ret = 0;
+
+	if (!vendor_freq)
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -FACTORY_GET_INPUT_NULL_POINTER;
+
+	bes2600_factory_lock();
+
+	if (!bes2600_factory_file_status_read(file_buffer)) {
+		ret = -FACTORY_SAVE_FILE_NOT_EXIST;
+		goto err;
+	}
+
+	vendor_freq->status = 0;
+	vendor_freq->freq_cali = factory_p->data.freq_cal;
+	vendor_freq->cali_flag = factory_p->data.freq_cal_flags;
+
+err:
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+	return ret;
+}
+
diff --git a/drivers/staging/bes2600/bes2600_factory.h b/drivers/staging/bes2600/bes2600_factory.h
new file mode 100755
index 000000000000..fee8821f97c0
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_factory.h
@@ -0,0 +1,209 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __FACTORY_H__
+#define __FACTORY_H__
+
+#include "bes2600.h"
+#include "wsm.h"
+
+#define NVREC_MINI_VERSION	1
+#define NVREC_DEV_MAGIC		0xba80
+#define NVREC_CURRENT_VERSION	2
+
+#define FACTORY_PATH "/lib/firmware/bes2600/bes2600_factory.txt"
+#define FACTORY_MAX_SIZE 600
+#define STANDARD_FACTORY "##head\n\
+magic:0x%hx\n\
+version:0x%hx\n\
+crc:0x%x\n\
+##iq&xtal\n\
+iQ_offset:0x%x\n\
+freq_cal:0x%hx\n\
+freq_cal_flags:0x%hhx\n\
+##2.4g_power_11n\n\
+ch1:0x%hx\n\
+ch7:0x%hx\n\
+ch13:0x%hx\n\
+tx_power_type:0x%hhx\n\
+temperature:0x%hx\n\
+##5g_power_11n\n\
+ch36-40:0x%hx\n\
+ch44-48:0x%hx\n\
+ch52-56:0x%hx\n\
+ch60-64:0x%hx\n\
+ch100-104:0x%hx\n\
+ch108-112:0x%hx\n\
+ch116-120:0x%hx\n\
+ch124-128:0x%hx\n\
+ch132-136:0x%hx\n\
+ch140-144:0x%hx\n\
+ch149-153:0x%hx\n\
+ch157-161:0x%hx\n\
+ch165-169:0x%hx\n\
+tx_power_flags_5G:0x%hx\n\
+temperature_5G:0x%hx\n\
+##bt\n\
+bdr_div:0x%x\n\
+bdr_power:0x%x\n\
+edr_div:0x%x\n\
+edr_power:0x%x\n\
+%%%%\n"
+
+typedef struct {
+	uint16_t magic;
+	uint16_t version;
+	uint32_t crc;
+} factory_head_t;
+
+typedef struct {
+	uint32_t iQ_offset;
+	uint16_t freq_cal;
+	/**
+	 * index 0-2
+	 * 11n ch1, 11n ch7, 11n ch13
+	 */
+	uint16_t tx_power_ch[3];
+
+	/**
+	 * freq_cal_flags 0 - chip not calibrated
+	 * freq_cal_flags 1 - chip has been calibrated
+	 */
+	uint8_t freq_cal_flags;
+
+	/**
+	 * tx_power_type 0 - save bgn 1,7,13 power
+	 * tx_power_type 1 - save bgn 1-13 power
+	 * tx_power_type 0xff - not calibration
+	 */
+	uint8_t tx_power_type;
+	uint16_t temperature;
+
+	/**
+	 * 11n
+	 * 0   36~40:1    44~48:2    52~56:3    60~64;
+	 * 4   100~104:5    108~112:6    116~120;
+	 * 7   124~128:8    132~136:9    140~144
+	 * 10    149~153; 11   157~161:12   165~169
+	 */
+	uint16_t tx_power_ch_5G[13];
+	/**
+	 * 0- it means that power not calib
+	 * 1- it means that power have clibrated
+	 */
+	uint16_t tx_power_flags_5G;
+
+
+	uint32_t bt_tx_power[4];
+	/* The temperature after 5G clibrating. */
+	uint16_t temperature_5G;
+} factory_data_t;
+
+struct factory_t {
+	factory_head_t head;
+	factory_data_t data;
+};
+
+
+enum band_type {
+	BAND_2G4,
+	BAND_5G,
+};
+
+struct wifi_get_power_cali_t {
+	uint16_t save_type; /* enmu RF_FACTORY_CALI_DATA_SAVE_TYPE */
+	uint16_t tx_power_ch[3];
+	uint16_t tx_power_ch_5G[13];
+	int16_t status; /* 0: success, != 0: fial */
+};
+
+struct wifi_power_cali_save_t {
+	uint16_t save_type; /* enmu RF_FACTORY_CALI_DATA_SAVE_TYPE */
+	uint16_t mode;
+	uint16_t bandwidth;
+	uint16_t band;
+	uint16_t ch;
+	uint16_t power_cali;
+	int16_t status; /* 0: success, != 0: fial */
+};
+
+struct wifi_freq_cali_t {
+	uint16_t save_type; /* enmu RF_FACTORY_CALI_DATA_SAVE_TYPE */
+	uint16_t freq_cali;
+	int16_t status; /* 0: success, != 0: fial */
+	uint16_t cali_flag;
+};
+
+struct wifi_power_cali_flag_t {
+	uint16_t save_type; /* enmu RF_FACTORY_CALI_DATA_SAVE_TYPE */
+	uint16_t band;
+	int16_t status; /* 0: success, != 0: fial */
+};
+
+
+/**
+ * fatory cali data save type
+ * @RF_CALIB_DATA_IN_LINUX - save to linux file
+ * @RF_CALIB_DATA_IN_EFUSE - save to efuse
+ * @RF_CALIB_DATA_IN_FLASH - save to flash
+ * @RF_CALIB_DATA_TYPE_MAX - save type num
+ */
+enum RF_FACTORY_CALI_DATA_SAVE_TYPE {
+	RF_CALIB_DATA_IN_LINUX = 0,
+	RF_CALIB_DATA_IN_EFUSE,
+	RF_CALIB_DATA_IN_FLASH,
+	RF_CALIB_DATA_TYPE_MAX,
+};
+
+/* fatory power & freq cali save status code */
+enum factory_cali_status {
+	FACTORY_SAVE_SUCCESS				= 0,
+	FACTORY_SAVE_FILE_NOT_EXIST			= 1,
+	FACTORY_SAVE_MODE_ERR				= 2,
+	FACTORY_SAVE_CH_ERR					= 3,
+	FACTORY_SAVE_POWER_ERR				= 4,
+	FACTORY_SAVE_FREQ_ERR				= 5,
+	FACTORY_SAVE_EFUSE_CALIED			= 6,
+	FACTORY_SAVE_WRITE_ERR				= 7,
+	FACTORY_GET_CALIB_FROM_EFUSE_ERR	= 8,
+	FACTORY_GET_FREQ_FROM_EFUSE_ERR		= 9,
+	FACTORY_GET_POWER_FROM_EFUSE_ERR	= 10,
+	FACTORY_GET_POWER_FROM_FLASH_ERR	= 11,
+	FACTORY_GET_FREQ_FROM_FLASH_ERR		= 12,
+	FACTORY_SET_POWER_CALI_FLAG_ERR		= 13,
+	FACTORY_SET_FREQ_CALI_FLAG_ERR		= 14,
+	FACTORY_SAVE_READ_ERR				= 15,
+	FACTORY_GET_INPUT_NULL_POINTER		= 16,
+	FACTORY_FACTORY_TXT_CREATE_FAIL		= 17,
+	/* add new here, and numbered sequentially */
+};
+
+
+
+/* just calibrate 11n, other protocols are automatically mapped */
+#define WIFI_RF_11N_MODE 0x15
+
+/* read wifi & bt factory cali value*/
+u8* bes2600_get_factory_cali_data(u8 *file_buffer, u32 *data_len, char *path);
+void factory_little_endian_cvrt(u8 *data);
+void bes2600_factory_data_check(u8* data);
+void bes2600_factory_lock(void);
+void bes2600_factory_unlock(void);
+u8* bes2600_factory_get_file_buffer(void);
+void bes2600_factory_free_file_buffer(u8 *file_buffer);
+
+/* read & write wifi cali value */
+int16_t bes2600_wifi_power_cali_table_write(struct wifi_power_cali_save_t *data_cali);
+int16_t bes2600_wifi_cali_freq_write(struct wifi_freq_cali_t *data_cali);
+int16_t vendor_get_freq_cali(struct wifi_freq_cali_t *vendor_freq);
+int16_t vendor_get_power_cali(struct wifi_get_power_cali_t *power_cali);
+int16_t vendor_set_power_cali_flag(struct wifi_power_cali_flag_t *cali_flag);
+
+#endif
diff --git a/drivers/staging/bes2600/bes2600_log.c b/drivers/staging/bes2600/bes2600_log.c
new file mode 100755
index 000000000000..28f6ed1a1ada
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_log.c
@@ -0,0 +1,152 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/kernel.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+
+#include "bes2600_log.h"
+#include "bes2600.h"
+
+struct bes2600_dbg_info {
+	int dbg_lvl;
+	char *module_name;
+};
+
+struct bes2600_dbg_info bes2600_dbg_tbl[BES2600_DBG_MAX] = {
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "download"},       /* BES2600_DBG_DOWNLOAD */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "niy"},            /* BES2600_DBG_NIY */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "sbus"},           /* BES2600_DBG_SBUS */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "init"},           /* BES2600_DBG_INIT */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "txrx_opt"},       /* BES2600_DBG_TXRX_OPT */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "txrx"},           /* BES2600_DBG_TXRX */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "queue"},          /* BES2600_DBG_QUEUE */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "spi"},            /* BES2600_DBG_SPI */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "sdio"},           /* BES2600_DBG_SDIO */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "usb"},            /* BES2600_DBG_USB */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "pm"},             /* BES2600_DBG_PM */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "sys"},            /* BES2600_DBG_SYS */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "bt"},             /* BES2600_DBG_BT */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "android"},        /* BES2600_DBG_ANDROID */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "bh"},             /* BES2600_DBG_BH */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "ap"},             /* BES2600_DBG_AP */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "sta"},            /* BES2600_DBG_STA */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "scan"},           /* BES2600_DBG_SCAN */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "itp"},            /* BES2600_DBG_ITP */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "test_mode"},      /* BES2600_DBG_TEST_MODE */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "tx_policy"},      /* BES2600_DBG_TX_POLICY */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "wsm"},            /* BES2600_DBG_WSM */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "roc"},            /* BES2600_DBG_ROC */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "chardev"},        /* BES2600_DBG_CHARDEV */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "factory"},        /* BES2600_DBG_FACTORY */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "epta"},           /* BES2600_DBG_EPTA */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "bes_pwr"},        /* BES2600_DBG_PWR */
+	{.dbg_lvl = BES2600_LOG_INFO, .module_name = "tx_loop"},        /* BES2600_DBG_TXLOOP */
+};
+
+int bes2600_get_dbg_lvl(int module)
+{
+	if(module >= ARRAY_SIZE(bes2600_dbg_tbl))
+		return BES2600_LOG_NONE;
+
+	return bes2600_dbg_tbl[module].dbg_lvl;
+}
+
+int bes2600_log_control_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+ssize_t bes2600_log_control_write(struct file *file,const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	u32 i;
+	char *buf = NULL;
+	char *module, *level;
+	unsigned long log_level;
+	char *str_none = "NONE";
+	char *str_err = "ERR";
+	char *str_warn = "WARN";
+	char *str_info = "INFO";
+	char *str_dbg = "DBG";
+
+	buf = kmalloc(count + 1, GFP_KERNEL);
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+	buf[count] = '\0';
+
+	module = strstr(buf, "module:");
+	level = strstr(buf, "level:");
+	if (module == NULL || level == NULL) {
+		bes2600_err(BES2600_DBG_CHARDEV, "module or level error. %s\n", buf);
+		goto out;
+	}
+	module += 7;
+	level += 6;
+	if (strncasecmp(str_none, level, strlen(str_none)) == 0)
+		log_level = BES2600_LOG_NONE;
+	else if(strncasecmp(str_err, level, strlen(str_err)) == 0)
+		log_level = BES2600_LOG_ERROR;
+	else if(strncasecmp(str_warn, level, strlen(str_warn)) == 0)
+		log_level = BES2600_LOG_WARN;
+	else if(strncasecmp(str_info, level, strlen(str_info)) == 0)
+		log_level = BES2600_LOG_INFO;
+	else if(strncasecmp(str_dbg, level, strlen(str_dbg)) == 0)
+		log_level = BES2600_LOG_DBG;
+	else {
+		bes2600_err(BES2600_DBG_CHARDEV, "module level error. %s\n", __func__);
+		goto out;
+	}
+
+	for (i = 0; i < ARRAY_SIZE(bes2600_dbg_tbl); ++i) {
+		if (strncasecmp(bes2600_dbg_tbl[i].module_name, module, strlen(bes2600_dbg_tbl[i].module_name)) == 0) {
+			bes2600_dbg_tbl[i].dbg_lvl = log_level;
+			break;
+		}
+	}
+
+out:
+	kfree(buf);
+	return count;
+}
+
+ssize_t bes2600_log_control_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos)
+{
+	char *buf = NULL;
+	int i,ret;
+	int used_len = 0;
+	char str[10];
+
+	if (!count)
+		return -EINVAL;
+	buf = kmalloc(1024, GFP_KERNEL);
+	if(!buf) {
+		bes2600_err(BES2600_DBG_CHARDEV, "kmalloc error. %s\n", __func__);
+		return -ENOMEM;
+	}
+	for (i = 0; i < ARRAY_SIZE(bes2600_dbg_tbl); ++i) {
+		if(bes2600_dbg_tbl[i].dbg_lvl == BES2600_LOG_NONE) 
+			strcpy(str, "NONE");
+		else if (bes2600_dbg_tbl[i].dbg_lvl == BES2600_LOG_ERROR)
+			strcpy(str, "ERR");
+		else if (bes2600_dbg_tbl[i].dbg_lvl == BES2600_LOG_WARN)
+			strcpy(str, "WARN");
+		else if (bes2600_dbg_tbl[i].dbg_lvl == BES2600_LOG_INFO)
+			strcpy(str, "INFO");
+		else if (bes2600_dbg_tbl[i].dbg_lvl == BES2600_LOG_DBG)
+			strcpy(str, "DBG");
+		else
+			return -ENOMEM;
+		used_len += snprintf(buf + used_len, (1024 - used_len), "%-16s%s\n", bes2600_dbg_tbl[i].module_name, str);
+	}
+	ret = simple_read_from_buffer(user_buf, count, ppos, buf, used_len);
+	kfree(buf);
+	return ret;
+}
diff --git a/drivers/staging/bes2600/bes2600_log.h b/drivers/staging/bes2600/bes2600_log.h
new file mode 100755
index 000000000000..14f36810b072
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_log.h
@@ -0,0 +1,161 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __BES2600_LOG_H__
+#define __BES2600_LOG_H__
+
+/* Log Level Control */
+#define BES2600_LOG_NONE		0
+#define BES2600_LOG_ERROR		1
+#define BES2600_LOG_WARN		2
+#define BES2600_LOG_INFO		3
+#define BES2600_LOG_DBG			4
+
+/* Module Log Level Control */
+enum BES2600_DBG {
+	BES2600_DBG_DOWNLOAD = 0,
+	BES2600_DBG_NIY,
+	BES2600_DBG_SBUS,
+	BES2600_DBG_INIT,
+	BES2600_DBG_TXRX_OPT,
+	BES2600_DBG_TXRX,
+	BES2600_DBG_QUEUE,
+	BES2600_DBG_SPI,
+	BES2600_DBG_SDIO,
+	BES2600_DBG_USB,
+	BES2600_DBG_PM,
+	BES2600_DBG_SYS,
+	BES2600_DBG_BT,
+	BES2600_DBG_ANDROID,
+	BES2600_DBG_BH,
+	BES2600_DBG_AP,
+	BES2600_DBG_STA,
+	BES2600_DBG_SCAN,
+	BES2600_DBG_ITP,
+	BES2600_DBG_TEST_MODE,
+	BES2600_DBG_TX_POLICY,
+	BES2600_DBG_WSM,
+	BES2600_DBG_ROC,
+	BES2600_DBG_CHARDEV,
+	BES2600_DBG_FACTORY,
+	BES2600_DBG_EPTA,
+	BES2600_DBG_PWR,
+	BES2600_DBG_TXLOOP,
+
+	BES2600_DBG_MAX,
+};
+
+int bes2600_get_dbg_lvl(int module);
+
+int bes2600_log_control_open(struct inode *inode, struct file *file);
+
+ssize_t bes2600_log_control_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos);
+
+ssize_t bes2600_log_control_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos);
+
+#define GET_LOG_LVL(module)		bes2600_get_dbg_lvl(module)
+
+#define bes2600_dbg(module, ...)				\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_DBG)	\
+			printk(KERN_INFO __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_dbg_with_cond(cond, module, ...)		\
+	do {							\
+		if ((0 != (cond)) && 				\
+		    GET_LOG_LVL(module) >= BES2600_LOG_DBG)	\
+			printk(KERN_DEBUG __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_dbg_dump(module, desc, array, len)		\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_DBG)	\
+			print_hex_dump(KERN_DEBUG, 		\
+				desc, DUMP_PREFIX_NONE,		\
+				16, 1, array, 			\
+				len, false);			\
+	} while(0)
+
+#define bes2600_info(module, ...)				\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_INFO)	\
+			printk(KERN_INFO __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_info_with_cond(cond, module, ...)		\
+	do {							\
+		if ((0 != (cond)) && 				\
+		    GET_LOG_LVL(module) >= BES2600_LOG_INFO)	\
+			printk(KERN_INFO __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_info_dump(module, desc, array, len)		\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_INFO)	\
+			print_hex_dump(KERN_INFO, 		\
+				desc, DUMP_PREFIX_NONE,		\
+				16, 1, array, 			\
+				len, false);			\
+	} while(0)
+
+
+#define bes2600_warn(module, ...)				\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_WARN)	\
+			printk(KERN_WARNING __VA_ARGS__);	\
+	} while (0)
+
+#define bes2600_warn_with_cond(cond, module, ...)		\
+	do {							\
+		if ((0 != (cond)) && 				\
+		    GET_LOG_LVL(module) >= BES2600_LOG_WARN)	\
+			printk(KERN_WARNING __VA_ARGS__);	\
+	} while (0)
+
+#define bes2600_warn_dump(module, desc, array, len)		\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_WARN)	\
+			print_hex_dump(KERN_WARNING, 		\
+				desc, DUMP_PREFIX_NONE,		\
+				16, 1, array, 			\
+				len, false);			\
+	} while(0)
+
+#define bes2600_err(module, ...)				\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_ERROR)	\
+			printk(KERN_ERR __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_err_with_cond(cond, module, ...)		\
+	do {							\
+		if ((0 != (cond)) && 				\
+		    GET_LOG_LVL(module) >= BES2600_LOG_ERROR)	\
+			printk(KERN_ERR __VA_ARGS__);		\
+	} while (0)
+
+#define bes2600_err_dump(module, desc, array, len)		\
+	do {							\
+		if (GET_LOG_LVL(module) >= BES2600_LOG_ERROR)	\
+			print_hex_dump(KERN_ERR, 		\
+				desc, DUMP_PREFIX_NONE,		\
+				16, 1, array, 			\
+				len, false);			\
+	} while(0)
+
+#define STUB()							\
+	do {							\
+		bes2600_dbg(BES2600_DBG_NIY,			\
+			   "%s: STUB at line %d.\n",		\
+			   __func__, __LINE__);			\
+	} while (0)
+
+#endif
diff --git a/drivers/staging/bes2600/bes2600_plat.h b/drivers/staging/bes2600/bes2600_plat.h
new file mode 100755
index 000000000000..a1f87c6a966e
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_plat.h
@@ -0,0 +1,36 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef BES2600_PLAT_H_INCLUDED
+#define BES2600_PLAT_H_INCLUDED
+
+#include <linux/ioport.h>
+
+struct bes2600_platform_data_sdio {
+	u16 ref_clk;				/* REQUIRED (in KHz) */
+
+	/* All others are optional */
+	bool have_5ghz;
+	bool no_nptb;				/* SDIO hardware does not support non-power-of-2-blocksizes */
+	struct gpio_desc *powerup;		/* GPIO to POWERUP signal (0 disables) */
+	struct gpio_desc *wakeup;		/* GPIO to WAKEUP signal (0 disables) */
+	struct gpio_desc *host_wakeup;		/* wifi GPIO to WAKEUP host signal (0 disables) */
+	bool wlan_bt_hostwake_registered;	/* wifi request_irq success or not */
+	int gpio_irq;				/* IRQ line or 0 to use SDIO IRQ */
+	int (*power_ctrl)(const struct bes2600_platform_data_sdio *pdata,
+			  bool enable);		/* Control 3v3 / 1v8 supply */
+	int (*clk_ctrl)(const struct bes2600_platform_data_sdio *pdata,
+			bool enable);		/* Control CLK32K */
+	const u8 *macaddr;			/* if NULL, use bes2600_mac_template module parameter */
+	const char *sdd_file;			/* if NULL, will use default for detected hw type */
+	bool wakeup_source;			/* marks whether bes2600 is the wakeup souce or not */
+};
+
+#endif /* BES2600_PLAT_H_INCLUDED */
diff --git a/drivers/staging/bes2600/bes2600_sdio.c b/drivers/staging/bes2600/bes2600_sdio.c
new file mode 100755
index 000000000000..f7b58ad13ba2
--- /dev/null
+++ b/drivers/staging/bes2600/bes2600_sdio.c
@@ -0,0 +1,1901 @@
+/*
+ * Mac80211 SDIO driver for BES2600 device
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+ #define DEBUG 1
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/delay.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
+#include <linux/spinlock.h>
+#include <net/mac80211.h>
+#include <linux/scatterlist.h>
+#include <linux/mmc/host.h>
+#include <linux/mmc/card.h>
+#include <linux/mmc/sdio.h>
+#include <linux/mmc/sdio_func.h>
+#include <linux/version.h>
+#include <linux/of_gpio.h>
+
+#include "bes2600.h"
+#include "sbus.h"
+#include "bes2600_plat.h"
+#include "hwio.h"
+#include "bes2600_driver_mode.h"
+#include "bes_chardev.h"
+
+static void sdio_scan_work(struct work_struct *work);
+int bes2600_register_net_dev(struct sbus_priv *bus_priv);
+int bes2600_unregister_net_dev(struct sbus_priv *bus_priv);
+static void bes2600_gpio_wakeup_mcu(struct sbus_priv *self, int falg);
+static void bes2600_gpio_allow_mcu_sleep(struct sbus_priv *self, int falg);
+
+MODULE_AUTHOR("Dmitry Tarnyagin <dmitry.tarnyagin@stericsson.com>");
+MODULE_DESCRIPTION("mac80211 BES2600 SDIO driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bes2600_wlan");
+
+struct sbus_priv {
+	struct sdio_func	*func;
+	struct bes2600_common	*core;
+	struct bes2600_platform_data_sdio *pdata;
+	spinlock_t		lock;
+	sbus_irq_handler	irq_handler;
+	void			*irq_priv;
+	struct work_struct sdio_scan_work;
+	struct device *dev;
+	struct workqueue_struct *sdio_wq;
+	bool fw_started;
+	struct mutex io_mutex;
+	long unsigned int gpio_wakup_flags;
+	struct mutex sbus_mutex;
+	bool retune_protected;
+	u8 next_toggle;
+	int tx_data_toggle;
+	int rx_data_toggle;
+	spinlock_t rx_queue_lock;
+	struct sk_buff_head rx_queue;
+	u8 *rx_buffer;
+	struct work_struct rx_work;
+	u32 rx_last_ctrl;
+	u32 rx_valid_ctrl;
+	u32 rx_total_ctrl_cnt;
+	u32 rx_continuous_ctrl_cnt;
+	u32 rx_zero_ctrl_cnt;
+	u32 rx_remain_ctrl_cnt;
+	u32 rx_data_cnt;
+	u32 rx_xfer_cnt;
+	u32 rx_proc_cnt;
+	long unsigned int last_irq_timestamp;
+	long unsigned int last_rx_data_timestamp;
+	u8 *tx_buffer;
+	struct list_head tx_bufferlist;
+	struct kmem_cache *tx_bufferlistpool;
+	spinlock_t tx_bufferlock;
+	struct work_struct tx_work;
+	struct scatterlist tx_sg[BES_SDIO_TX_MULTIPLE_NUM + 1];
+	struct scatterlist tx_sg_nosignal[BES_SDIO_TX_MULTIPLE_NUM_NOSIGNAL + 1];
+	u32 tx_data_cnt;
+	u32 tx_xfer_cnt;
+	u32 tx_proc_cnt;
+	long unsigned int last_tx_data_timestamp;
+	bool unregister_in_process;
+};
+
+#define IS_DRIVER_VENDOR_CMD(X) ((X & 0x0C00) == 0x0C00)
+struct HI_MSG_HDR {
+	uint16_t MsgLen;
+	uint16_t MsgId;
+};
+
+enum DRIVER_TO_MCU_MSG_ST {
+	ST_ENTER,
+	ST_EXIT,
+};
+
+#define BES_VENDOR_ID	0xbe57
+#define BES_DEVICE_ID_2002	0x2002
+
+static const struct sdio_device_id bes2600_sdio_ids[] = {
+	{ SDIO_DEVICE(BES_VENDOR_ID, BES_DEVICE_ID_2002) },
+	{ /* end: all zeroes */			},
+};
+
+static int bes2600_gpio_wakeup_ap_config(struct sbus_priv *priv);
+
+/* sbus_ops implemetation */
+
+static inline unsigned int sdio_max_byte_size(struct sdio_func *func)
+{
+	unsigned mval = min(func->card->host->max_seg_size, func->card->host->max_blk_size);
+
+	if (func->card->quirks & MMC_QUIRK_BLKSZ_FOR_BYTE_MODE)
+		mval = min(mval, func->cur_blksize);
+	else
+		mval = min(mval, func->max_blksize);
+
+	return min(mval, 512u);
+}
+
+static int bes_sdio_memcpy_io_helper(struct sdio_func *func, int write, void *data_buf, unsigned size)
+{
+	int ret = 0;
+	unsigned remainder = size;
+	unsigned max_blocks, align_blocks, pads;
+
+	struct sbus_priv *self = NULL;
+
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+	struct scatterlist sg[2];
+
+	struct scatterlist *next;
+
+	u8 *pad_buf = (u8 *)kmalloc(func->cur_blksize, GFP_KERNEL);
+	if (!pad_buf)
+		return -ENOMEM;
+
+	if (!func || (func->num > 7) || (!data_buf) || (!size)) {
+		ret = -EINVAL;
+		goto out;
+	}
+
+	self = sdio_get_drvdata(func);
+	BUG_ON(!self);
+
+	if (func->card->cccr.multi_block && size > sdio_max_byte_size(func) ) {
+		max_blocks = min(func->card->host->max_blk_count, 511u);
+		align_blocks = (size + func->cur_blksize - 1) / func->cur_blksize;
+		if (align_blocks > max_blocks) {
+			/* to be simplified, consider this should not
+			 * happen, and to be continued;
+			 */
+			bes2600_dbg(BES2600_DBG_SDIO, "%s warning to be continued, align=%d max=%d", __func__, align_blocks, max_blocks);
+			ret = -EINVAL;
+			goto out;
+		}
+		pads = align_blocks * func->cur_blksize - size;
+		bes2600_dbg(BES2600_DBG_SDIO, "%s sz=%u blk=%u pad=%u,dir=%d", __func__, size, align_blocks, pads, write);
+
+		memset(&mrq, 0, sizeof(mrq));
+		memset(&cmd, 0, sizeof(cmd));
+		memset(&data, 0, sizeof(data));
+
+		mrq.cmd = &cmd;
+		mrq.data = &data;
+
+		cmd.opcode = SD_IO_RW_EXTENDED;
+		cmd.arg = write ? 0x80000000 : 0x00000000;
+		cmd.arg |= func->num << 28;
+		cmd.arg |= 0x04000000;
+		cmd.arg |= size << 9;
+
+		if (likely(self->fw_started == true)) {
+			cmd.arg &= ~(1 << 25);
+			if (write) {
+				cmd.arg |= ((self->tx_data_toggle & 0x1) << 25);
+				++self->tx_data_toggle;
+			} else {
+				cmd.arg |= ((self->rx_data_toggle & 0x1) << 25);
+				++self->rx_data_toggle;
+			}
+		}
+
+		cmd.arg |= (0x08000000 | align_blocks);
+		cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
+
+		data.blksz = func->cur_blksize;
+		data.blocks = align_blocks;
+		data.flags = write ? MMC_DATA_WRITE : MMC_DATA_READ;
+
+		data.sg = sg;
+		data.sg_len = 1;
+		sg_init_table(sg, 2);
+		sg_set_buf(sg, data_buf, size);
+		if (pads) {
+			next = sg_next(sg);
+			sg_set_buf(next, pad_buf, pads);
+			data.sg_len = 2;
+		}
+
+		mmc_set_data_timeout(&data, func->card);
+
+		mmc_wait_for_req(func->card->host, &mrq);
+
+		if (cmd.error){
+			ret = cmd.error;
+			goto out;
+		}
+		if (data.error) {
+			ret = data.error;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_ERROR) {
+			ret = -EIO;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_FUNCTION_NUMBER) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_OUT_OF_RANGE) {
+			ret = -ERANGE;
+			goto out;
+		}
+	} else {
+		while (remainder) {
+			size = min(remainder, sdio_max_byte_size(func));
+
+			bes2600_dbg(BES2600_DBG_SDIO, "%s size=%d dir=%d", __func__, size, write);
+			if (write) {
+				if (likely(self->fw_started == true)) {
+					ret = sdio_memcpy_toio(func, size | ((self->tx_data_toggle & 0x1) << 16), data_buf, size);
+					++self->tx_data_toggle;
+				} else {
+					ret = sdio_memcpy_toio(func, size, data_buf, size);
+				}
+			} else {
+				if (likely(self->fw_started == true)) {
+					ret = sdio_memcpy_fromio(func, data_buf, size | ((self->rx_data_toggle & 0x1) << 16), size);
+					++self->rx_data_toggle;
+				} else {
+					ret = sdio_memcpy_fromio(func, data_buf, size, size);
+				}
+			}
+			if (ret)
+				goto out;
+
+			remainder -= size;
+			data_buf += size;
+		}
+	}
+out:
+	kfree(pad_buf);
+	if (ret) {
+		bes2600_err(BES2600_DBG_SDIO, "%s, err=%d(%d:%p:%d)",
+				__func__, ret, func->num, data_buf, size);
+				if (self && self->fw_started == true) {
+					if (write)
+						--self->tx_data_toggle;
+					else
+						--self->rx_data_toggle;
+					bes2600_err(BES2600_DBG_SDIO, "%s,toggle count:%u,%u\n", __func__, self->tx_data_toggle, self->rx_data_toggle);
+				}
+	}
+	return ret;
+}
+
+static int bes2600_sdio_memcpy_fromio(struct sbus_priv *self,
+				     unsigned int addr,
+				     void *dst, int count)
+{
+	return bes_sdio_memcpy_io_helper(self->func, 0, dst, count);
+}
+
+static int bes2600_sdio_memcpy_toio(struct sbus_priv *self,
+				   unsigned int addr,
+				   const void *src, int count)
+{
+	return bes_sdio_memcpy_io_helper(self->func, 1, (void *)src, count);
+}
+
+static void bes2600_sdio_lock(struct sbus_priv *self)
+{
+	sdio_claim_host(self->func);
+}
+
+static void bes2600_sdio_unlock(struct sbus_priv *self)
+{
+	sdio_release_host(self->func);
+}
+
+/* bes sdio slave regs can only be accessed by command52
+ * if a WORD or DWORD reg wants to be accessed,
+ * please combine the results of multiple command52
+ */
+static int bes2600_sdio_reg_read(struct sbus_priv *self, u32 reg,
+					void *dst, int count)
+{
+	int ret = 0;
+	if (count <= 0 || !dst)
+		return -EINVAL;
+	while(count && !ret) {
+		*(u8 *)dst = sdio_readb(self->func, reg, &ret);
+		dst ++;
+		reg ++;
+		count--;
+	}
+	return ret;
+
+}
+
+static int bes2600_sdio_reg_write(struct sbus_priv *self, u32 reg,
+					const void *src, int count)
+{
+	int ret = 0;
+	if (count <= 0 || !src)
+		return -EINVAL;
+	while (count && !ret) {
+		sdio_writeb(self->func, *(u8 *)src, reg, &ret);
+		src ++;
+		reg ++;
+		count --;
+	}
+	return ret;
+}
+
+static void bes2600_sdio_irq_handler(struct sdio_func *func)
+{
+	struct sbus_priv *self = sdio_get_drvdata(func);
+	unsigned long flags;
+	bes2600_dbg(BES2600_DBG_SDIO, "\n %s called, fw_started:%d \n",
+			 __func__, self->fw_started);
+
+	if (WARN_ON(!self)) {
+		return;
+	}
+
+	if (likely(self->fw_started && self->core)) {
+		queue_work(self->sdio_wq, &self->rx_work);
+		self->last_irq_timestamp = jiffies;
+	} else if(self->irq_handler) {
+		spin_lock_irqsave(&self->lock, flags);
+		self->irq_handler(self->irq_priv);
+		spin_unlock_irqrestore(&self->lock, flags);
+	}
+}
+
+static int bes2600_sdio_irq_subscribe(struct sbus_priv *self,
+				     sbus_irq_handler handler,
+				     void *priv)
+{
+	int ret;
+	unsigned long flags;
+
+	if (!handler)
+		return -EINVAL;
+
+	spin_lock_irqsave(&self->lock, flags);
+	self->irq_priv = priv;
+	self->irq_handler = handler;
+	spin_unlock_irqrestore(&self->lock, flags);
+
+	bes2600_dbg(BES2600_DBG_SDIO,  "SW IRQ subscribe\n");
+	sdio_claim_host(self->func);
+	ret = sdio_claim_irq(self->func, bes2600_sdio_irq_handler);
+	sdio_release_host(self->func);
+	return ret;
+}
+
+static int bes2600_sdio_irq_unsubscribe(struct sbus_priv *self)
+{
+	int ret = 0;
+	unsigned long flags;
+
+	WARN_ON(!self->irq_handler);
+	if (!self->irq_handler)
+		return 0;
+
+	bes2600_dbg(BES2600_DBG_SDIO, "SW IRQ unsubscribe\n");
+
+	spin_lock_irqsave(&self->lock, flags);
+	self->irq_priv = NULL;
+	self->irq_handler = NULL;
+	spin_unlock_irqrestore(&self->lock, flags);
+
+	return ret;
+}
+
+static int bes2600_sdio_off(struct bes2600_platform_data_sdio *pdata)
+{
+	bes2600_info(BES2600_DBG_SDIO, "%s enter\n", __func__);
+
+	gpiod_direction_output(pdata->powerup, 0);
+
+	return 0;
+}
+
+static int bes2600_sdio_on(struct bes2600_platform_data_sdio *pdata)
+{
+
+	bes2600_info(BES2600_DBG_SDIO, "%s enter\n", __func__);
+
+	gpiod_direction_output(pdata->powerup, 1);
+
+	return 0;
+}
+
+static size_t bes2600_sdio_align_size(struct sbus_priv *self, size_t size)
+{
+	size_t aligned  = size;
+	if (self->func->cur_blksize > size)
+	       aligned = sdio_align_size(self->func, size);
+	else
+		aligned = (aligned + 3) & (~3);
+
+	return aligned;
+}
+
+int bes2600_sdio_set_block_size(struct sbus_priv *self, size_t size)
+{
+	return sdio_set_block_size(self->func, size);
+}
+
+void sdio_work_debug(struct sbus_priv *self)
+{
+	u8 cfg;
+	int ret;
+	bes2600_err(BES2600_DBG_SDIO, "%s now=%u last irq timestamp=%u\n", __func__,
+			(u32)jiffies_to_msecs(jiffies), jiffies_to_msecs(self->last_irq_timestamp));
+	bes2600_err(BES2600_DBG_SDIO, "%s rx ctrl: total=%u continuous=%u xfer=%u remain=%u zero=%u last=%x(%x) next=%d\n", __func__,
+			self->rx_total_ctrl_cnt, self->rx_continuous_ctrl_cnt, self->rx_xfer_cnt, self->rx_remain_ctrl_cnt, self->rx_zero_ctrl_cnt,
+			self->rx_last_ctrl, self->rx_valid_ctrl, self->next_toggle);
+	bes2600_err(BES2600_DBG_SDIO, "%s rx: last timestamp=%u, total=%u(%u), proc=%u\n", __func__,
+			(u32)jiffies_to_msecs(self->last_rx_data_timestamp),
+			self->rx_data_cnt, self->rx_xfer_cnt, self->rx_proc_cnt);
+	bes2600_err(BES2600_DBG_SDIO, "%s tx: last timestamp=%u, total=%u,%u, proc=%u\n", __func__,
+			(u32)jiffies_to_msecs(self->last_tx_data_timestamp),
+			self->tx_data_cnt, self->tx_xfer_cnt, self->tx_proc_cnt);
+	mutex_lock(&self->sbus_mutex);
+	sdio_claim_host(self->func);
+	bes2600_sdio_reg_read(self, BES_TX_CTRL_REG_ID + 1, &cfg, 1);
+	bes2600_err(BES2600_DBG_SDIO, "realtime ctrl=%x\n", cfg);
+	cfg = BES_HOST_INT | BES_SUBSYSTEM_WIFI_DEBUG;
+	sdio_writeb(self->func, 0, BES_HOST_INT_REG_ID + 1, &ret);
+	sdio_writeb(self->func, cfg, BES_HOST_INT_REG_ID, &ret);
+	sdio_release_host(self->func);
+	mutex_unlock(&self->sbus_mutex);
+}
+
+int bes2600_sdio_read_ctrl(struct sbus_priv *self, u32 *ctrl_reg)
+{
+	u8 data[4];
+	int ret = 0, again = 0;
+	*ctrl_reg = 0;
+
+	/* clear sdio slave gen interrupt */
+	ret = bes2600_sdio_reg_read(self, BES_TX_CTRL_REG_ID + 1, data, 1);
+	if (unlikely(ret)) {
+		bes2600_err(BES2600_DBG_SDIO, "[SBUS] Failed(%d) to read control register.\n", ret);
+		return ret;
+	}
+	self->rx_total_ctrl_cnt++;
+
+	if (data[0] & 0x7f) {
+		/* length field valid */
+		again = 1;
+		if (((data[0] >> 7) & 0x1) == self->next_toggle) {
+			*ctrl_reg = (data[0] & 0x7f) << 9;
+			self->rx_valid_ctrl = data[0];
+			if (self->rx_last_ctrl && (((self->rx_last_ctrl >> 7) & 0x1) != self->next_toggle))
+				self->rx_continuous_ctrl_cnt++;
+			self->next_toggle ^= 1;
+		} else {
+			self->rx_remain_ctrl_cnt++;
+		}
+	} else {
+		/* distinguish zero true or false */
+		self->rx_zero_ctrl_cnt++;
+		ret = bes2600_sdio_reg_read(self, BES_TX_CTRL_REG_ID, &data[1], 1);
+		if (!ret && (data[1] & 0x01))
+			again = 0;
+		else
+			again = 1;
+	}
+	self->rx_last_ctrl = data[0];
+	return again;
+}
+
+static int bes2600_sdio_packets_check(u32 ctrl_reg, u8 *packets)
+{
+	int i;
+	u16 single, total_cal = 0;
+	u16 packets_length;
+	struct HI_MSG_HDR *pMsg;
+
+	/* bit 23-16 indicate count of packets */
+	u32 packets_cnt;
+	packets_cnt = BES_SDIO_RX_MULTIPLE_NUM;
+
+	/* bit 15-0 indicate totoal length of packets */
+	packets_length = PACKET_TOTAL_LEN(ctrl_reg);
+
+	/* first 32-bit: addr in mcu;
+	 * second 32-bit: packet length;
+	 * next: data
+	 */
+	for (i = 0; i < packets_cnt; i++) {
+		pMsg = (struct HI_MSG_HDR *)(packets + total_cal);
+		bes2600_dbg(BES2600_DBG_SDIO, "%s, %x,%x\n", __func__, pMsg->MsgId, pMsg->MsgLen);
+		single = pMsg->MsgLen;
+		single = (single + 3) & (~0x3);
+		if (unlikely(single > 1632)) {
+			bes2600_warn(BES2600_DBG_SDIO, "%s %d,len=%u,%dth,total=%u,%u\n", __func__, __LINE__, single, i,
+					packets_length, total_cal);
+			if (i >= 1) {
+				return -201;
+			}
+		}
+		total_cal += single;
+		if ((!pMsg->MsgLen) || (total_cal == packets_length)) {
+			//pr_info("%s, contain %d packets\n", __func__, i);
+			break;
+		}
+	}
+	bes2600_dbg(BES2600_DBG_SDIO, "%s, %d,%u,%u\n", __func__, packets_cnt, packets_length, total_cal);
+
+	if (packets_length < total_cal) {
+		pr_err("%s,%d pkt len=%u, total len=%u", __func__, __LINE__, packets_length, total_cal);
+		return -202;
+	}
+
+	return 0;
+}
+
+static int bes2600_sdio_extract_packets(struct sbus_priv *self, u32 ctrl_reg, u8 *data)
+{
+	int i, alloc_retry = 0;
+	u8 packets_cnt = BES_SDIO_RX_MULTIPLE_NUM;
+	u16 packet_len, pos = 0;
+	struct sk_buff *skb;
+
+	for (i = 0; i < packets_cnt; i++) {
+		packet_len = ((struct HI_MSG_HDR *)&(data[pos]))->MsgLen;
+		if (!packet_len)
+			break;
+		do {
+			skb = dev_alloc_skb(packet_len);
+			if (likely(skb))
+				break;
+			bes2600_warn(BES2600_DBG_SDIO, "%s,%d no memory and sleep\n", __func__, __LINE__);
+			msleep(100);
+			++alloc_retry;
+		} while(alloc_retry < 10);
+		if (WARN_ON(!skb)) {
+			return -ENOMEM;
+		}
+		skb_trim(skb, 0);
+		skb_put(skb, packet_len);
+		memcpy(skb->data, &data[pos], packet_len);
+		bes2600_dbg(BES2600_DBG_SDIO, "%s, %d,%d\n", __func__, packet_len, pos);
+		spin_lock(&self->rx_queue_lock);
+		skb_queue_tail(&self->rx_queue, skb);
+		self->rx_data_cnt++;
+		spin_unlock(&self->rx_queue_lock);
+		packet_len = (packet_len + 3) & (~0x3);
+		pos += packet_len;
+		if (pos == PACKET_TOTAL_LEN(ctrl_reg))
+			break;
+	}
+	return 0;
+}
+
+static void sdio_rx_work(struct work_struct *work)
+{
+	int ret, again = 0, retry = 0, crc_retry = 0;
+	u32 ctrl_reg = 0;
+	int total_len;
+	struct sbus_priv *self = container_of(work, struct sbus_priv, rx_work);
+	u8 *buf = self->rx_buffer;
+
+	/* don't read/write sdio when sdio error */
+	if(bes2600_chrdev_is_bus_error())
+		return;
+
+	bes2600_gpio_wakeup_mcu(self, GPIO_WAKE_FLAG_SDIO_RX);
+
+	do {
+		bes2600_sdio_lock(self);
+		again = bes2600_sdio_read_ctrl(self, &ctrl_reg);
+
+		if(again == -EBUSY || again == -ETIMEDOUT) {
+			bes2600_err(BES2600_DBG_SDIO, "%s sdio read error\n", __func__);
+			bes2600_sdio_unlock(self);
+			goto failed;
+		}
+
+		total_len = PACKET_TOTAL_LEN(ctrl_reg);
+		if (!total_len) {
+			bes2600_sdio_unlock(self);
+			if ((again == 1) && retry <= 5) {
+				retry++;
+				continue;
+			} else {
+				break;
+			}
+		}
+
+		do {
+			ret = bes2600_sdio_memcpy_fromio(self, 0, buf, total_len);
+			if (likely(ret != -84)) {
+				crc_retry = 0;
+				break;
+			} else {
+				crc_retry++;
+				bes2600_err(BES2600_DBG_SDIO, "%s sdio read crc error(%d)\n", __func__, crc_retry);
+			}
+		} while (crc_retry <= 10);
+		if (self->retune_protected == true) {
+			sdio_retune_release(self->func);
+			self->retune_protected = false;
+		}
+		bes2600_sdio_unlock(self);
+		if (ret) {
+			bes2600_err(BES2600_DBG_SDIO, "%s,%d error=%d\n", __func__, __LINE__, ret);
+			sdio_work_debug(self);
+			goto failed;
+		}
+		retry = 0;
+		self->rx_xfer_cnt++;
+		self->last_rx_data_timestamp = jiffies;
+
+		if ((ret = bes2600_sdio_packets_check(ctrl_reg, buf))) {
+			bes2600_err(BES2600_DBG_SDIO, "%s,%d error=%d\n", __func__, __LINE__, ret);
+			sdio_work_debug(self);
+			goto failed;
+		}
+
+		if ((ret = bes2600_sdio_extract_packets(self, ctrl_reg, buf))) {
+			bes2600_err(BES2600_DBG_SDIO, "%s,%d error=%d\n", __func__, __LINE__, ret);
+			goto failed;
+		}
+
+		ctrl_reg = 0;
+
+		if (likely(self->irq_handler)) {
+			self->irq_handler(self->irq_priv);
+		} else {
+			bes2600_err(BES2600_DBG_SDIO, "%s,%d\n", __func__, __LINE__);
+			goto failed;
+		}
+
+	} while (again);
+
+	bes2600_gpio_allow_mcu_sleep(self, GPIO_WAKE_FLAG_SDIO_RX);
+	return;
+
+failed:
+	bes2600_gpio_allow_mcu_sleep(self, GPIO_WAKE_FLAG_SDIO_RX);
+	bes2600_chrdev_wifi_force_close(self->core, false);
+	WARN_ON(1);
+}
+
+static void sdio_scan_work(struct work_struct *work)
+{
+	// TODO: enable card detection?
+	bes2600_info(BES2600_DBG_SDIO, "%s: power down, rescan card\n", __FUNCTION__);
+}
+
+static void *bes2600_sdio_pipe_read(struct sbus_priv *self)
+{
+	struct sk_buff *skb;
+
+	if(bes2600_chrdev_is_bus_error()) {
+		return bes2600_tx_loop_read(self->core);
+	}
+
+	spin_lock(&self->rx_queue_lock);
+	skb = skb_dequeue(&self->rx_queue);
+	if (skb)
+		self->rx_proc_cnt++;
+	spin_unlock(&self->rx_queue_lock);
+	if (likely(self->fw_started == true &&
+		!bes2600_pwr_device_is_idle(self->core) &&
+		self->core->hw_bufs_used > 0))
+		if (!skb)
+			queue_work(self->sdio_wq, &self->rx_work);
+	return skb;
+}
+
+struct bes_sdio_tx_list_t {
+	struct list_head node;
+	u8 *buf;
+	u32 len;
+};
+
+static int bes_sdio_memcpy_to_io_helper(struct sdio_func *func, unsigned origin_size, struct scatterlist *sg, u32 sg_num)
+{
+	int ret = 0;
+	u32 align_blocks;
+	u32 compensate;
+	unsigned size = origin_size & (~0x3);
+
+	struct sbus_priv *self = NULL;
+
+	u32 sg_compensate_num = sg_num;
+
+	struct mmc_request mrq;
+	struct mmc_command cmd;
+	struct mmc_data data;
+
+	self = sdio_get_drvdata(func);
+
+	if (size && func->card->cccr.multi_block) {
+
+		align_blocks = (size + func->cur_blksize - 1) / func->cur_blksize;
+		bes2600_dbg(BES2600_DBG_SDIO, "%s sz=%u blk=%u", __func__, size, align_blocks);
+		compensate = align_blocks * func->cur_blksize - size;
+		if (compensate) {
+			sg_set_buf(&sg[sg_num], self->tx_buffer, compensate);
+			sg_compensate_num = sg_num + 1;
+		}
+		sg_mark_end(&sg[sg_compensate_num - 1]);
+
+		memset(&mrq, 0, sizeof(mrq));
+		memset(&cmd, 0, sizeof(cmd));
+		memset(&data, 0, sizeof(data));
+
+		mrq.cmd = &cmd;
+		mrq.data = &data;
+
+		cmd.opcode = SD_IO_RW_EXTENDED;
+		cmd.arg = 0x80000000;
+		cmd.arg |= func->num << 28;
+		cmd.arg |= 0x04000000;
+		cmd.arg |= (origin_size) << 9;
+
+		if (likely(self->fw_started == true)) {
+			cmd.arg &= ~(1 << 25);
+			cmd.arg |= ((self->tx_data_toggle & 0x1) << 25);
+			++self->tx_data_toggle;
+		}
+
+		cmd.arg |= 0x08000000 | align_blocks;
+		cmd.flags = MMC_RSP_SPI_R5 | MMC_RSP_R5 | MMC_CMD_ADTC;
+
+		data.blksz = func->cur_blksize;
+		data.blocks = align_blocks;
+		data.flags = MMC_DATA_WRITE;
+
+		data.sg = sg;
+		data.sg_len = sg_compensate_num;
+
+		mmc_set_data_timeout(&data, func->card);
+
+		mmc_wait_for_req(func->card->host, &mrq);
+
+		if (cmd.error){
+			ret = cmd.error;
+			goto out;
+		}
+		if (data.error) {
+			ret = data.error;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_ERROR) {
+			ret = -EIO;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_FUNCTION_NUMBER) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (cmd.resp[0] & R5_OUT_OF_RANGE) {
+			ret = -ERANGE;
+			goto out;
+		}
+	} else {
+		bes2600_err(BES2600_DBG_SDIO, "%s,%d (%u)\n", __func__, __LINE__, size);
+		ret = -EINVAL;
+	}
+out:
+	if (unlikely(ret))
+		self->tx_data_toggle--;
+	return ret;
+}
+
+static void sdio_tx_work(struct work_struct *work)
+{
+	int ret, crc_retry = 0;
+	u32 blks, cur_blk = 0, align, total_len = 0, scatters = 0;
+	struct list_head proc_list;
+	struct bes_sdio_tx_list_t *tx_buffer, *temp;
+	struct sbus_priv *self = container_of(work, struct sbus_priv, tx_work);
+	struct scatterlist *sg = NULL;
+	int bes_sdio_tx_multiple_num;
+	struct HI_MSG_HDR *pMsg;
+	enum DRIVER_TO_MCU_MSG_ST driver_to_mcu = ST_EXIT;
+
+	/* don't read/write sdio when sdio error */
+	if(bes2600_chrdev_is_bus_error())
+		return;
+
+	if (bes2600_chrdev_is_signal_mode()) {
+		sg = self->tx_sg;
+		bes_sdio_tx_multiple_num = BES_SDIO_TX_MULTIPLE_NUM;
+	} else {
+		sg = self->tx_sg_nosignal;
+		bes_sdio_tx_multiple_num = BES_SDIO_TX_MULTIPLE_NUM_NOSIGNAL;
+	}
+
+	INIT_LIST_HEAD(&proc_list);
+
+	for (;;) {
+		spin_lock(&self->tx_bufferlock);
+		list_splice_tail_init(&self->tx_bufferlist, &proc_list);
+		spin_unlock(&self->tx_bufferlock);
+		if (list_empty(&proc_list))
+			break;
+		sg_init_table(sg, bes_sdio_tx_multiple_num + 1);
+		list_for_each_entry_safe(tx_buffer, temp, &proc_list, node) {
+			blks = (tx_buffer->len + self->func->cur_blksize - 1) / self->func->cur_blksize;
+			align = blks * self->func->cur_blksize;
+			if (blks >= 4) {
+				align = 1632;
+			}
+			if (unlikely(blks >= 5)) {
+				bes2600_err(BES2600_DBG_SDIO, "%s,%d skip error-len packet:%u,%d\n", __func__, __LINE__, tx_buffer->len, blks);
+				list_del_init(&tx_buffer->node);
+				kmem_cache_free(self->tx_bufferlistpool, tx_buffer);
+				continue;
+			}
+			bes2600_dbg(BES2600_DBG_SDIO, "%s,%p,%u->%u\n", __func__, tx_buffer->buf, tx_buffer->len, align);
+			if (!cur_blk)
+				cur_blk = blks;
+			else if (cur_blk != blks)
+				goto flush_previous;
+
+			pMsg = (struct HI_MSG_HDR *)tx_buffer->buf;
+			if (unlikely(IS_DRIVER_VENDOR_CMD(pMsg->MsgId))) {
+				if (driver_to_mcu == ST_EXIT) {
+					driver_to_mcu = ST_ENTER;
+					goto flush_previous;
+				}
+			}
+
+			sg_set_buf(&sg[scatters], tx_buffer->buf, align);
+			total_len += align;
+			++scatters;
+/*del_node:*/
+			list_del_init(&tx_buffer->node);
+			kmem_cache_free(self->tx_bufferlistpool, tx_buffer);
+			self->tx_proc_cnt++;
+			if (unlikely(IS_DRIVER_VENDOR_CMD(pMsg->MsgId))) {
+				if (driver_to_mcu == ST_ENTER) {
+					driver_to_mcu = ST_EXIT;
+					break;
+				}
+			}
+			if (scatters >= bes_sdio_tx_multiple_num) {
+				break;
+			}
+		}
+flush_previous:
+		if (likely(scatters)) {
+			if (WARN_ON(total_len & 0x3))
+				break;
+			else
+				total_len |= (cur_blk - 1);
+			sdio_claim_host(self->func);
+			if (self->retune_protected == false) {
+				sdio_retune_hold_now(self->func);
+				self->retune_protected = true;
+			}
+			do {
+				ret = bes_sdio_memcpy_to_io_helper(self->func, total_len, sg, scatters);
+				if (likely(ret != -84)) {
+					crc_retry = 0;
+					break;
+				} else {
+					crc_retry++;
+					bes2600_err(BES2600_DBG_SDIO, "%s sdio write crc error(%d)\n", __func__, crc_retry);
+				}
+			} while (crc_retry <= 10);
+			sdio_release_host(self->func);
+			queue_work(self->sdio_wq, &self->rx_work);
+			if (ret) {
+				bes2600_err(BES2600_DBG_SDIO, "%s,%d err=%d,%d,%d\n", __func__, __LINE__, ret, scatters, cur_blk);
+				sdio_work_debug(self);
+				bes2600_chrdev_wifi_force_close(self->core, false);
+			}
+			scatters = 0;
+			total_len = 0;
+			cur_blk = 0;
+			self->tx_xfer_cnt++;
+			self->last_tx_data_timestamp = jiffies;
+		}
+	}
+}
+
+static int bes2600_sdio_pipe_send(struct sbus_priv *self, u8 pipe, u32 len, u8 *buf)
+{
+	struct bes_sdio_tx_list_t * desc = NULL;
+
+	if(bes2600_chrdev_is_bus_error()) {
+		bes2600_tx_loop_pipe_send(self->core, buf, len);
+		return 0;
+	}
+
+	desc = kmem_cache_alloc(self->tx_bufferlistpool, GFP_KERNEL);
+	if (!desc)
+		return -ENOMEM;
+	INIT_LIST_HEAD(&desc->node);
+	desc->buf = buf;
+	desc->len = len;
+	if (!buf || !len)
+		return -EINVAL;
+
+	spin_lock(&self->tx_bufferlock);
+	list_add_tail(&desc->node, &self->tx_bufferlist);
+	self->tx_data_cnt++;
+	spin_unlock(&self->tx_bufferlock);
+	queue_work(self->sdio_wq, &self->tx_work);
+	return 0;
+
+}
+
+static int bes2600_sdio_misc_init(struct sbus_priv *self, struct bes2600_common *ar)
+{
+	self->rx_data_toggle = 0;
+	self->tx_data_toggle = 0;
+	self->next_toggle = 0;
+	spin_lock_init(&self->rx_queue_lock);
+	skb_queue_head_init(&self->rx_queue);
+	self->rx_buffer = (u8 *)__get_dma_pages(GFP_KERNEL, get_order(1632 * BES_SDIO_RX_MULTIPLE_NUM));
+	if (!self->rx_buffer)
+		return -ENOMEM;
+	INIT_WORK(&self->rx_work, sdio_rx_work);
+	INIT_LIST_HEAD(&self->tx_bufferlist);
+	spin_lock_init(&self->tx_bufferlock);
+	self->tx_buffer = (u8 *)kmalloc(512, GFP_KERNEL);
+	if (!self->tx_buffer) {
+		goto err2;
+	}
+	self->tx_bufferlistpool = kmem_cache_create("sdio_tx_bufferlistpool", sizeof(struct bes_sdio_tx_list_t), 0, SLAB_HWCACHE_ALIGN, NULL);
+	if (!self->tx_bufferlistpool)
+		goto err1;
+	self->sdio_wq = alloc_workqueue("bes_sdio", WQ_MEM_RECLAIM | WQ_HIGHPRI | WQ_CPU_INTENSIVE, 2);
+	if (!self->sdio_wq)
+		goto err0;
+	INIT_WORK(&self->tx_work, sdio_tx_work);
+	return 0;
+err0:
+	kmem_cache_destroy(self->tx_bufferlistpool);
+err1:
+	kfree(self->tx_buffer);
+err2:
+	free_pages((unsigned long)self->rx_buffer, get_order(1632 * BES_SDIO_RX_MULTIPLE_NUM));
+	return -ENOMEM;
+}
+
+static int bes2600_platform_data_init(struct sbus_priv *self)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+	struct device_node *np = self->dev->of_node;
+	int ret = 0;
+
+	if (!np || !of_device_is_compatible(np, "bes,bes2600")) {
+		bes2600_err(BES2600_DBG_SDIO, "Device tree node not found\n");
+		return -EINVAL;
+	}
+
+	pdata->powerup = gpiod_get(self->dev, "power", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->powerup)) {
+		ret = PTR_ERR(pdata->powerup);
+		bes2600_err(BES2600_DBG_SDIO, "Can't request powerup_gpio:%d\n", ret);
+		goto exit;
+	}
+
+	pdata->wakeup = gpiod_get(self->dev, "wakeup", GPIOD_OUT_LOW);
+	if (IS_ERR(pdata->wakeup)) {
+		ret = PTR_ERR(pdata->wakeup);
+		bes2600_err(BES2600_DBG_SDIO, "Can't request wakeup gpio:%d\n", ret);
+		goto exit;
+	}
+
+	pdata->host_wakeup = gpiod_get(self->dev, "interrupt", GPIOD_IN);
+	if (IS_ERR(pdata->host_wakeup)) {
+		ret = PTR_ERR(pdata->host_wakeup);
+		bes2600_err(BES2600_DBG_SDIO, "Can't request interrupt gpio:%d\n", ret);
+		goto exit;
+	}
+
+	pdata->wlan_bt_hostwake_registered = false;
+exit:
+	return ret;
+}
+
+static void bes2600_platform_data_deinit(struct sbus_priv *self)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+
+	gpiod_put(pdata->powerup);
+	gpiod_put(pdata->wakeup);
+	gpiod_put(pdata->host_wakeup);
+}
+
+static int bes2600_sdio_readb_safe(struct sdio_func *func, unsigned int addr)
+{
+	int ret = 0;
+	u8 val = 0;
+	u8 retry = 0;
+
+	do {
+		val = sdio_readb(func, addr, &ret);
+	} while((ret < 0) && ++retry < 30);
+
+	bes2600_err_with_cond(ret, BES2600_DBG_SDIO, "%s failed, ret:%d\n", __func__, ret);
+
+	return (ret < 0) ? ret : val;
+}
+
+static int bes2600_sdio_writeb_safe(struct sdio_func *func, unsigned int addr, u8 val)
+{
+	int ret;
+	u8 retry = 0;
+
+	do {
+		sdio_writeb(func, val, addr, &ret);
+	} while((ret < 0) && ++retry < 30);
+
+	bes2600_err_with_cond(ret, BES2600_DBG_SDIO, "%s failed, ret:%d\n", __func__, ret);
+
+	return ret;
+}
+
+static void bes2600_gpio_wakeup_mcu(struct sbus_priv *self, int flag)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+	bool gpio_wakeup = false;
+
+	bes2600_dbg(BES2600_DBG_SDIO, "%s with %d\n", __func__, flag);
+
+	mutex_lock(&self->io_mutex);
+
+	/* error check */
+	if((self->gpio_wakup_flags & BIT(flag)) != 0) {
+		bes2600_err(BES2600_DBG_SDIO,
+			"repeat set gpio_wake_flag, sub_sys:%d", flag);
+		mutex_unlock(&self->io_mutex);
+		return;
+	}
+
+	/* check if this is the first subsystem that need mcu to keep awake */
+	gpio_wakeup = (self->gpio_wakup_flags == 0);
+
+	/* do wakeup mcu operation */
+	if(gpio_wakeup) {
+		bes2600_dbg(BES2600_DBG_SDIO, "pull high gpio by flag:%d\n", flag);
+		gpiod_direction_output(pdata->wakeup, 1);
+		msleep(10);
+	}
+
+	/* set flag of gpio_wakeup_flags */
+	self->gpio_wakup_flags |= BIT(flag);
+
+	mutex_unlock(&self->io_mutex);
+}
+
+static void bes2600_gpio_allow_mcu_sleep(struct sbus_priv *self, int flag)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+	bool gpio_sleep = false;
+
+	bes2600_dbg(BES2600_DBG_SDIO, "%s with %d\n", __func__, flag);
+
+	mutex_lock(&self->io_mutex);
+
+	/* error check */
+	if((self->gpio_wakup_flags & BIT(flag)) == 0) {
+		bes2600_err(BES2600_DBG_SDIO,
+			"repeat clear gpio_wake_flag, sub_sys:%d", flag);
+		mutex_unlock(&self->io_mutex);
+		return;
+	}
+
+	/* clear flag of gpio_wakeup_flags */
+	self->gpio_wakup_flags &= ~BIT(flag);
+
+	/* check if this is the last subsystem that need mcu to keep awake */
+	gpio_sleep = (self->gpio_wakup_flags == 0);
+
+	/* do wakeup mcu operation */
+	if(gpio_sleep) {
+		bes2600_dbg(BES2600_DBG_SDIO, "pull low gpio by flag:%d\n", flag);
+		gpiod_direction_output(pdata->wakeup, 0);
+	}
+
+	mutex_unlock(&self->io_mutex);
+}
+
+int bes2600_sdio_active(struct sbus_priv *self, int sub_system)
+{
+	u16 cfg;
+	u8 cfm = 0;
+	int ret = 0, retries = 0;
+	u8 tmp_val = 0;
+	u32 cnt = 0;
+	u32 delay_cnt = 2;
+
+	/* nosignal mode only allow SUBSYSTEM_WIFI */
+	if (!bes2600_chrdev_is_signal_mode() && sub_system != SUBSYSTEM_WIFI)
+		return -EINVAL;
+
+	/* don't read/write sdio when sdio error */
+	if(bes2600_chrdev_is_bus_error())
+		return 0;
+
+	/* prevent concurrent access */
+	mutex_lock(&self->sbus_mutex);
+
+	/* set config and confirm value */
+	if (sub_system == SUBSYSTEM_MCU) {
+		cfg = BES_HOST_INT | BES_SUBSYSTEM_MCU_ACTIVE;
+		cfm = BES_SLAVE_STATUS_MCU_WAKEUP_READY;
+		delay_cnt = 2;
+	} else if (sub_system == SUBSYSTEM_WIFI) {
+		cfg = BES_HOST_INT | BES_SUBSYSTEM_WIFI_ACTIVE;
+		cfm = BES_SLAVE_STATUS_WIFI_READY;
+		delay_cnt = 25;
+	} else if(sub_system == SUBSYSTEM_BT) {
+		cfg = BES_HOST_INT | BES_SUBSYSTEM_BT_ACTIVE;
+		cfm = BES_SLAVE_STATUS_BT_READY;
+		delay_cnt = 25;
+	} else if(sub_system == SUBSYSTEM_BT_LP) {
+		cfg = BES_HOST_INT | BES_SUBSYSTEM_BT_WAKEUP;
+		cfm = BES_SLAVE_STATUS_BT_WAKE_READY;
+		delay_cnt = 2;
+	} else {
+		mutex_unlock(&self->sbus_mutex);
+		return -EINVAL;
+	}
+
+	/* set fw_started flag in advance */
+	if(sub_system == SUBSYSTEM_WIFI) {
+		self->fw_started = true;
+	}
+
+	/* wait until device ready */
+	do {
+		sdio_claim_host(self->func);
+		ret = bes2600_sdio_readb_safe(self->func, BES_SLAVE_STATUS_REG_ID);
+		sdio_release_host(self->func);
+		bes2600_dbg(BES2600_DBG_SDIO, "active wait mcu ready cnt:%d, reg:%d\n", cnt++, ret);
+		if(ret < 0) {
+			goto err;
+		}
+	} while((ret & BES_SLAVE_STATUS_MCU_READY) == 0);
+
+	do {
+		/* claim sdio host */
+		sdio_claim_host(self->func);
+
+		/* write first segment */
+		tmp_val = (cfg >> 8) & 0xff;
+		ret = bes2600_sdio_writeb_safe(self->func, BES_HOST_INT_REG_ID + 1, tmp_val);
+		if(ret < 0) {
+			sdio_release_host(self->func);
+			bes2600_err(BES2600_DBG_SDIO, "active write 1st seg failed\n");
+			goto err;
+		}
+
+		/* write second segment */
+		tmp_val = cfg & 0xff;
+		ret = bes2600_sdio_writeb_safe(self->func, BES_HOST_INT_REG_ID, tmp_val);
+		if(ret < 0) {
+			sdio_release_host(self->func);
+			bes2600_err(BES2600_DBG_SDIO, "active write 2nd seg failed\n");
+			goto err;
+		}
+
+		/* release sdio host */
+		sdio_release_host(self->func);
+
+		/* wait device to response */
+		msleep(delay_cnt);
+
+		/* read device response result */
+		sdio_claim_host(self->func);
+		ret = bes2600_sdio_readb_safe(self->func, BES_SLAVE_STATUS_REG_ID);
+		sdio_release_host(self->func);
+		if(ret < 0) {
+			bes2600_err(BES2600_DBG_SDIO, "active read response failed\n");
+			goto err;
+		}
+		bes2600_dbg(BES2600_DBG_SDIO, "active resp cnt:%d, reg:%d, sub_sys:%d\n", retries, ret, sub_system);
+	} while ((cfm != 0) && (ret & cfm) == 0 && ++retries <= 200);	// check if cfm bit is set
+
+	if (retries > 200) {
+		bes2600_err(BES2600_DBG_SDIO, "bes2600_sdio_active failed, subsys:%d\n", sub_system);
+		/* open wifi failed, restore fw_started flag */
+		if(sub_system == SUBSYSTEM_WIFI) {
+			self->fw_started = false;
+		}
+
+		mutex_unlock(&self->sbus_mutex);
+		return -EFAULT;
+	} else {
+		ret = 0;
+	}
+
+	if (sub_system == SUBSYSTEM_WIFI ||
+		sub_system == SUBSYSTEM_BT)
+		ret = bes2600_gpio_wakeup_ap_config(self);
+	/* prevent concurrent access */
+	mutex_unlock(&self->sbus_mutex);
+
+	return ret;
+err:
+	mutex_unlock(&self->sbus_mutex);
+	bes2600_chrdev_wifi_force_close(self->core, false);
+	return -ENODEV;
+}
+
+static void bes2600_sdio_empty_work(struct sbus_priv *self)
+{
+	struct sk_buff *skb;
+	struct bes_sdio_tx_list_t *tx_buffer, *temp;
+
+	cancel_work_sync(&self->rx_work);
+	while (1) {
+		skb = skb_dequeue(&self->rx_queue);
+		if (skb)
+			dev_kfree_skb(skb);
+		else
+			break;
+	}
+	self->rx_last_ctrl = 0;
+	self->rx_total_ctrl_cnt = 0;
+	self->rx_continuous_ctrl_cnt = 0;
+	self->rx_remain_ctrl_cnt = 0;
+	self->rx_zero_ctrl_cnt = 0;
+	self->rx_data_cnt = 0;
+	self->rx_xfer_cnt = 0;
+	self->rx_proc_cnt = 0;
+
+	cancel_work_sync(&self->tx_work);
+	list_for_each_entry_safe(tx_buffer, temp, &self->tx_bufferlist, node) {
+		list_del_init(&tx_buffer->node);
+		kmem_cache_free(self->tx_bufferlistpool, tx_buffer);
+	}
+	self->tx_data_cnt = 0;
+	self->tx_xfer_cnt = 0;
+	self->tx_proc_cnt = 0;
+	self->rx_data_toggle = 0;
+	self->tx_data_toggle = 0;
+	self->next_toggle = 0;
+}
+
+int bes2600_sdio_deactive(struct sbus_priv *self, int sub_system)
+{
+	u16 cfg = 0;
+	u8 cfm = 0;
+	u8 tmp_val = 0;
+	u16 retries = 0;
+	u32 cnt = 0;
+	u32 delay_cnt = 2;
+	int ret;
+
+	/* don't read/write sdio when sdio error */
+	if(bes2600_chrdev_is_bus_error())
+		return 0;
+
+	/* notify device deactive event */
+	if (bes2600_chrdev_is_signal_mode()) {
+		/* prevent concurrent access */
+		mutex_lock(&self->sbus_mutex);
+
+		/* set config and confirm value */
+		if (sub_system == SUBSYSTEM_MCU) {
+			cfg = BES_HOST_INT | BES_SUBSYSTEM_MCU_DEACTIVE;
+			cfm = BES_SLAVE_STATUS_MCU_WAKEUP_READY;
+		} else if (sub_system == SUBSYSTEM_WIFI) {
+			cfg = BES_HOST_INT | BES_SUBSYSTEM_WIFI_DEACTIVE;
+			cfm = BES_SLAVE_STATUS_WIFI_READY;
+		} else if(sub_system == SUBSYSTEM_BT) {
+			cfg = BES_HOST_INT | BES_SUBSYSTEM_BT_DEACTIVE;
+			cfm = BES_SLAVE_STATUS_BT_READY;
+		} else if(sub_system == SUBSYSTEM_BT_LP) {
+			cfg = BES_HOST_INT | BES_SUBSYSTEM_BT_SLEEP;
+			cfm = BES_SLAVE_STATUS_BT_WAKE_READY;
+		} else {
+			mutex_unlock(&self->sbus_mutex);
+			return -EINVAL;
+		}
+
+		/* wait until device ready */
+		do {
+			sdio_claim_host(self->func);
+			ret = bes2600_sdio_readb_safe(self->func, BES_SLAVE_STATUS_REG_ID);
+			sdio_release_host(self->func);
+			bes2600_dbg(BES2600_DBG_SDIO, "deactive wait mcu ready cnt:%d, reg:%d\n", cnt++, ret);
+
+			if(ret < 0) {
+				goto err;
+			}
+		} while((ret & BES_SLAVE_STATUS_MCU_READY) == 0);
+
+		do {
+			/* claim sdio host */
+			sdio_claim_host(self->func);
+
+			/* write first segment */
+			tmp_val = (cfg >> 8) & 0xff;
+			ret = bes2600_sdio_writeb_safe(self->func, BES_HOST_INT_REG_ID + 1, tmp_val);
+			if(ret < 0) {
+				sdio_release_host(self->func);
+				bes2600_err(BES2600_DBG_SDIO, "deactive write 1st seg failed\n");
+				goto err;
+			}
+
+			/* write second segment */
+			tmp_val = cfg & 0xff;
+			ret = bes2600_sdio_writeb_safe(self->func, BES_HOST_INT_REG_ID, tmp_val);
+			if(ret < 0) {
+				sdio_release_host(self->func);
+				bes2600_err(BES2600_DBG_SDIO, "deactive write 2nd seg failed\n");
+				goto err;
+			}
+
+			/* release sdio host */
+			sdio_release_host(self->func);
+
+			/* wait device to response */
+			msleep(delay_cnt);
+
+			/* read device response result */
+			sdio_claim_host(self->func);
+			ret = bes2600_sdio_readb_safe(self->func, BES_SLAVE_STATUS_REG_ID);
+			sdio_release_host(self->func);
+			if(ret < 0) {
+				bes2600_err(BES2600_DBG_SDIO, "deactive read response failed\n");
+				if (sub_system == SUBSYSTEM_MCU) {
+					/* cmd52 may return error when 2600 is sleeping */
+					ret = 0;
+					break;
+				} else {
+					goto err;
+				}
+			}
+			bes2600_dbg(BES2600_DBG_SDIO, "deactive resp cnt:%d, reg:%d, sub_sys:%d\n", retries, ret, sub_system);
+		} while((cfm != 0) && (ret & cfm) != 0 && ++retries < 200);
+
+		/* set fw_started flag to false */
+		if(bes2600_chrdev_is_signal_mode()
+		   && sub_system == SUBSYSTEM_WIFI)
+			self->fw_started = false;
+
+		/* reset sdio send and receive control variable */
+		if(sub_system == SUBSYSTEM_WIFI) {
+			bes2600_sdio_empty_work(self);
+		}
+
+		/* prevent concurrent access */
+		mutex_unlock(&self->sbus_mutex);
+
+		return (ret < 0) ? ret : 0;
+	} else {
+		return 0;
+	}
+
+err:
+	mutex_unlock(&self->sbus_mutex);
+	bes2600_chrdev_wifi_force_close(self->core, false);
+	return -ENODEV;
+}
+
+static int bes2600_sdio_power_switch(struct sbus_priv *self, int on)
+{
+	int ret = 0;
+	if(on) {
+		ret = bes2600_sdio_on(self->pdata);
+	} else {
+		ret = bes2600_sdio_off(self->pdata);
+	}
+
+	return ret;
+}
+
+static void bes2600_sdio_halt_device(struct sbus_priv *self)
+{
+	sdio_work_debug(self);
+}
+
+static bool bes2600_sdio_wakeup_source(struct sbus_priv *self)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+
+	if(pdata->wakeup_source) {
+		pdata->wakeup_source = false;
+		return true;
+	}
+
+	return false;
+}
+
+static struct sbus_ops bes2600_sdio_sbus_ops = {
+	.sbus_memcpy_fromio	= bes2600_sdio_memcpy_fromio,
+	.sbus_memcpy_toio	= bes2600_sdio_memcpy_toio,
+	.lock			= bes2600_sdio_lock,
+	.unlock			= bes2600_sdio_unlock,
+	.irq_subscribe		= bes2600_sdio_irq_subscribe,
+	.irq_unsubscribe	= bes2600_sdio_irq_unsubscribe,
+	.align_size		= bes2600_sdio_align_size,
+	.set_block_size		= bes2600_sdio_set_block_size,
+	.sbus_reg_read		= bes2600_sdio_reg_read,
+	.sbus_reg_write		= bes2600_sdio_reg_write,
+	.init			= bes2600_sdio_misc_init,
+	.pipe_read		= bes2600_sdio_pipe_read,
+	.pipe_send		= bes2600_sdio_pipe_send,
+	.sbus_active		= bes2600_sdio_active,
+	.sbus_deactive		= bes2600_sdio_deactive,
+	.power_switch		= bes2600_sdio_power_switch,
+	.gpio_wake		= bes2600_gpio_wakeup_mcu,
+	.gpio_sleep		= bes2600_gpio_allow_mcu_sleep,
+	.halt_device		= bes2600_sdio_halt_device,
+	.wakeup_source		= bes2600_sdio_wakeup_source,
+};
+
+static void bes2600_sdio_en_lp_cb(struct bes2600_common *hw_priv)
+{
+	long unsigned int old_ts, new_ts;
+	struct sbus_priv *self = hw_priv->sbus_priv;
+
+	do {
+		old_ts = self->last_irq_timestamp;
+		flush_work(&self->rx_work);
+		new_ts = self->last_irq_timestamp;
+	} while(old_ts != new_ts);
+}
+
+/* Probe Function to be called by SDIO stack when device is discovered */
+static int bes2600_sdio_probe(struct sdio_func *func,
+			      const struct sdio_device_id *id)
+{
+	struct sbus_priv *self;
+	int status = 0;
+
+	bes2600_info(BES2600_DBG_SDIO, "Probe called:%p,%d\n", func, func->num);
+	if (func->num > 1)
+		return 0;
+
+	func->card->host->caps |= MMC_CAP_NONREMOVABLE;
+	bes2600_chrdev_bus_probe_notify();
+
+	self = kzalloc(sizeof(*self), GFP_KERNEL);
+	if (!self) {
+		bes2600_dbg(BES2600_DBG_SDIO, "Can't allocate SDIO sbus_priv.");
+		return -ENOMEM;
+	}
+
+	self->pdata = kzalloc(sizeof(*(self->pdata)), GFP_KERNEL);
+	if (!self->pdata) {
+		bes2600_dbg(BES2600_DBG_SDIO, "Can't allocate platform data.");
+		kfree(self);
+		return -ENOMEM;
+	}
+
+	spin_lock_init(&self->lock);
+	self->func = func;
+	self->dev = &func->dev;
+
+	status = bes2600_platform_data_init(self);
+	if (status)
+		goto pdata_err;
+
+	self->gpio_wakup_flags = 0;
+	self->retune_protected = false;
+	self->unregister_in_process = false;
+	mutex_init(&self->io_mutex);
+	mutex_init(&self->sbus_mutex);
+	INIT_WORK(&self->sdio_scan_work, sdio_scan_work);
+	self->fw_started = false;
+	bes2600_gpio_wakeup_mcu(self, GPIO_WAKE_FLAG_SDIO_PROBE);
+
+	sdio_set_drvdata(func, self);
+	sdio_claim_host(func);
+	sdio_enable_func(func);
+	sdio_release_host(func);
+
+	bes2600_reg_set_object(&bes2600_sdio_sbus_ops, self);
+	status = bes2600_load_firmware(&bes2600_sdio_sbus_ops, self);
+	bes2600_info_with_cond((status > 0), BES2600_DBG_SDIO,
+			"interrupt init process beacuse device be closed.\n");
+	if(status > 0)		// for wifi closed case
+		goto out;
+	else if (status < 0)	// for download fail case
+		goto err;
+
+	status = bes2600_register_net_dev(self);
+	if (status)
+		goto err;
+
+out:
+	bes2600_chrdev_set_sbus_priv_data(self, false);
+	bes2600_gpio_allow_mcu_sleep(self, GPIO_WAKE_FLAG_SDIO_PROBE);
+	return 0;
+
+err:
+	bes2600_err(BES2600_DBG_SDIO, "%s failed, func:%d\n", __func__, func->num);
+	func->card->host->caps &= ~MMC_CAP_NONREMOVABLE;
+	sdio_claim_host(func);
+	sdio_disable_func(func);
+	sdio_release_host(func);
+	bes2600_gpio_allow_mcu_sleep(self, GPIO_WAKE_FLAG_SDIO_PROBE);
+	sdio_set_drvdata(func, NULL);
+	bes2600_reg_set_object(NULL, NULL);
+	bes2600_chrdev_set_sbus_priv_data(NULL, true);
+
+pdata_err:
+	kfree(self->pdata);
+	kfree(self);
+
+	return status;
+}
+
+int bes2600_register_net_dev(struct sbus_priv *bus_priv)
+{
+	int status = 0;
+	BUG_ON(!bus_priv);
+	status = bes2600_core_probe(&bes2600_sdio_sbus_ops,
+			      bus_priv, bus_priv->dev, &bus_priv->core);
+	if(!status)
+		bes2600_pwr_register_en_lp_cb(bus_priv->core, bes2600_sdio_en_lp_cb);
+
+	return status;
+}
+
+int bes2600_unregister_net_dev(struct sbus_priv *bus_priv)
+{
+	BUG_ON(!bus_priv);
+	if (bus_priv->core && !bus_priv->unregister_in_process) {
+		bus_priv->unregister_in_process = true;
+		bes2600_core_release(bus_priv->core);
+		bes2600_pwr_unregister_en_lp_cb(bus_priv->core, bes2600_sdio_en_lp_cb);
+		bus_priv->core = NULL;
+
+		if (bus_priv->sdio_wq) {
+			flush_workqueue(bus_priv->sdio_wq);
+			destroy_workqueue(bus_priv->sdio_wq);
+			bus_priv->sdio_wq = NULL;
+		}
+
+		if (bus_priv->rx_buffer) {
+			free_pages((unsigned long)bus_priv->rx_buffer, get_order(1632 * BES_SDIO_RX_MULTIPLE_NUM));
+			bus_priv->rx_buffer = NULL;
+		}
+
+		if (bus_priv->tx_buffer) {
+			kfree(bus_priv->tx_buffer);
+			bus_priv->tx_buffer = NULL;
+		}
+
+		if (bus_priv->tx_bufferlistpool) {
+			kmem_cache_destroy(bus_priv->tx_bufferlistpool);
+			bus_priv->tx_bufferlistpool = NULL;
+		}
+
+		bus_priv->unregister_in_process = false;
+	}
+	return 0;
+}
+
+bool bes2600_is_net_dev_created(struct sbus_priv *bus_priv)
+{
+	BUG_ON(!bus_priv);
+	return (bus_priv->core != NULL);
+}
+
+/* Disconnect Function to be called by SDIO stack when
+ * device is disconnected */
+static void bes2600_sdio_disconnect(struct sdio_func *func)
+{
+	struct sbus_priv *self = sdio_get_drvdata(func);
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+
+	func->card->host->caps &= ~MMC_CAP_NONREMOVABLE;
+	bes2600_info(BES2600_DBG_SDIO, "%s called:%p,%d\n", __func__, func, func->num);
+
+	if (self) {
+		bes2600_unregister_net_dev(self);
+		sdio_claim_host(func);
+		sdio_disable_func(func);
+		sdio_release_host(func);
+		bes2600_sdio_off(pdata);
+		bes2600_platform_data_deinit(self);
+		bes2600_reg_set_object(NULL, NULL);
+		bes2600_chrdev_set_sbus_priv_data(NULL, false);
+		sdio_set_drvdata(func, NULL);
+		if (self->retune_protected == true) {
+			sdio_retune_release(func);
+		}
+		kfree(self->pdata);
+		kfree(self);
+	}
+}
+
+static irqreturn_t bes2600_wlan_bt_hostwake_thread(int irq, void *dev_id)
+{
+	struct bes2600_platform_data_sdio *pdata = (struct bes2600_platform_data_sdio *)dev_id;
+
+	bes2600_info(BES2600_DBG_SDIO, "bes2600_wlan_hostwake:%d\n", dev_id == (void *)pdata);
+
+	pdata->wakeup_source = true;
+	disable_irq_nosync(irq);
+	return IRQ_HANDLED;
+}
+
+static int bes2600_wlan_bt_hostwake_register(struct sbus_priv *self)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+	int ret = 0;
+
+	// TODO: reimplement
+	//int irq_flags = rockchip_wifi_get_oob_irq_flag();
+	//int irq = rockchip_wifi_get_oob_irq();
+	int irq_flags = 0;
+	int irq = 0;
+
+	if (pdata->wlan_bt_hostwake_registered == true) {
+		bes2600_err(BES2600_DBG_SDIO, "wlan hostwake register repeatedly.\n");
+		return -1;
+	}
+
+	irq_flags |= IRQF_ONESHOT;
+	irq_flags &= (~IRQF_NO_SUSPEND);
+	if (((ret = request_threaded_irq(irq, NULL, bes2600_wlan_bt_hostwake_thread,
+		irq_flags, "bes2600_wlan_hostwake", pdata)) != 0) ||
+	    ((ret = enable_irq_wake(irq)) != 0)) {
+		bes2600_err(BES2600_DBG_SDIO, "request_irq or irq_wake failed with %d\n", ret);
+		return ret;
+	}
+
+	pdata->wlan_bt_hostwake_registered = true;
+	pdata->wakeup_source = false;
+
+	return ret;
+}
+
+static void bes2600_wlan_bt_hostwake_unregister(struct sbus_priv *self)
+{
+	struct bes2600_platform_data_sdio *pdata = self->pdata;
+	int ret = 0;
+
+	// TODO: reimplement
+	//int irq = rockchip_wifi_get_oob_irq();
+	int irq = 0;
+
+	if (pdata->wlan_bt_hostwake_registered == false)
+		return;
+
+	pdata->wlan_bt_hostwake_registered = false;
+	ret = disable_irq_wake(irq);
+	if (ret) {
+		bes2600_err(BES2600_DBG_SDIO, "disable_irq_wake failed with %d\n", ret);
+	}
+	free_irq(irq, pdata);
+}
+
+static int bes2600_gpio_wakeup_ap_config(struct sbus_priv *self)
+{
+	u8 wakeup_cfg = 0;
+	int ret = 0, irq_flags = 0, irq = 0;
+
+	if (!bes2600_chrdev_is_signal_mode())
+		return 0;
+
+	// TODO: reimplement
+	//irq_flags = rockchip_wifi_get_oob_irq_flag();
+	//irq = rockchip_wifi_get_oob_irq();
+
+	if (irq_flags & IRQF_TRIGGER_HIGH) {
+		wakeup_cfg = BES_AP_WAKEUP_GPIO_HIGH | BES_AP_WAKEUP_CFG_VALID;
+	} else if (irq_flags & IRQF_TRIGGER_LOW) {
+		wakeup_cfg = BES_AP_WAKEUP_GPIO_LOW | BES_AP_WAKEUP_CFG_VALID;
+	} else if (irq_flags & IRQF_TRIGGER_RISING) {
+		wakeup_cfg = BES_AP_WAKEUP_GPIO_RISE | BES_AP_WAKEUP_CFG_VALID;
+	} else if (irq_flags & IRQF_TRIGGER_FALLING) {
+		wakeup_cfg = BES_AP_WAKEUP_GPIO_FALL | BES_AP_WAKEUP_CFG_VALID;
+	}
+
+	if (wakeup_cfg & BES_AP_WAKEUP_CFG_VALID)
+		wakeup_cfg |= (BES_AP_WAKEUP_TYPE_GPIO << BES_AP_WAKEUP_TYPE_SHIFT);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s config:%x\n", __func__, wakeup_cfg);
+
+	sdio_claim_host(self->func);
+	sdio_writeb(self->func, wakeup_cfg, BES_AP_WAKEUP_REG_ID, &ret);
+	if (!ret) {
+		sdio_writeb(self->func, 0, BES_HOST_INT_REG_ID + 1, &ret);
+	}
+	if (!ret) {
+		sdio_writeb(self->func, (BES_HOST_INT | BES_AP_WAKEUP_CFG), BES_HOST_INT_REG_ID, &ret);
+	}
+	sdio_release_host(self->func);
+	if (ret) {
+		bes2600_err(BES2600_DBG_SDIO, "%s failed:%d\n", __func__, ret);
+		free_irq(irq, self->pdata);
+		return ret;
+	}
+
+	return 0;
+}
+
+int bes2600_sdio_prepare(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+
+	if (func->num > 1)
+		return 0;
+
+	if(bes2600_sdio_sbus_ops.gpio_wake)
+		bes2600_sdio_sbus_ops.gpio_wake(self, GPIO_WAKE_FLAG_HOST_SUSPEND);
+
+	return 0;
+}
+
+static int bes2600_sdio_suspend(struct device *dev)
+{
+	int ret;
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+	if (func->num > 1)
+		return 0;
+
+	if(bes2600_chrdev_check_system_close() == false)
+		return -EBUSY;
+
+	/* Notify SDIO that BES2600 will remain powered during suspend */
+	ret = sdio_set_host_pm_flags(func, MMC_PM_KEEP_POWER);
+	if (ret) {
+		bes2600_err(BES2600_DBG_PM, "Error setting SDIO pm flags: %i\n", ret);
+		return ret;
+	}
+
+	if (bes2600_chrdev_is_bt_opened() == true) {
+		if ((ret = bes2600_sdio_deactive(self, SUBSYSTEM_BT_LP))) {
+			bes2600_err(BES2600_DBG_PM, "bt sleep in suspend failed:%d.\n", ret);
+			return ret;
+		}
+	}
+
+	return bes2600_wlan_bt_hostwake_register(self);
+}
+
+static int bes2600_sdio_suspend_noirq(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+
+	if (func->num > 1)
+		return 0;
+
+	if(self->core &&
+	   (work_pending(&self->rx_work) || atomic_read(&self->core->bh_rx))) {
+		bes2600_info(BES2600_DBG_SDIO, "%s: Suspend interrupted.\n", __func__);
+		return -EAGAIN;
+	}
+
+	if(bes2600_sdio_sbus_ops.gpio_sleep)
+		bes2600_sdio_sbus_ops.gpio_sleep(self, GPIO_WAKE_FLAG_HOST_SUSPEND);
+
+	if (self->retune_protected == true)
+		bes2600_warn(BES2600_DBG_SDIO, "retune is closed while ap sleep.\n");
+
+	return 0;
+}
+
+int bes2600_sdio_resume_noirq(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+
+	if (func->num > 1)
+		return 0;
+
+	if(bes2600_sdio_sbus_ops.gpio_wake)
+		bes2600_sdio_sbus_ops.gpio_wake(self, GPIO_WAKE_FLAG_HOST_RESUME);
+
+	return 0;
+}
+
+static int bes2600_sdio_resume(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+
+	if (func->num > 1)
+		return 0;
+
+	bes2600_wlan_bt_hostwake_unregister(self);
+
+	return 0;
+}
+
+static void bes2600_sdio_complete(struct device *dev)
+{
+	struct sdio_func *func = dev_to_sdio_func(dev);
+	struct sbus_priv *self = sdio_get_drvdata(func);
+
+	bes2600_info(BES2600_DBG_SDIO, "%s (%p,%d)enter\n", __func__, func, func->num);
+
+	if (func->num > 1)
+		return;
+
+	/* wakeup bt if bt is on */
+	bes2600_chrdev_wakeup_bt();
+
+	/* clear resume gpio wake flag */
+	if(bes2600_sdio_sbus_ops.gpio_sleep)
+		bes2600_sdio_sbus_ops.gpio_sleep(self, GPIO_WAKE_FLAG_HOST_RESUME);
+}
+
+static const struct dev_pm_ops bes2600_pm_ops = {
+	.prepare = bes2600_sdio_prepare,
+	.suspend = bes2600_sdio_suspend,
+	.suspend_noirq = bes2600_sdio_suspend_noirq,
+	.resume_noirq = bes2600_sdio_resume_noirq,
+	.resume = bes2600_sdio_resume,
+	.complete = bes2600_sdio_complete,
+};
+
+static struct sdio_driver sdio_driver = {
+	.name		= "bes2600_wlan",
+	.id_table	= bes2600_sdio_ids,
+	.probe		= bes2600_sdio_probe,
+	.remove		= bes2600_sdio_disconnect,
+	.drv = {
+		.pm = &bes2600_pm_ops,
+	}
+};
+
+/* Init Module function -> Called by insmod */
+static int __init bes2600_sdio_init(void)
+{
+	int ret;
+
+	bes2600_info(BES2600_DBG_SDIO, "------Driver: bes2600.ko version :%s\n", BES2600_DRV_VERSION);
+
+	bes2600_chrdev_update_signal_mode();
+	bes2600_dbg(BES2600_DBG_SDIO, "%s type:%d sig_mode:%d\n", __func__,
+			bes2600_chrdev_get_fw_type(), bes2600_chrdev_is_signal_mode());
+
+	ret = bes2600_chrdev_init(&bes2600_sdio_sbus_ops);
+	if(ret)
+		goto err_chardev;
+
+	ret = sdio_register_driver(&sdio_driver);
+	if (ret)
+		goto err_reg;
+
+	return 0;
+
+err_reg:
+	bes2600_chrdev_free();
+err_chardev:
+	return ret;
+}
+
+/* Called at Driver Unloading */
+static void __exit bes2600_sdio_exit(void)
+{
+	bes2600_info(BES2600_DBG_SDIO, "%s called\n", __func__);
+
+	bes2600_chrdev_free();
+	sdio_unregister_driver(&sdio_driver);
+}
+
+module_init(bes2600_sdio_init);
+module_exit(bes2600_sdio_exit);
diff --git a/drivers/staging/bes2600/bes_chardev.c b/drivers/staging/bes2600/bes_chardev.c
new file mode 100755
index 000000000000..4a0c407535d6
--- /dev/null
+++ b/drivers/staging/bes2600/bes_chardev.c
@@ -0,0 +1,1080 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include<linux/module.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/atomic.h>
+#include <linux/wait.h>
+#include <linux/crc32.h>
+#include <linux/version.h>
+#include "bes2600.h"
+#include "sbus.h"
+#include "hwio.h"
+#include "fwio.h"
+#include "bes_chardev.h"
+#include "tx_loop.h"
+
+enum wait_state {
+	BES2600_BOOT_WAIT_NONE = 0,
+	BES2600_BOOT_WAIT_PROBE_DONE,
+	BES2600_BOOT_WAIT_CLOSE,
+};
+
+enum bus_probe_state {
+	BES2600_BUS_PROBE_NONE = 0,
+	BES2600_BUS_PROBE_START,
+	BES2600_BUS_PROBE_OK,
+	BES2600_BUS_PROBE_TIMEOUT,
+};
+
+struct bes_cdev
+{
+	struct cdev cdev;
+	dev_t dev_id;
+	int major;
+	int minor;
+	struct class *class;
+	struct device *device;
+	atomic_t num_proc;
+	wait_queue_head_t open_wq;
+	spinlock_t status_lock;
+	bool wifi_opened;
+	bool bt_opened;
+	bool bton_pending;
+	bool dpd_calied;
+	u8 *dpd_data;
+	u32 dpd_len;
+	enum wait_state wait_state;
+	wait_queue_head_t probe_done_wq;
+	const struct sbus_ops *sbus_ops;
+	struct sbus_priv *sbus_priv;
+	bool sig_mode;
+	int fw_type;
+	bool bus_error;
+	bool halt_dev;
+	struct delayed_work probe_timeout_work;
+	enum bus_probe_state bus_probe;
+	struct work_struct wifi_force_close_work;
+	enum pend_read_op read_flag;
+	u32 wakeup_state; /* for userspace check wakeup reason */
+};
+
+struct bes2600_op_map
+{
+	char op[20];	// operation
+	int op_len;	// operation length, used for effiency
+	int (*handler) (const char *cmd); // handler
+};
+
+static struct bes_cdev bes2600_cdev;
+module_param_named(fw_type, bes2600_cdev.fw_type, int, 0644);
+
+extern int bes2600_register_net_dev(struct sbus_priv *bus_priv);
+extern int bes2600_unregister_net_dev(struct sbus_priv *bus_priv);
+extern bool bes2600_is_net_dev_created(struct sbus_priv *bus_priv);
+
+static bool bes2600_bootup_end(void)
+{
+	bool end;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	end = (bes2600_cdev.bus_probe == BES2600_BUS_PROBE_TIMEOUT ||
+	       bes2600_cdev.sbus_priv != NULL ||
+	       bes2600_cdev.bus_error);
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return end;
+}
+
+static int bes2600_chrdev_switch_subsys(int wake_flag, int subsys, bool active)
+{
+	int ret = 0;
+
+	if(bes2600_cdev.sbus_priv == NULL)
+		return -EFAULT;
+
+	if(active) {
+		if(bes2600_cdev.sbus_ops->gpio_wake)
+			bes2600_cdev.sbus_ops->gpio_wake(bes2600_cdev.sbus_priv, wake_flag);
+
+		if(bes2600_cdev.sbus_ops->sbus_active)
+			ret = bes2600_cdev.sbus_ops->sbus_active(bes2600_cdev.sbus_priv, subsys);
+
+		if(bes2600_cdev.sbus_ops->gpio_sleep)
+			bes2600_cdev.sbus_ops->gpio_sleep(bes2600_cdev.sbus_priv, wake_flag);
+	} else {
+		if(bes2600_cdev.sbus_ops->gpio_wake)
+			bes2600_cdev.sbus_ops->gpio_wake(bes2600_cdev.sbus_priv, wake_flag);
+
+		if(bes2600_cdev.sbus_ops->sbus_deactive)
+			ret = bes2600_cdev.sbus_ops->sbus_deactive(bes2600_cdev.sbus_priv, subsys);
+
+		if(bes2600_cdev.sbus_ops->gpio_sleep)
+			bes2600_cdev.sbus_ops->gpio_sleep(bes2600_cdev.sbus_priv, wake_flag);
+	}
+
+	return ret;
+}
+
+static int bes2600_switch_wifi(bool on)
+{
+	int ret = 0;
+	long status = 0;
+
+	if(bes2600_cdev.wifi_opened == on)
+		return 0;
+
+	if(on) {
+		if(bes2600_chrdev_check_system_close()) {
+			bes2600_info(BES2600_DBG_CHARDEV, "power up bes2600 when active wifi.\n");
+			/* reset bus error status when restart bes2600 */
+			spin_lock(&bes2600_cdev.status_lock);
+			bes2600_cdev.bus_error = false;
+			bes2600_cdev.halt_dev = false;
+			bes2600_cdev.bus_probe = BES2600_BUS_PROBE_NONE;
+			spin_unlock(&bes2600_cdev.status_lock);
+
+			/* power up bes2600, trigger system to execute probe function */
+			bes2600_cdev.wifi_opened = true;
+			bes2600_cdev.sbus_ops->power_switch(NULL, 1);
+
+			/* wait probe done event */
+			status = wait_event_timeout(bes2600_cdev.probe_done_wq, 
+					bes2600_bootup_end(), HZ * 8);
+			WARN_ON(status <= 0);
+			ret = (status <= 0 || bes2600_chrdev_is_bus_error()) ? -1 : 0;
+		} else {
+			/* bes2600 is already powered up, we just need to create net device */
+			if(bes2600_cdev.sbus_priv) {
+				if(!bes2600_is_net_dev_created(bes2600_cdev.sbus_priv)) {
+					ret = bes2600_register_net_dev(bes2600_cdev.sbus_priv);
+				}
+			} else {
+				ret = -EFAULT;
+			}
+		}
+	} else {
+		if(bes2600_cdev.sbus_priv && bes2600_is_net_dev_created(bes2600_cdev.sbus_priv)) {
+			bes2600_unregister_net_dev(bes2600_cdev.sbus_priv);
+		}
+	}
+
+	if(!ret) {
+		bes2600_cdev.wifi_opened = on;
+	} else {
+		bes2600_cdev.wifi_opened = false;
+		bes2600_info_with_cond(on, BES2600_DBG_CHARDEV, "open wifi failed\n");
+	}
+
+	return ret;
+}
+
+static int bes2600_switch_bt(bool on)
+{
+	int ret = 0;
+	long status = 0;
+
+	if(bes2600_cdev.bt_opened == on)
+		return 0;
+
+	if(on) {
+		if(bes2600_chrdev_check_system_close()) {
+			bes2600_info(BES2600_DBG_CHARDEV, "power up bes2600 when active bt.\n");
+			/* reset bus error status when restart bes2600 */
+			spin_lock(&bes2600_cdev.status_lock);
+			bes2600_cdev.bus_error = false;
+			bes2600_cdev.halt_dev = false;
+			bes2600_cdev.bus_probe = BES2600_BUS_PROBE_NONE;
+			spin_unlock(&bes2600_cdev.status_lock);
+
+			/* set opend state in advance */
+			bes2600_cdev.bt_opened = true;
+			bes2600_cdev.bton_pending = true;
+
+			/* power up bes2600, trigger system to execute probe function */
+			bes2600_cdev.sbus_ops->power_switch(NULL, 1);
+
+			/* wait bootup process end */
+			status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+				bes2600_bootup_end(), HZ * 8);
+			WARN_ON(status <= 0);
+
+			/* check if there is a error when bootup */
+			ret = (status <= 0 || bes2600_chrdev_is_bus_error()) ? -1 : 0;
+		} else {
+			bes2600_info(BES2600_DBG_CHARDEV, "bes2600 activate bt.\n");
+			ret = bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_ON, SUBSYSTEM_BT, true);
+		}
+	} else {
+		bes2600_info(BES2600_DBG_CHARDEV, "bes2600 deactivate bt.\n");
+		bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_OFF, SUBSYSTEM_BT, false);
+	}
+
+	if(!ret) {
+		bes2600_cdev.bt_opened = on;
+	} else {
+		bes2600_cdev.bt_opened = false;
+		bes2600_cdev.bton_pending = false;
+		bes2600_info_with_cond(ret, BES2600_DBG_CHARDEV, "open bt failed\n");
+	}
+
+	return ret;
+}
+
+static int bes2600_get_cmd_and_ifname(const char *str, char **result)
+{
+	int cmd_len = 0;
+	int ifname_len = 0;
+	char *sp = NULL;
+	char *tmp_ptr = NULL;
+	char *cmd_ptr = NULL;
+
+	/* check if input arguments is valid */
+	if(!str || strncmp(str, "ifname:", 7) != 0)
+		return -1;
+
+	sp = strchr(str, ' ');
+	if(strncmp(sp + 1, "cmd:", 4) != 0)
+		return -1;
+
+	/* extract interface name */
+	ifname_len = sp - str - 7;
+	tmp_ptr = kmalloc(ifname_len + 1, GFP_KERNEL);
+	if(!tmp_ptr) {
+		return -2;
+	}
+
+	strncpy(tmp_ptr, str+7, ifname_len);
+	tmp_ptr[ifname_len] = '\0';
+	result[0] = tmp_ptr;
+
+	/* get command length */
+	cmd_ptr = strstr(str, "cmd:");
+	cmd_ptr += 4;
+	sp = strchr(cmd_ptr, ' ');
+	if(!sp) {	/* the command don't have any parameter */
+		cmd_len = strlen(cmd_ptr);
+		if(cmd_ptr[cmd_len - 1] == '\n')
+			--cmd_len;
+	} else {	/* the command have one or more parameter */
+		cmd_len = sp - cmd_ptr;
+	}
+
+	/* copy command to out buffer */
+	tmp_ptr = kmalloc( cmd_len + 1, GFP_KERNEL);
+	if(!tmp_ptr) {
+		kfree(result[0]);
+		result[0] = NULL;
+		return -3;
+	}
+
+	strncpy(tmp_ptr, cmd_ptr, cmd_len);
+	tmp_ptr[cmd_len] = '\0';
+	result[1] = tmp_ptr;
+
+	return 0;
+}
+
+static void bes2600_recyle_cmd_and_ifname_mem(char **info)
+{
+	if(info[0]) {
+		kfree(info[0]);
+		info[0] = NULL;
+	}
+
+	if(info[1]) {
+		kfree(info[1]);
+		info[1] = NULL;
+	}
+
+}
+
+static int bes2600_op_default_handler(const char *str)
+{
+	char *info[2] = {0};
+
+	if(bes2600_get_cmd_and_ifname(str, info) == 0) {
+		bes2600_info(BES2600_DBG_CHARDEV, "cmd(%s) on %s not handled\n", info[1], info[0]);
+	} else {
+		bes2600_err(BES2600_DBG_CHARDEV, "%s get command fail, the origin string is %s\n", __func__, str);
+	}
+
+	bes2600_recyle_cmd_and_ifname_mem(info);
+
+	return 0;
+}
+
+static int bes2600_op_wifi_bt_on_off(const char *str)
+{
+	char *info[2] = {0};
+	int ret = 0;
+	enum wait_state wait_state;
+	enum bus_probe_state probe_state;
+	unsigned long status = 0;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	probe_state = bes2600_cdev.bus_probe;
+	wait_state = bes2600_cdev.wait_state;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	/* only work for wifi signal mode */
+	if(bes2600_cdev.fw_type != BES2600_FW_TYPE_WIFI_SIGNAL)
+		return -EFAULT;
+
+	/* wait bus probe operation end */
+	if(probe_state == BES2600_BUS_PROBE_START) {
+		bes2600_info(BES2600_DBG_CHARDEV, "wait bus probe operation end\n");
+		status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+					(bes2600_cdev.bus_probe > BES2600_BUS_PROBE_START),
+					HZ);
+		WARN_ON(status <= 0);
+	}
+
+	/* must wait previous operation end in critical section */
+	if(wait_state != BES2600_BOOT_WAIT_NONE) {
+		bes2600_info(BES2600_DBG_CHARDEV, "wait previous operation end\n");
+		status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+					(bes2600_cdev.wait_state == BES2600_BOOT_WAIT_NONE),
+					HZ * 8);
+		WARN_ON(status <= 0);
+	}
+
+	/* if dpd calibration is doing, modify wifi and bt state directly */
+	spin_lock(&bes2600_cdev.status_lock);
+	if(bes2600_cdev.bus_probe == BES2600_BUS_PROBE_OK && !bes2600_cdev.dpd_calied) {
+		if(bes2600_get_cmd_and_ifname(str, info) == 0) {
+			if(strncmp(info[1], "WIFI_ON", 7) == 0) {
+				bes2600_cdev.wifi_opened = true;
+			} else if(strncmp(info[1], "WIFI_OFF", 8) == 0) {
+				bes2600_cdev.wifi_opened = false;
+			} else if(strncmp(info[1], "BT_ON", 5) == 0) {
+				bes2600_cdev.bt_opened = true;
+				bes2600_cdev.bton_pending = true;
+			} else if(strncmp(info[1], "BT_OFF", 6) == 0) {
+				bes2600_cdev.bt_opened = false;
+				bes2600_cdev.bton_pending = false;
+			}
+		}
+		bes2600_recyle_cmd_and_ifname_mem(info);
+		spin_unlock(&bes2600_cdev.status_lock);
+
+		/* wait probe done event */
+		status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+				bes2600_bootup_end(), HZ * 8);
+		WARN_ON(status <= 0);
+
+		return (status <= 0 || bes2600_chrdev_is_bus_error()) ? -EFAULT : 0;
+	}
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	/* process wifi/bt on/off operation */
+	if(bes2600_get_cmd_and_ifname(str, info) == 0) {
+		if(strncmp(info[1], "WIFI_ON", 7) == 0) {
+			ret = bes2600_switch_wifi(1);
+		} else if(strncmp(info[1], "WIFI_OFF", 8) == 0) {
+			ret = bes2600_switch_wifi(0);
+		} else if(strncmp(info[1], "BT_ON", 5) == 0) {
+			ret = bes2600_switch_bt(1);
+		} else if(strncmp(info[1], "BT_OFF", 6) == 0) {
+			ret = bes2600_switch_bt(0);
+		}
+	}
+
+	if(!ret && bes2600_chrdev_check_system_close())
+		ret = bes2600_chrdev_do_system_close(bes2600_cdev.sbus_ops,
+						bes2600_cdev.sbus_priv);
+
+	bes2600_recyle_cmd_and_ifname_mem(info);
+
+	return ret ;
+}
+
+
+static int bes2600_op_change_fw_type(const char *str)
+{
+	int ret = 0;
+	int temp = 0;
+	long status = 0;
+	char *cmd_ptr = NULL;
+	char fw_type[5] = {0};
+	bool sys_closed = bes2600_chrdev_check_system_close();
+
+	bes2600_dbg(BES2600_DBG_CHARDEV, "%s is called, arg:%s\n", __func__, str);
+
+	/* check if user input is valid */
+	cmd_ptr = strstr(str, "CHANGE_FW_TYPE ");
+	if(strlen(str) < 16 || !cmd_ptr) {
+		bes2600_err(BES2600_DBG_CHARDEV, "the format of \"%s\" is error\n", str);
+		return -EINVAL;
+	}
+
+	/* convert fw_type from string to int */
+	strncpy(fw_type, cmd_ptr + 14, 4);
+	fw_type[0] = '+';
+	ret = kstrtoint(fw_type, 10, &temp);
+	if(ret < 0) {
+		bes2600_err(BES2600_DBG_CHARDEV, "%s parse error\n", __func__);
+		return -EINVAL;
+	}
+
+	/* no need to realod firmware if new fw_type is equal to the old */
+	if(temp == bes2600_cdev.fw_type ) {
+		bes2600_info(BES2600_DBG_CHARDEV, "fw type is equal\n");
+		return 0;
+	}
+
+	/* close wifi net device */
+	if(bes2600_cdev.sbus_priv
+	    && bes2600_is_net_dev_created(bes2600_cdev.sbus_priv)) {
+		bes2600_unregister_net_dev(bes2600_cdev.sbus_priv);
+	}
+
+	/* update firmware type */
+	bes2600_cdev.fw_type = temp;
+	bes2600_chrdev_update_signal_mode();
+
+	if(!sys_closed) {
+		/* close device to call disconnect function */
+		bes2600_cdev.sbus_ops->power_switch(bes2600_cdev.sbus_priv, 0);
+	}
+
+	/* wait disconnect event */
+	status = wait_event_timeout(bes2600_cdev.probe_done_wq, (bes2600_cdev.sbus_priv == NULL), HZ * 10);
+	WARN_ON(status <= 0);
+
+
+	if(bes2600_cdev.dpd_calied
+	   && bes2600_chrdev_check_system_close()) {
+		bes2600_info(BES2600_DBG_CHARDEV, "no need to reload firmware\n");
+		return 0;
+	}
+
+
+	/* power on device to call probe function */
+	bes2600_info(BES2600_DBG_CHARDEV, "reload firmware...\n");
+	bes2600_cdev.sbus_ops->power_switch(NULL, 1);
+	/* wait probe done event */
+	status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+			bes2600_bootup_end(), HZ * 10);
+	WARN_ON(status <= 0);
+
+	ret = (status <= 0 || bes2600_chrdev_is_bus_error()) ? -1 : 0;
+
+
+	return ret;
+}
+
+static int bes2600_op_bt_wakeup(const char *str)
+{
+	int ret = 0;
+	unsigned long status = 0;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	if(!bes2600_cdev.bt_opened) {
+		spin_unlock(&bes2600_cdev.status_lock);
+		return -EFAULT;
+	}
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	/* wait probe done event */
+	status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+			bes2600_bootup_end(), HZ * 8);
+	if(status <= 0 || bes2600_chrdev_is_bus_error())
+		return -EFAULT;
+
+	bes2600_info(BES2600_DBG_CHARDEV, "bes2600 wakeup bt.\n");
+	ret = bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_LP_ON, SUBSYSTEM_BT_LP, true);
+
+	return ret;
+}
+
+static int bes2600_op_bt_sleep(const char *str)
+{
+	int ret = 0;
+	unsigned long status = 0;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	if(!bes2600_cdev.bt_opened) {
+		spin_unlock(&bes2600_cdev.status_lock);
+		return -EFAULT;
+	}
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	/* wait probe done event */
+	status = wait_event_timeout(bes2600_cdev.probe_done_wq,
+			bes2600_bootup_end(), HZ * 8);
+	if(status <= 0 || bes2600_chrdev_is_bus_error())
+		return -EFAULT;
+
+	bes2600_info(BES2600_DBG_CHARDEV, "bes2600 allow bt sleep.\n");
+	ret = bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_LP_OFF, SUBSYSTEM_BT_LP, false);
+
+	return ret;
+}
+
+static int bes2600_op_set_wakeup_read_flag(const char *str)
+{
+	bes2600_dbg(BES2600_DBG_CHARDEV, "%s is called, arg:%s\n", __func__, str);
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.read_flag = BES_CDEV_READ_WAKEUP_STATE;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return 0;
+}
+
+static struct bes2600_op_map bes2600_op_map_tab[] ={
+	/*op			op_len	handler				*/
+	{"P2P_SET_NOA", 	11,	bes2600_op_default_handler},
+	{"P2P_SET_PS", 		10,	bes2600_op_default_handler},
+	{"SET_AP_WPS_P2P_IE",	17, 	bes2600_op_default_handler},
+	{"LINKSPEED", 		9,	bes2600_op_default_handler},
+	{"RSSI",		4,	bes2600_op_default_handler},
+	{"GETBAND", 		7,	bes2600_op_default_handler},
+	{"WLS_BATCHING", 	12,	bes2600_op_default_handler},
+	{"MACADDR",		7,	bes2600_op_default_handler},
+	{"RXFILTER-START",	14,	bes2600_op_default_handler},
+	{"RXFILTER-STOP",	13,	bes2600_op_default_handler},
+	{"RXFILTER-ADD",	12,	bes2600_op_default_handler},
+	{"RXFILTER-REMOVE",	15,	bes2600_op_default_handler},
+	{"BTCOEXMODE",		10,	bes2600_op_default_handler},
+	{"BTCOEXSCAN-START",	16,	bes2600_op_default_handler},
+	{"BTCOEXSCAN-STOP",	15,	bes2600_op_default_handler},
+	{"SETSUSPENDMODE",	14,	bes2600_op_default_handler},
+	{"COUNTRY",		7,	bes2600_op_default_handler},
+	{"WIFI_ON", 		7,	bes2600_op_wifi_bt_on_off},
+	{"WIFI_OFF", 		8,	bes2600_op_wifi_bt_on_off},
+	{"BT_ON", 		5,	bes2600_op_wifi_bt_on_off},
+	{"BT_OFF", 		6,	bes2600_op_wifi_bt_on_off},
+	{"CHANGE_FW_TYPE",	14,	bes2600_op_change_fw_type},
+	{"BT_WAKEUP",		9,	bes2600_op_bt_wakeup},
+	{"BT_SLEEP",		8,	bes2600_op_bt_sleep},
+	{"WAKEUP_STATE",	12,	bes2600_op_set_wakeup_read_flag},
+};
+
+static int bes2600_chrdev_check_system_close_internal(void)
+{
+	return (bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_SIGNAL)
+		&&(bes2600_cdev.bt_opened == false)
+		&& (bes2600_cdev.wifi_opened == false);
+}
+
+static int bes2600_chrdev_open(struct inode *inode, struct file *filp)
+{
+	if(atomic_read(&bes2600_cdev.num_proc) > 0) {
+		wait_event_timeout(bes2600_cdev.open_wq, 
+			(atomic_read(&bes2600_cdev.num_proc) == 0),
+			MAX_SCHEDULE_TIMEOUT);
+	}
+
+	bes2600_dbg(BES2600_DBG_CHARDEV, "bes2600 char device is opened\n");
+	atomic_inc(&bes2600_cdev.num_proc);
+
+        return 0;
+}
+
+static ssize_t bes2600_chrdev_read(struct file *file, char __user *user_buf,
+			     size_t count, loff_t *ppos)
+{
+	char buf[64] = {0};
+	unsigned int len;
+
+	switch (bes2600_cdev.read_flag) {
+	case BES_CDEV_READ_WAKEUP_STATE:
+		len = sprintf(buf, "wakeup_state:%u\n", bes2600_cdev.wakeup_state);
+		break;
+	default:
+		len = sprintf(buf, "dpd_calied:%d wifi_opened:%d bt_opened:%d fw_type:%d\n",
+				bes2600_cdev.dpd_calied,
+				bes2600_cdev.wifi_opened,
+				bes2600_cdev.bt_opened,
+				bes2600_cdev.fw_type);
+		break;
+	}
+
+	len = sizeof(buf);
+	/* reset read flag */
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.read_flag = BES_CDEV_READ_NUM_MAX;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return simple_read_from_buffer(user_buf, count, ppos, buf, len);
+}
+
+static ssize_t bes2600_chrdev_write(struct file *file,
+		 const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	int i = 0;
+	int cmd_num = ARRAY_SIZE(bes2600_op_map_tab);
+	int cmd_len = 0;
+	int ret = 0;
+	char *info[2] = {0};
+	char *buf = NULL;
+
+	/* copy content from user space to kernel */
+	/* message format:"ifname:wlanx cmd:xxx arg1 arg2 ..." */
+	buf = kmalloc(count + 1, GFP_KERNEL);
+	if (copy_from_user(buf, user_buf, count))
+		return -EFAULT;
+
+	/* add terminal character */
+	buf[count] = '\0';
+
+	/* extract comand and interface */
+	if(bes2600_get_cmd_and_ifname(buf, info) != 0) {
+		bes2600_err(BES2600_DBG_CHARDEV, "%s get command fail, the origin string is %s\n", __func__, buf);
+		kfree(buf);
+		return -EINVAL;
+	}
+
+	/* match operation item and execure its handler */
+	cmd_len = strlen(info[1]);
+	for(i = 0; i < cmd_num; i++) {
+		if(cmd_len < bes2600_op_map_tab[i].op_len)
+			continue;
+
+		if(strncasecmp(info[1], bes2600_op_map_tab[i].op, bes2600_op_map_tab[i].op_len) == 0) {
+			ret = bes2600_op_map_tab[i].handler(buf);
+			break;
+		}
+	}
+
+	/* operation item mismatch */
+	if(i == cmd_num) {
+		bes2600_err(BES2600_DBG_CHARDEV, "cmd(%s) mismatch\n", info[1]);
+	}
+
+	bes2600_recyle_cmd_and_ifname_mem(info);
+	kfree(buf);
+
+	return (ret == 0) ? count : ret;
+}
+
+static int bes2600_chrdev_release (struct inode *inode, struct file *file)
+{
+	if(atomic_dec_and_test(&bes2600_cdev.num_proc)) {
+		wake_up(&bes2600_cdev.open_wq);
+	}
+
+	bes2600_dbg(BES2600_DBG_CHARDEV, "bes2600 char device is closed\n");
+
+	return 0;
+}
+
+static struct file_operations bes2600_chardev_fops =
+{
+	.owner = THIS_MODULE,
+	.open = bes2600_chrdev_open,
+	.read = bes2600_chrdev_read,
+	.write = bes2600_chrdev_write,
+	.release = bes2600_chrdev_release,
+};
+
+const u8* bes2600_chrdev_get_dpd_data(u32 *len)
+{
+	if(!bes2600_cdev.dpd_calied)
+		return NULL;
+	if(len)
+		*len = bes2600_cdev.dpd_len;
+
+	return bes2600_cdev.dpd_data;
+}
+
+u8* bes2600_chrdev_get_dpd_buffer(u32 size)
+{
+	if(bes2600_cdev.dpd_data)
+		kfree(bes2600_cdev.dpd_data);
+
+	bes2600_cdev.dpd_data = kmalloc(size, GFP_KERNEL);
+	if(!bes2600_cdev.dpd_data) {
+		return NULL;
+	}
+
+	bes2600_cdev.dpd_len = DPD_BIN_SIZE;
+
+	return bes2600_cdev.dpd_data;
+}
+
+void bes2600_chrdev_free_dpd_data(void)
+{
+	if(bes2600_cdev.dpd_data)
+		kfree(bes2600_cdev.dpd_data);
+
+	bes2600_cdev.dpd_data = NULL;
+	bes2600_cdev.dpd_len = 0;
+}
+
+int bes2600_chrdev_update_dpd_data(void)
+{
+	u32 cal_crc = 0;
+	u32 dpd_crc = *((u32 *)bes2600_cdev.dpd_data);
+
+	/* check if the dpd data is valid */
+	cal_crc ^= 0xffffffffL;
+	cal_crc = crc32_le(cal_crc, bes2600_cdev.dpd_data + 4, bes2600_cdev.dpd_len - 4);
+	cal_crc ^= 0xffffffffL;
+	if(cal_crc != dpd_crc) {
+		bes2600_err(BES2600_DBG_CHARDEV,
+			"bes2600 dpd data check failed, calc_crc:0x%08x dpd_crc: 0x%08x\n",
+			cal_crc, dpd_crc);
+		return -1;
+	}
+
+	bes2600_info(BES2600_DBG_CHARDEV, "bes2600 dpd cali pass.\n");
+
+	/* update dpd calibration and wait state */
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.dpd_calied = true;
+	if(bes2600_chrdev_check_system_close_internal()) {
+		bes2600_cdev.wait_state = BES2600_BOOT_WAIT_CLOSE;
+	} else {
+		bes2600_cdev.wait_state = BES2600_BOOT_WAIT_PROBE_DONE;
+	}
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return 0;
+}
+
+void bes2600_chrdev_set_sbus_priv_data(struct sbus_priv *priv, bool error)
+{
+	bes2600_cdev.sbus_priv = priv;
+	if(priv) {
+		if(bes2600_cdev.bton_pending) {
+			bes2600_info(BES2600_DBG_CHARDEV, "execute pending bt on operation.\n");
+			bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_ON, SUBSYSTEM_BT, true);
+
+			bes2600_cdev.bton_pending = false;
+		}
+
+		spin_lock(&bes2600_cdev.status_lock);
+		if(bes2600_cdev.wait_state == BES2600_BOOT_WAIT_PROBE_DONE) {
+			bes2600_cdev.wait_state = BES2600_BOOT_WAIT_NONE;
+		}
+		spin_unlock(&bes2600_cdev.status_lock);
+
+		bes2600_info(BES2600_DBG_CHARDEV, "wakup proc on wq of probe_done.\n");
+	} else {
+		spin_lock(&bes2600_cdev.status_lock);
+		bes2600_cdev.wait_state = BES2600_BOOT_WAIT_NONE;
+		bes2600_cdev.bus_error = error;
+		if(bes2600_cdev.bus_error) {
+			bes2600_cdev.wifi_opened = false;
+			bes2600_cdev.bt_opened = false;
+			bes2600_cdev.bton_pending = false;
+			bes2600_cdev.bus_probe = BES2600_BUS_PROBE_NONE;
+		}
+		spin_unlock(&bes2600_cdev.status_lock);
+		bes2600_info(BES2600_DBG_CHARDEV, "wakup proc on wq of disconnect_done.\n");
+	}
+
+	wake_up(&bes2600_cdev.probe_done_wq);
+}
+
+struct sbus_priv * bes2600_chrdev_get_sbus_priv_data(void)
+{
+	return bes2600_cdev.sbus_priv;
+}
+
+int bes2600_chrdev_check_system_close(void)
+{
+	bool sys_closed = false;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	sys_closed = bes2600_chrdev_check_system_close_internal();
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return sys_closed;
+}
+
+int bes2600_chrdev_do_system_close(const struct sbus_ops *sbus_ops, struct sbus_priv *priv)
+{
+	int ret = 0;
+	long status = 0;
+
+	if(!sbus_ops || !priv) {
+		bes2600_warn(BES2600_DBG_CHARDEV, "abort power down device.\n");
+		return 0;
+	}
+
+	bes2600_dbg(BES2600_DBG_CHARDEV, "power down bes2600.\n");
+
+	/* trigger system to execute disconnect function */
+	ret = sbus_ops->power_switch(priv, 0);
+
+	/* wait disconnect event */
+	status = wait_event_timeout(bes2600_cdev.probe_done_wq, (bes2600_cdev.sbus_priv == NULL), HZ * 3);
+	WARN_ON(status <= 0);
+
+
+	return ret;
+}
+
+bool bes2600_chrdev_is_wifi_opened(void)
+{
+	bool wifi_opened = false;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	wifi_opened = bes2600_cdev.wifi_opened;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	if(bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_NO_SIGNAL)
+		return true;
+	else if(bes2600_cdev.fw_type == BES2600_FW_TYPE_BT)
+		return false;
+	else if(bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_SIGNAL)
+		return wifi_opened;
+
+	return false;
+}
+
+bool bes2600_chrdev_is_bt_opened(void)
+{
+	bool bt_opened = false;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	bt_opened = bes2600_cdev.bt_opened;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	if(bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_NO_SIGNAL)
+		return false;
+	else if(bes2600_cdev.fw_type == BES2600_FW_TYPE_BT)
+		return true;
+	else if(bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_SIGNAL)
+		return bt_opened;
+
+	return false;
+}
+
+void bes2600_chrdev_wakeup_bt(void)
+{
+	int ret = 0;
+
+	if(bes2600_cdev.bt_opened && bes2600_cdev.sbus_priv) {
+		bes2600_info(BES2600_DBG_PM, "wakeup bt in resume flow\n");
+		ret = bes2600_chrdev_switch_subsys(GPIO_WAKE_FLAG_BT_LP_ON, SUBSYSTEM_BT_LP, true);
+
+		bes2600_err_with_cond(ret, BES2600_DBG_PM, "Wakeup BT fail in resume\n");
+	}
+}
+
+int bes2600_chrdev_get_fw_type(void)
+{
+	return bes2600_cdev.fw_type;
+}
+
+bool bes2600_chrdev_is_signal_mode(void)
+{
+	return bes2600_cdev.sig_mode;
+}
+
+bool bes2600_chrdev_is_bus_error(void)
+{
+	bool error = false;
+
+	spin_lock(&bes2600_cdev.status_lock);
+	error = (bes2600_cdev.bus_error || bes2600_cdev.bus_probe != BES2600_BUS_PROBE_OK);
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	return error;
+}
+
+void bes2600_chrdev_update_signal_mode(void)
+{
+	if(bes2600_cdev.fw_type >= BES2600_FW_TYPE_MAX_NUM) {
+		bes2600_cdev.fw_type = BES2600_FW_TYPE_WIFI_SIGNAL;
+		bes2600_warn(BES2600_DBG_CHARDEV, "unexpected fw type, switch to wifi signal mode\n");
+	}
+
+	if (bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_SIGNAL) {
+		bes2600_cdev.sig_mode = true;
+	} else if ((bes2600_cdev.fw_type == BES2600_FW_TYPE_WIFI_NO_SIGNAL)
+		|| (bes2600_cdev.fw_type == BES2600_FW_TYPE_BT)) {
+		bes2600_cdev.sig_mode = false;
+	}
+}
+
+static void bes2600_chrdev_wifi_force_close_work(struct work_struct *work)
+{
+	char wifi_state[15];
+	char bt_state[15];
+	char fw_type[15];
+	char *env[] = { wifi_state, bt_state, fw_type, NULL };
+	int ret;
+
+	if(bes2600_chrdev_is_wifi_opened()) {
+		bes2600_info(BES2600_DBG_CHARDEV, "system exeception, force wifi down\n");
+
+		/* halt device if needed */
+		if(bes2600_cdev.halt_dev && bes2600_cdev.sbus_ops->halt_device) {
+			bes2600_cdev.sbus_ops->halt_device(bes2600_cdev.sbus_priv);
+		}
+
+		/* unregister wifi */
+		bes2600_switch_wifi(0);
+
+		/* power down device if wifi is only opened */
+		if(bes2600_chrdev_check_system_close()) {
+			bes2600_chrdev_do_system_close(bes2600_cdev.sbus_ops,
+						bes2600_cdev.sbus_priv);
+		}
+
+		/* notify userspace */
+		snprintf(wifi_state, sizeof(wifi_state), "WIFI_OPENED=%d", bes2600_cdev.wifi_opened);
+		snprintf(bt_state, sizeof(bt_state), "BT_OPENED=%d", bes2600_cdev.bt_opened);
+		snprintf(fw_type, sizeof(fw_type), "FW_TYPE=%d", bes2600_cdev.fw_type);
+		ret = kobject_uevent_env(&bes2600_cdev.device->kobj, KOBJ_CHANGE, env);
+		bes2600_err_with_cond(ret != 0, BES2600_DBG_CHARDEV, "bes2600 notify userspace failed\n");
+	}
+}
+
+void bes2600_chrdev_wifi_force_close(struct bes2600_common *hw_priv, bool halt_dev)
+{
+	if(hw_priv == NULL)
+		return;
+
+	if(bes2600_chrdev_is_wifi_opened() &&
+	   !work_pending(&bes2600_cdev.wifi_force_close_work)) {
+		spin_lock(&bes2600_cdev.status_lock);
+		bes2600_cdev.bus_error = true;
+		bes2600_cdev.halt_dev = halt_dev;
+		spin_unlock(&bes2600_cdev.status_lock);
+
+		bes2600_tx_loop_set_enable(hw_priv);
+		schedule_work(&bes2600_cdev.wifi_force_close_work);
+	}
+}
+
+static void bes2600_probe_timeout_work(struct work_struct *work)
+{
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.bus_probe = BES2600_BUS_PROBE_TIMEOUT;
+	bes2600_cdev.wifi_opened = false;
+	bes2600_cdev.bt_opened = false;
+	bes2600_cdev.bton_pending = false;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	bes2600_info(BES2600_DBG_CHARDEV, "bus probe timeout\n");
+	wake_up(&bes2600_cdev.probe_done_wq);
+}
+
+void bes2600_chrdev_start_bus_probe(void)
+{
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.bus_probe = BES2600_BUS_PROBE_START;
+	spin_unlock(&bes2600_cdev.status_lock);
+
+	cancel_delayed_work_sync(&bes2600_cdev.probe_timeout_work);
+	schedule_delayed_work(&bes2600_cdev.probe_timeout_work, (HZ * 8) / 10);
+}
+
+void bes2600_chrdev_bus_probe_notify(void)
+{
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.bus_probe = BES2600_BUS_PROBE_OK;
+	spin_unlock(&bes2600_cdev.status_lock);
+	cancel_delayed_work_sync(&bes2600_cdev.probe_timeout_work);
+
+	wake_up(&bes2600_cdev.probe_done_wq);
+}
+
+void bes2600_chrdev_wifi_update_wakeup_reason(u32 val)
+{
+	spin_lock(&bes2600_cdev.status_lock);
+	bes2600_cdev.wakeup_state = val;
+	spin_unlock(&bes2600_cdev.status_lock);
+}
+
+int bes2600_chrdev_init(struct sbus_ops *ops)
+{
+	int ret = 0;
+
+	/* allocate devide id */
+	ret = alloc_chrdev_region(&bes2600_cdev.dev_id, 0, 1, "bes2600_chrdev");
+	if(ret < 0){
+		bes2600_err(BES2600_DBG_CHARDEV, "bes2600 alloc device id fail\n");
+		ret =  -EFAULT;
+		goto fail;
+	}
+
+	/* extract major and minor device id */
+	bes2600_cdev.major = MAJOR(bes2600_cdev.dev_id);
+	bes2600_cdev.minor = MINOR(bes2600_cdev.dev_id);
+
+	/* add char device and bind operation function */
+	bes2600_cdev.cdev.owner = THIS_MODULE;
+	cdev_init(&bes2600_cdev.cdev, &bes2600_chardev_fops);
+	ret = cdev_add(&bes2600_cdev.cdev, bes2600_cdev.dev_id, 1);
+	if(ret < 0){
+		bes2600_err(BES2600_DBG_CHARDEV, "bes2600 char device add fail\n");
+		ret =  -EFAULT;
+		goto fail1;
+	}
+
+	/* create class for creating device node */
+	bes2600_cdev.class = class_create(THIS_MODULE, "bes2600_chrdev");
+	if (IS_ERR(bes2600_cdev.class)){
+		bes2600_err(BES2600_DBG_CHARDEV, "bes2600 char device add fail\n");
+		ret = -EFAULT;
+		goto fail2;
+	}
+
+	/* get char device pointer */
+	bes2600_cdev.device = device_create(bes2600_cdev.class, NULL, bes2600_cdev.dev_id, NULL, "bes2600");
+	if(IS_ERR(bes2600_cdev.device)){
+		bes2600_err(BES2600_DBG_CHARDEV, "bes2600 char device create fail\n");
+		ret =  -EFAULT;
+		goto fail3;
+	}
+
+	/* initialise global variable */
+	atomic_set(&bes2600_cdev.num_proc, 0);
+	init_waitqueue_head(&bes2600_cdev.open_wq);
+	spin_lock_init(&bes2600_cdev.status_lock);
+	init_waitqueue_head(&bes2600_cdev.probe_done_wq);
+	INIT_WORK(&bes2600_cdev.wifi_force_close_work, bes2600_chrdev_wifi_force_close_work);
+	INIT_DELAYED_WORK(&bes2600_cdev.probe_timeout_work, bes2600_probe_timeout_work);
+	bes2600_cdev.wifi_opened = true;
+	bes2600_cdev.bt_opened = false;
+	bes2600_cdev.bton_pending = false;
+	bes2600_cdev.dpd_calied = false;
+	bes2600_cdev.wait_state = BES2600_BOOT_WAIT_NONE;
+	bes2600_cdev.sbus_ops = ops;
+	bes2600_cdev.bus_error = false;
+	bes2600_cdev.halt_dev = false;
+	bes2600_cdev.read_flag = BES_CDEV_READ_NUM_MAX;
+	bes2600_info(BES2600_DBG_CHARDEV, "%s done\n", __func__);
+
+	return 0;
+
+fail3:
+	class_destroy(bes2600_cdev.class);
+fail2:
+	cdev_del(&bes2600_cdev.cdev);
+fail1:
+	unregister_chrdev_region(bes2600_cdev.dev_id, 1);
+fail:
+	return ret;
+}
+
+void bes2600_chrdev_free(void)
+{
+	bes2600_chrdev_free_dpd_data();
+	cdev_del(&bes2600_cdev.cdev);
+	unregister_chrdev_region(bes2600_cdev.dev_id, 1);
+	device_destroy(bes2600_cdev.class, bes2600_cdev.dev_id);
+	class_destroy(bes2600_cdev.class);
+	bes2600_info(BES2600_DBG_CHARDEV, "%s done\n", __func__);
+}
diff --git a/drivers/staging/bes2600/bes_chardev.h b/drivers/staging/bes2600/bes_chardev.h
new file mode 100755
index 000000000000..8c7257c087a4
--- /dev/null
+++ b/drivers/staging/bes2600/bes_chardev.h
@@ -0,0 +1,70 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __BES_CHARDEV_H__
+#define __BES_CHARDEV_H__
+
+#define BES2600_FW_TYPE_WIFI_SIGNAL	0
+#define BES2600_FW_TYPE_WIFI_NO_SIGNAL	1
+#define BES2600_FW_TYPE_BT		2
+#define BES2600_FW_TYPE_MAX_NUM     3
+
+#define DPD_BIN_SIZE            0x3AF8
+#define DPD_BIN_FILE_SIZE       0x4000
+
+enum pend_read_op {
+	BES_CDEV_READ_WAKEUP_STATE = 0,
+	/* add new here */
+
+	BES_CDEV_READ_NUM_MAX,
+};
+
+/* dpd management */
+u8* bes2600_chrdev_get_dpd_buffer(u32 size);
+int bes2600_chrdev_update_dpd_data(void);
+const u8* bes2600_chrdev_get_dpd_data(u32 *len);
+void bes2600_chrdev_free_dpd_data(void);
+
+/* get/set subs_priv instance from/to bes_chrdev module */
+void bes2600_chrdev_set_sbus_priv_data(struct sbus_priv *priv, bool error);
+struct sbus_priv *bes2600_chrdev_get_sbus_priv_data(void);
+
+/* used to control device power down */
+int bes2600_chrdev_check_system_close(void);
+int bes2600_chrdev_do_system_close(const struct sbus_ops *sbus_ops, struct sbus_priv *priv);
+void bes2600_chrdev_wakeup_bt(void);
+void bes2600_chrdev_wifi_force_close(struct bes2600_common *hw_priv, bool halt_dev);
+
+/* get and set internal state */
+bool bes2600_chrdev_is_wifi_opened(void);
+bool bes2600_chrdev_is_bt_opened(void);
+int bes2600_chrdev_get_fw_type(void);
+bool bes2600_chrdev_is_signal_mode(void);
+void bes2600_chrdev_update_signal_mode(void);
+bool bes2600_chrdev_is_bus_error(void);
+
+/* bus probe check */
+void bes2600_chrdev_start_bus_probe(void);
+void bes2600_chrdev_bus_probe_notify(void);
+
+/* set wifi wakeup state */
+void bes2600_chrdev_wifi_update_wakeup_reason(u32 val);
+
+/* init and deinit module */
+int bes2600_chrdev_init(struct sbus_ops *ops);
+void bes2600_chrdev_free(void);
+
+#ifdef BES2600_DUMP_FW_DPD_LOG
+void bes2600_free_dpd_log_buffer(void);
+u8* bes2600_alloc_dpd_log_buffer(u16 len);
+void bes2600_get_dpd_log(char **data, size_t *len);
+#endif
+
+#endif
\ No newline at end of file
diff --git a/drivers/staging/bes2600/bes_fw.c b/drivers/staging/bes2600/bes_fw.c
new file mode 100755
index 000000000000..d3e1718eb729
--- /dev/null
+++ b/drivers/staging/bes2600/bes_fw.c
@@ -0,0 +1,976 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "bes_fw_common.h"
+#include "bes2600.h"
+#include "hwio.h"
+#include "sbus.h"
+#include "bes2600_driver_mode.h"
+#include "bes_chardev.h"
+#include <linux/string.h>
+#include "bes2600_factory.h"
+
+struct platform_fw_t {
+	struct delayed_work work_data;
+	struct sdio_func *func;
+	struct completion completion_data;
+	const struct sbus_ops *sbus_ops;
+	struct sbus_priv *sbus_priv;
+};
+
+static void bes_fw_irq_handler(void *priv)
+{
+	struct platform_fw_t *fw_data = (struct platform_fw_t *)priv;
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s\n", __func__);
+	complete(&fw_data->completion_data);
+}
+
+//#define BES_SLAVE_RX_DOUBLE_CHECK
+static int bes_slave_rx_ready(struct platform_fw_t *fw_data, u8* buf_cnt,
+					u16* buf_len, int timeout)
+{
+	int ret;
+	unsigned long start = jiffies;
+
+	do {
+		ret = bes2600_reg_read(0x108, buf_cnt, 1);
+		if (!(ret || buf_cnt)) {
+			mdelay(50);
+			continue;
+		} else if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "%s,%d err=%d\n", __func__, __LINE__, ret);
+		} else {
+			ret = bes2600_reg_read_16(0x109, buf_len);
+		}
+		break;
+	} while(time_before(jiffies, start + timeout));
+
+	return ret;
+}
+
+static int bes_slave_tx_ready(struct platform_fw_t *fw_data, u16 *tx_len, int timeout)
+{
+	int ret, retry = 0;
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s now=%lu\n", __func__, jiffies);
+
+	msleep(2);
+
+	ret = wait_for_completion_interruptible_timeout(&fw_data->completion_data, timeout);
+	if (ret > 0) {
+		do {
+			ret = bes2600_reg_read_16(0, tx_len);
+			if (!ret && (*tx_len))
+				break;
+			else
+				bes2600_err(BES2600_DBG_DOWNLOAD,"%s,%d ret=%d tx_len=%x retry=%d\n",
+						__func__, __LINE__, ret, *tx_len, retry);
+			retry++;
+		} while(retry <= 5);
+		reinit_completion(&fw_data->completion_data);
+
+	} else if(!ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "%s now=%lu delta=%d\n", __func__, jiffies, timeout);
+		ret = -110;
+	} else {
+		// ret = -ERESTARTSYS, to be continued;
+	}
+
+	return ret;
+}
+
+int bes_host_slave_sync(struct bes2600_common *hw_priv)
+{
+	u8 val;
+	int ret;
+
+	ret = bes2600_reg_read(BES_HOST_INT_REG_ID, &val, 1);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "%s,%d err=%d\n", __func__, __LINE__, ret);
+		return ret;
+	}
+
+	val |= BES_HOST_INT;
+	ret = bes2600_reg_write(BES_HOST_INT_REG_ID, &val, 1);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "%s,%d err=%d\n", __func__, __LINE__, ret);
+	}
+	return ret;
+}
+
+//#define DATA_DUMP_OBSERVE
+
+static int bes_firmware_download_write_reg(struct platform_fw_t *fw_data, u32 addr, u32 val)
+{
+	u8 frame_num = 0;
+	u8 buf_cnt = 0;
+	u16 tx_size = 0;
+	u16 rx_size = 0;
+	u32 length = 0;
+	u8 *short_buf;
+	int ret;
+
+	struct fw_msg_hdr_t header;
+	struct fw_info_t fw_info;
+	struct download_fw_t download_addr;
+
+	fw_info.addr = addr;
+	fw_info.len = 4;
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave rx buf cnt:%d,buf len max:%d\n", buf_cnt, tx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait bes sdio slave rx ready tiemout:%d\n", ret);
+		return ret;
+	}
+
+	short_buf = kzalloc(512, GFP_KERNEL);
+	if (!short_buf)
+		return -ENOMEM;
+
+	header.type = FRAME_HEADER_DOWNLOAD_INFO;
+	header.seq = frame_num;
+	header.len = sizeof(struct fw_info_t);
+	frame_num++;
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&fw_info, sizeof(struct fw_info_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx download firmware info err:%d\n", ret);
+		goto err;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave tx ready %d bytes\n", rx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process failed:%d\n", ret);
+		goto err;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rx download firmware info rsp err:%d\n", ret);
+		goto err;
+	}
+
+	header.type = FRAME_HEADER_DOWNLOAD_DATA;
+	header.seq = frame_num;
+	header.len = 8;
+	frame_num++;
+
+	download_addr.addr = fw_info.addr;
+
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), &download_addr.addr, sizeof(struct download_fw_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t), &val, 4);
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx download fw data err:%d\n", ret);
+		goto err;
+	}
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process download fw data err:%d\n", ret);
+		goto err;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rx tx download fw data rsp err:%d\n", ret);
+		goto err;
+	}
+
+err:
+	kfree(short_buf);
+	return ret;
+}
+
+static int bes_firmware_download_write_mem(struct platform_fw_t *fw_data, const u32 addr, const u8 *data, const  u32 len)
+{
+	u8 frame_num = 0;
+	u8 last_frame_num = 0;
+	u8 buf_cnt = 0;
+
+	u16 tx_size = 0;
+	u16 rx_size = 0;
+
+	u32 length = 0;
+	u32 code_length = len;
+	u32 retry_cnt = 0;
+	int ret;
+
+	const u8 *data_p;
+	u8 *short_buf, *long_buf;
+
+	struct fw_msg_hdr_t header;
+	struct fw_info_t fw_info;
+	struct download_fw_t download_addr;
+	struct fw_crc_t crc32_t;
+
+retry:
+	fw_info.addr = addr;
+	fw_info.len = len;
+	data_p = data;
+
+	crc32_t.crc32 = 0;
+	crc32_t.crc32 ^= 0xffffffffL;
+	crc32_t.crc32 = crc32_le(crc32_t.crc32, (u8 *)data, len);
+	crc32_t.crc32 ^= 0xffffffffL;
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave rx buf cnt:%d,buf len max:%d\n", buf_cnt, tx_size);
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "wait bes sdio slave rx ready tiemout:%d\n", ret);
+		return ret;
+	}
+
+	header.type = FRAME_HEADER_DOWNLOAD_INFO;
+	header.seq = frame_num;
+	header.len = sizeof(struct fw_info_t);
+	last_frame_num = frame_num;
+	frame_num++;
+
+	short_buf = kzalloc(512, GFP_KERNEL);
+	if (!short_buf)
+		return -ENOMEM;
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&fw_info, sizeof(struct fw_info_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	if (tx_size > length) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s", "tx download firmware info\n");
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "%s:%d bes slave has no enough buffer%d/%d\n", __func__, __LINE__, tx_size, length);
+		goto err1;
+	}
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx download firmware info err:%d\n", ret);
+		goto err1;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave tx ready %d bytes\n", rx_size);
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "wait slave process failed:%d\n", ret);
+		goto err1;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rx download firmware info rsp err:%d\n", ret);
+		goto err1;
+	}
+
+	//check device rx status
+	ret = bes_frame_rsp_check(short_buf, last_frame_num);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rsp download firmware info err:%d\n", ret);
+		goto err1;
+	}
+
+	//download firmware
+	long_buf = kmalloc(1024 * 32, GFP_KERNEL);
+	if (!long_buf) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "%s:%d fw failed to allocate memory\n",__func__, __LINE__);
+		ret = -ENOMEM;
+		goto err1;
+	}
+	download_addr.addr = fw_info.addr;
+
+	while (code_length) {
+
+		ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+		if (ret) {
+			goto err2;
+		} else {
+			bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes salve rx ready %d bytes\n", tx_size);
+		}
+
+
+		if ((tx_size < 4) || (tx_size % 4)) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "%s:%d tx size=%d\n", __func__, __LINE__, tx_size);
+			ret = -203;
+			goto err2;
+		}
+
+		if ((code_length + sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t)) < tx_size) {
+			length = code_length + sizeof(struct download_fw_t);
+		} else {
+			length = tx_size - sizeof(struct fw_msg_hdr_t);
+		}
+
+		header.type = FRAME_HEADER_DOWNLOAD_DATA;
+		header.seq = frame_num;
+		header.len = length;
+		last_frame_num = frame_num;
+		frame_num++;
+
+		memcpy(long_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+		memcpy(long_buf + sizeof(struct fw_msg_hdr_t), &download_addr.addr, sizeof(struct download_fw_t));
+		length -= sizeof(struct download_fw_t);//real data length
+		memcpy(long_buf + sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t), data_p, length);
+
+		length += (sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t));
+
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "tx_download_firmware_data:%x %d\n", download_addr.addr, length);
+
+		ret = bes2600_data_write(long_buf, length > 512 ? length : 512);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "tx download fw data err:%d\n", ret);
+			goto err2;
+		}
+		length -= (sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t));
+
+		ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+		if (!ret) {
+			bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+		} else {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process download fw data err:%d\n", ret);
+			goto err2;
+		}
+
+		ret = bes2600_data_read(short_buf, rx_size);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "rx tx download fw data rsp err:%d\n", ret);
+			goto err2;
+		}
+
+		//check device rx status
+		ret = bes_frame_rsp_check(short_buf, last_frame_num);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "rsp tx download fw err:%d\n", ret);
+			goto err2;
+		}
+
+		code_length -= length;
+		data_p += length;
+		download_addr.addr += length;
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "already tx fw size:%x/%x\n", download_addr.addr - fw_info.addr, fw_info.len);
+	}
+
+	//Notify Device:The firmware download is complete
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (ret) {
+		goto err2;
+	} else {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes salve rx ready %d bytes\n", tx_size);
+	}
+
+	header.type = FRAME_HEADER_DOWNLOAD_END;
+	header.seq = frame_num;
+	header.len = sizeof(struct fw_crc_t);
+	last_frame_num = frame_num;
+	frame_num++;
+
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&crc32_t.crc32, sizeof(struct fw_crc_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s", "tx download firmware complete command\n");
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx downlod firmware complete command err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process download fw data err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "receive download firmware complete cmd rsp err:%d\n", ret);
+		goto err2;
+	}
+
+	//check device rx status
+	ret = bes_frame_rsp_check(short_buf, last_frame_num);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rsp download firmware complete err:%d\n", ret);
+		goto err2;
+	}
+err2:
+	kfree(long_buf);
+err1:
+	kfree(short_buf);
+
+	if (ret && retry_cnt < 3) {
+		retry_cnt++;
+		goto retry;
+	}
+	return ret;
+}
+
+int bes_firmware_download(struct platform_fw_t *fw_data, const char *fw_name, bool auto_run)
+{
+	u8 frame_num = 0;
+	u8 last_frame_num = 0;
+	u8 buf_cnt = 0;
+
+	u16 tx_size = 0;
+	u16 rx_size = 0;
+
+	u32 length = 0;
+	u32 code_length = 0;
+	u32 retry_cnt = 0;
+	int ret;
+	const u8 *fw_ver_ptr;
+	const u8 *data_p;
+	u8 *short_buf, *long_buf;
+
+#ifdef CONFIG_FW_LOADER
+	const struct firmware *fw_bin;
+#else
+	struct my_firmware_t {
+		u8 *data;
+		size_t size;
+	} my_fw, *fw_bin;
+	struct file *my_fwp;
+#endif
+
+	struct fw_msg_hdr_t header;
+	struct fw_info_t fw_info;
+	struct download_fw_t download_addr;
+	struct fw_crc_t crc32_t;
+	struct run_fw_t run_addr;
+
+retry:
+#ifdef CONFIG_FW_LOADER
+	ret = request_firmware(&fw_bin, fw_name, NULL);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "request firmware err:%d\n", ret);
+		return ret;
+	}
+#else
+	my_fwp = filp_open(fw_name, O_RDONLY, 0);
+	if (IS_ERR(my_fwp)) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "firmware path invalid:%s,%ld.\n", fw_name, PTR_ERR(my_fwp));
+		return PTR_ERR(my_fwp);
+	}
+	fw_bin = &my_fw;
+	fw_bin->size = my_fwp->f_inode->i_size;
+	if (fw_bin->size <= 0) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wrong firmware size:%lu.\n", (long unsigned)fw_bin->size);
+		ret = -ENOENT;
+		goto close_fp;
+	}
+	fw_bin->data = kmalloc(fw_bin->size, GFP_KERNEL);
+	if (!fw_bin->data) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "kmalloc firmware buffer failed.\n");
+		ret = -ENOMEM;
+		goto close_fp;
+	}
+	ret = kernel_read(my_fwp, fw_bin->data, fw_bin->size, &my_fwp->f_pos);
+	if (ret != fw_bin->size) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "read firmware size error:%d,%lu.\n", ret, (long unsigned)fw_bin->size);
+		ret = -EIO;
+		goto free_mem;
+	}
+#endif
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s fw.size=%ld\n", __func__, (long)fw_bin->size);
+
+	bes_parse_fw_info(fw_bin->data, fw_bin->size, &fw_info.addr, &crc32_t.crc32);
+
+	fw_ver_ptr = bes2600_get_firmware_version_info(fw_bin->data, fw_bin->size);
+	if(fw_ver_ptr == NULL)
+		bes2600_err(BES2600_DBG_DOWNLOAD, "------Firmware version get failed\n");
+	else
+		bes2600_info(BES2600_DBG_DOWNLOAD, "------Firmware: %s version :%s\n", fw_name ,fw_ver_ptr);
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "------load addr  :0x%08X\n", fw_info.addr);
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "------data crc   :0x%08X\n", crc32_t.crc32);
+
+	code_length = fw_bin->size - CODE_DATA_USELESS_SIZE;
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "------code size  :%d\n", code_length);
+
+	fw_info.len = code_length;
+	data_p = fw_bin->data;
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave rx buf cnt:%d,buf len max:%d\n", buf_cnt, tx_size);
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "wait bes sdio slave rx ready tiemout:%d\n", ret);
+		return ret;
+	}
+
+	header.type = FRAME_HEADER_DOWNLOAD_INFO;
+	header.seq = frame_num;
+	header.len = sizeof(struct fw_info_t);
+	last_frame_num = frame_num;
+	frame_num++;
+
+	short_buf = kzalloc(512, GFP_KERNEL);
+	if (!short_buf)
+		return -ENOMEM;
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&fw_info, sizeof(struct fw_info_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	//mdelay(5000);
+	bes2600_dbg_dump(BES2600_DBG_DOWNLOAD, "Fw Info:", short_buf, length);
+
+	if (tx_size > length) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s", "tx download firmware info\n");
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "%s:%d bes slave has no enough buffer%d/%d\n", __func__, __LINE__, tx_size, length);
+		goto err1;
+	}
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx download firmware info err:%d\n", ret);
+		goto err1;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "sdio slave tx ready %d bytes\n", rx_size);
+	} else {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "wait slave process failed:%d\n", ret);
+		goto err1;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rx download firmware info rsp err:%d\n", ret);
+		goto err1;
+	}
+
+	//check device rx status
+	ret = bes_frame_rsp_check(short_buf, last_frame_num);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rsp download firmware info err:%d\n", ret);
+		goto err1;
+	}
+
+	//download firmware
+	long_buf = kmalloc(1024 * 32, GFP_KERNEL);
+	if (!long_buf) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "%s:%d fw failed to allocate memory\n",__func__, __LINE__);
+		ret = -ENOMEM;
+		goto err1;
+	}
+	download_addr.addr = fw_info.addr;
+
+	while (code_length) {
+		ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+		if (ret) {
+			goto err2;
+		} else {
+			bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes salve rx ready %d bytes\n", tx_size);
+		}
+
+		if ((tx_size < 4) || (tx_size % 4)) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "%s:%d tx size=%d\n", __func__, __LINE__, tx_size);
+			ret = -203;
+			goto err2;
+		}
+
+		if ((code_length + sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t)) < tx_size) {
+			length = code_length + sizeof(struct download_fw_t);
+		} else {
+			length = tx_size - sizeof(struct fw_msg_hdr_t);
+		}
+
+		header.type = FRAME_HEADER_DOWNLOAD_DATA;
+		header.seq = frame_num;
+		header.len = length;
+		last_frame_num = frame_num;
+		frame_num++;
+
+		memcpy(long_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+		memcpy(long_buf + sizeof(struct fw_msg_hdr_t), &download_addr.addr, sizeof(struct download_fw_t));
+		length -= sizeof(struct download_fw_t);//real data length
+		memcpy(long_buf + sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t), data_p, length);
+
+		length += (sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t));
+
+		//mdelay(5000);
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "tx_download_firmware_data:%x %d\n", download_addr.addr, length);
+
+		ret = bes2600_data_write(long_buf, length > 512 ? length : 512);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "tx download fw data err:%d\n", ret);
+			goto err2;
+		}
+		length -= (sizeof(struct fw_msg_hdr_t) + sizeof(struct download_fw_t));
+
+		ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+		if (!ret) {
+			bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+		} else {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process download fw data err:%d\n", ret);
+			goto err2;
+		}
+
+		ret = bes2600_data_read(short_buf, rx_size);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "rx tx download fw data rsp err:%d\n", ret);
+			goto err2;
+		}
+
+		//check device rx status
+		ret = bes_frame_rsp_check(short_buf, last_frame_num);
+		if (ret) {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "rsp tx download fw err:%d\n", ret);
+			goto err2;
+		}
+
+		code_length -= length;
+		data_p += length;
+		download_addr.addr += length;
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "already tx fw size:%x/%x\n", download_addr.addr - fw_info.addr, fw_info.len);
+	}
+
+	//Notify Device:The firmware download is complete
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (ret) {
+		goto err2;
+	} else {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes salve rx ready %d bytes\n", tx_size);
+	}
+
+	header.type = FRAME_HEADER_DOWNLOAD_END;
+	header.seq = frame_num;
+	header.len = sizeof(struct fw_crc_t);
+	last_frame_num = frame_num;
+	frame_num++;
+
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&crc32_t.crc32, sizeof(struct fw_crc_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "%s", "tx download firmware complete command\n");
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx downlod firmware complete command err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process download fw data err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "receive download firmware complete cmd rsp err:%d\n", ret);
+		goto err2;
+	}
+
+	//check device rx status
+	ret = bes_frame_rsp_check(short_buf, last_frame_num);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rsp download firmware complete err:%d\n", ret);
+		goto err2;
+	}
+
+	if (auto_run == false) {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "partial firmware(%s) is downloaded successfully\n", fw_name);
+		goto err2;
+	}
+
+	ret = bes_slave_rx_ready(fw_data, &buf_cnt, &tx_size, HZ);
+	if (ret) {
+		goto err2;
+	} else {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes salve rx ready %d bytes\n", tx_size);
+	}
+
+	//Notify Device:Run firmware
+	run_addr.addr = fw_info.addr;
+
+	header.type = FRAME_HEADER_RUN_CODE;
+	header.seq = frame_num;
+	header.len = sizeof(struct run_fw_t);
+	last_frame_num = frame_num;
+	frame_num++;
+
+	memcpy(short_buf, (u8 *)&header, sizeof(struct fw_msg_hdr_t));
+	memcpy(short_buf + sizeof(struct fw_msg_hdr_t), (u8 *)&run_addr.addr, sizeof(struct run_fw_t));
+	length = BES_FW_MSG_TOTAL_LEN(header);
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "tx run firmware command:0x%X\n", run_addr.addr);
+
+	length = length > 512 ? length : 512;
+	ret = bes2600_data_write(short_buf, length);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "tx run firmware command err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes_slave_tx_ready(fw_data, &rx_size, HZ);
+	if (!ret) {
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes_slave ready tx %d bytes\n", rx_size);
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait slave process run fw cmd err:%d\n", ret);
+		goto err2;
+	}
+
+	ret = bes2600_data_read(short_buf, rx_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rx run firmware command err:%d\n", ret);
+		goto err2;
+	}
+
+	//check device rx status
+	ret = bes_frame_rsp_check(short_buf, last_frame_num);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "rsp run firmware command err:%d\n", ret);
+		goto err2;
+	}
+
+	bes2600_info(BES2600_DBG_DOWNLOAD, "%s", "firmware is downloaded successfully and is already running\n");
+	msleep(500);
+
+err2:
+	kfree(long_buf);
+err1:
+	kfree(short_buf);
+#ifdef CONFIG_FW_LOADER
+	release_firmware(fw_bin);
+#else
+free_mem:
+	kfree(fw_bin->data);
+close_fp:
+	filp_close(my_fwp, NULL);
+#endif
+	if (ret && retry_cnt < 3) {
+		retry_cnt++;
+		goto retry;
+	}
+	return ret;
+}
+
+static int bes_read_dpd_data(struct platform_fw_t *fw_data)
+{
+	u16 dpd_size = 0;
+	int ret = 0;
+	u8 *dpd_buf = NULL;
+	u8 mcu_status = 0;
+	unsigned long wait_timeout;
+
+	/* wait for device ready */
+	wait_timeout = jiffies + 15 * HZ;
+	do {
+		msleep(100);
+		ret = bes2600_reg_read(BES_SLAVE_STATUS_REG_ID, &mcu_status, 1);
+	} while(((ret == 0) || (ret == -84)) &&
+	        !(mcu_status & BES_SLAVE_STATUS_DPD_READY) &&
+		time_before(jiffies, wait_timeout));
+
+	/* check if read dpd error */
+	if(ret < 0 || time_after(jiffies, wait_timeout)) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait dpd data ready failed:%d\n", ret);
+		return -1;
+	}
+
+	/* wait dpd read ready */
+	ret = bes_slave_tx_ready(fw_data, &dpd_size, HZ);
+	if (ret)  {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "wait dpd data failed:%d\n", ret);
+		return -1;
+	}
+
+	/* dpd size check */
+	if (dpd_size != DPD_BIN_SIZE) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "get dpd data size err:%u\n", dpd_size);
+		return -1;
+	}
+
+	/* read dpd data */
+	dpd_buf = bes2600_chrdev_get_dpd_buffer(DPD_BIN_FILE_SIZE);
+	if(!dpd_buf) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "allocate dpd buffer failed.\n");
+		return -1;
+	}
+
+	ret = bes2600_data_read(dpd_buf, dpd_size);
+	bes2600_info(BES2600_DBG_DOWNLOAD, "read dpd data size:%d\n", dpd_size);
+	if (ret) {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "read dpd data failed:%d\n", ret);
+		bes2600_chrdev_free_dpd_data();
+		return -1;
+	}
+
+	/* update dpd data */
+	ret = bes2600_chrdev_update_dpd_data();
+
+	return ret;
+}
+
+static int bes2600_load_wifi_firmware(struct platform_fw_t *fw_data)
+{
+	int ret = 0;
+	const char *fw_name_tbl[3];
+	int fw_type = bes2600_chrdev_get_fw_type();
+
+	fw_name_tbl[0] = BES2600_LOAD_FW_NAME;
+	fw_name_tbl[1] = BES2600_LOAD_NOSIGNAL_FW_NAME;
+	fw_name_tbl[2] = BES2600_LOAD_BTRF_FW_NAME;
+
+	bes2600_info(BES2600_DBG_DOWNLOAD, "bes2600 download cali and wifi signal firmware.\n");
+	ret = bes_firmware_download(fw_data, BES2600_LOAD_BOOT_NAME, true);
+	bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download dpd cali firmware failed\n");
+
+	if (!ret) {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "bes2600 read dpd cali data.\n");
+		ret = bes_read_dpd_data(fw_data);
+		bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "read dpd data failed.\n");
+	}
+
+	/* for wifi non-signal mode, download second firmware directly */
+	if (!ret && bes2600_chrdev_check_system_close()) {
+		bes2600_info(BES2600_DBG_DOWNLOAD, "bes2600 device power down.\n");
+		ret = bes2600_chrdev_do_system_close(fw_data->sbus_ops, fw_data->sbus_priv);
+		bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "device down fail.\n");
+	} else if (!ret) {
+		ret = bes_firmware_download(fw_data, fw_name_tbl[fw_type], true);
+		bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download normal firmware failed.\n");
+	}
+
+	return ret;
+}
+
+static int bes2600_load_wifi_firmware_with_dpd(struct platform_fw_t *fw_data)
+{
+	int ret = 0;
+	u32 dpd_data_len = 0;
+	const u8 *dpd_data = NULL;
+	const char *fw_name_tbl[3];
+	int fw_type = bes2600_chrdev_get_fw_type();
+
+	fw_name_tbl[0] = BES2600_LOAD_FW_NAME;
+	fw_name_tbl[1] = BES2600_LOAD_NOSIGNAL_FW_NAME;
+	fw_name_tbl[2] = BES2600_LOAD_BTRF_FW_NAME;
+
+	dpd_data = bes2600_chrdev_get_dpd_data(&dpd_data_len);
+	BUG_ON(!dpd_data);
+
+	bes2600_info(BES2600_DBG_DOWNLOAD, "bes2600 download firmware with dpd.\n");
+	ret = bes_firmware_download_write_mem(fw_data, BES2600_DPD_ADDR, dpd_data, dpd_data_len);
+	bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download dpd data failed.\n");
+	if (!ret) {
+		ret = bes_firmware_download(fw_data, fw_name_tbl[fw_type], true);
+		bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download firmware failed after dpd download.\n");
+	}
+
+	return ret;
+}
+
+static int bes2600_load_bt_firmware(struct platform_fw_t *fw_data)
+{
+	int ret = 0;
+
+	/* for bt mode, don't need to download dpd cali firmware*/
+	bes2600_info(BES2600_DBG_DOWNLOAD, "download bt test firmware.\n");
+	ret = bes_firmware_download(fw_data, BES2600_LOAD_BTRF_FW_NAME, true);
+	bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download normal firmware failed.\n");
+
+	return ret;
+
+}
+
+int bes2600_load_firmware_sdio(struct sbus_ops *ops, struct sbus_priv *priv)
+{
+	int ret = 0;
+	struct platform_fw_t *temp_fw_data;
+	u32 dpd_data_len = 0;
+	const u8 *dpd_data = NULL;
+	int fw_type = bes2600_chrdev_get_fw_type();
+	u8 *factory_data = NULL;
+	u8 *file_buffer = NULL;
+	u32 factory_data_len = 0;
+
+	temp_fw_data = kzalloc(sizeof(struct platform_fw_t), GFP_KERNEL);
+	if (!temp_fw_data)
+		return -ENOMEM;
+
+	init_completion(&temp_fw_data->completion_data);
+	temp_fw_data->sbus_ops = ops;
+	temp_fw_data->sbus_priv = priv;
+
+	temp_fw_data->sbus_ops->irq_subscribe(temp_fw_data->sbus_priv,
+			(sbus_irq_handler)bes_fw_irq_handler, temp_fw_data);
+
+	bes_firmware_download_write_reg(temp_fw_data, 0x40100000, 0x802006);
+	bes_firmware_download_write_reg(temp_fw_data, 0x4008602C, 0x3E00C000);
+
+	if (!(file_buffer = bes2600_factory_get_file_buffer()))
+		return -ENOMEM;
+
+	bes2600_factory_lock();
+	if (!(factory_data = bes2600_get_factory_cali_data(file_buffer, &factory_data_len, FACTORY_PATH))) {
+		bes2600_warn(BES2600_DBG_DOWNLOAD, "factory cali data get failed.\n");
+	} else {
+		bes2600_factory_data_check(factory_data);
+		factory_little_endian_cvrt(factory_data);
+		ret = bes_firmware_download_write_mem(temp_fw_data, BES2600_FACTORY_ADDR, factory_data, factory_data_len);
+		bes2600_err_with_cond(ret, BES2600_DBG_DOWNLOAD, "download factory data failed.\n");
+	}
+
+	bes2600_factory_free_file_buffer(file_buffer);
+	bes2600_factory_unlock();
+
+	bes2600_info(BES2600_DBG_DOWNLOAD, "%s fw_type:%d.\n", __func__, fw_type);
+	if(fw_type == BES2600_FW_TYPE_BT) {
+		ret = bes2600_load_bt_firmware(temp_fw_data);
+	} else {
+		dpd_data = bes2600_chrdev_get_dpd_data(&dpd_data_len);
+		if(dpd_data) {
+			ret = bes2600_load_wifi_firmware_with_dpd(temp_fw_data);
+		} else {
+			ret = bes2600_load_wifi_firmware(temp_fw_data);
+		}
+	}
+
+
+	/* don't register net device when wifi is closed */
+	if(!ret && !bes2600_chrdev_is_wifi_opened()) {
+		ret = 1;
+	}
+
+
+	temp_fw_data->sbus_ops->irq_unsubscribe(temp_fw_data->sbus_priv);
+	kfree(temp_fw_data);
+
+	bes2600_info(BES2600_DBG_DOWNLOAD, "download finished ,wifi_state:%d result is %d\n", bes2600_chrdev_is_wifi_opened(), ret);
+
+	return ret;
+}
diff --git a/drivers/staging/bes2600/bes_fw_common.c b/drivers/staging/bes2600/bes_fw_common.c
new file mode 100755
index 000000000000..2520d73f419c
--- /dev/null
+++ b/drivers/staging/bes2600/bes_fw_common.c
@@ -0,0 +1,99 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "bes_fw_common.h"
+
+void bes_parse_fw_info(const u8 *data, u32 data_len, u32 *load_addr, u32 *crc32)
+{
+	u8 buffer[16];
+	struct exec_struct_t exec_struct;
+	u32 exec_addr_last4byte;
+	u32 crc_le = 0;
+	crc_le = crc32_le(0xffffffffL, (u8 *)data, data_len - CODE_DATA_USELESS_SIZE);
+	crc_le ^= 0xffffffffL;
+
+	//read entry,param,sp,exec_addr
+	memcpy((u8 *)buffer, (u8 *)data, sizeof(exec_struct));
+	exec_struct.entry       = ((struct exec_struct_t *)buffer)->entry;//PC
+	exec_struct.param       = ((struct exec_struct_t *)buffer)->param;
+	exec_struct.sp          = ((struct exec_struct_t *)buffer)->sp;
+	exec_struct.exec_addr   = ((struct exec_struct_t *)buffer)->exec_addr;//load addr
+
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "crc32                :0x%08X\n", crc_le);
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_struct.entry    :0x%08X\n", exec_struct.entry);
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_struct.param    :0x%08X\n", exec_struct.param);
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_struct.sp       :0x%08X\n", exec_struct.sp);
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_struct.exec_addr:0x%08X\n", exec_struct.exec_addr);
+
+	exec_addr_last4byte = (*((u32 *)(data + data_len - 4)));
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_addr_last4byte  :0x%08X\n", exec_addr_last4byte);
+	if ((!exec_struct.exec_addr) || (exec_struct.exec_addr != exec_addr_last4byte && exec_addr_last4byte)) {
+		exec_struct.exec_addr = exec_addr_last4byte;
+		bes2600_dbg(BES2600_DBG_DOWNLOAD, "exec_addr_last4byte covered exec_struct.exec_addr\n");
+	}
+	bes2600_dbg(BES2600_DBG_DOWNLOAD, "final exec_struct.exec_addr:0x%08X\n", exec_struct.exec_addr);
+
+	*load_addr = exec_struct.exec_addr;
+
+	*crc32 = crc_le;
+}
+
+int bes_frame_rsp_check(void *rsp, u8 frame_num)
+{
+	int ret = 0;
+	struct frame_struct_t *pframe = (struct frame_struct_t *)rsp;
+	if (pframe->type == FRAME_HEADER_REPLY) {
+		if (pframe->frame_num == frame_num) {
+			if (pframe->len == 4) {
+				if (pframe->payload == ERR_NONE) {
+					bes2600_dbg(BES2600_DBG_DOWNLOAD, "bes slave  download firmware is ready\n");
+				} else {
+					bes2600_err(BES2600_DBG_DOWNLOAD, "frame payload=0x%x\n", pframe->payload);
+					ret = -200;
+				}
+			} else {
+				bes2600_err(BES2600_DBG_DOWNLOAD, "payload len error:%u\n", pframe->len);
+				ret = -201;
+			}
+		} else {
+			bes2600_err(BES2600_DBG_DOWNLOAD, "frame num err. 0x%x != 0x%x. len:%u\n",
+				pframe->frame_num, frame_num, pframe->len);
+			ret = -202;
+		}
+	} else {
+		bes2600_err(BES2600_DBG_DOWNLOAD, "frame type err. type 0x%x num=0x%x(0x%x), len:%u\n",
+			pframe->type, pframe->frame_num, frame_num, pframe->len);
+		ret = -203;
+	}
+	return ret;
+}
+
+const u8* bes2600_get_firmware_version_info(const u8 *data, u32 count)
+{
+        int i = 0;
+        const u8 *tmp_ptr = NULL;
+        const char month[12][4] = {
+                "Jan", "Feb", "Mar", "Apr", "May", "Jun",
+                "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
+        };
+
+        if(!data || count < 4)
+                return NULL;
+
+        for(tmp_ptr = data + count - 3; tmp_ptr > data; tmp_ptr -= 1) {
+                for(i = 0; i < 12; i++) {
+                        if(memcmp(tmp_ptr, month[i], 3) == 0) {
+                                return tmp_ptr;
+                        }
+                }
+        }
+
+        return NULL;
+}
diff --git a/drivers/staging/bes2600/bes_fw_common.h b/drivers/staging/bes2600/bes_fw_common.h
new file mode 100755
index 000000000000..af93355d3150
--- /dev/null
+++ b/drivers/staging/bes2600/bes_fw_common.h
@@ -0,0 +1,101 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __BES_FW_COMMON_H__
+#define __BES_FW_COMMON_H__
+
+#include <linux/types.h>
+#include <linux/printk.h>
+#include <linux/string.h>
+#include <linux/crc32.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/mm.h>
+#include <linux/wait.h>
+#include <linux/completion.h>
+#include <linux/firmware.h>
+#include <linux/fs.h>
+#include <linux/version.h>
+#include "bes2600.h"
+
+/***** firmware macro *****/
+#define BUF_SIZE        49152
+#define RETRY_CNT_MAX   3
+#define TIMEOUT_TIME    20
+#define FRAME_HEADER_SIZE           0x04
+#define CODE_DATA_USELESS_SIZE      0x04
+/****frame header code****/
+#define FRAME_HEADER_REPLY          0xB0
+#define FRAME_HEADER_DOWNLOAD_INFO  0xB1
+#define FRAME_HEADER_DOWNLOAD_DATA  0xB2
+#define FRAME_HEADER_DOWNLOAD_END   0xB3
+#define FRAME_HEADER_RUN_CODE       0xB4
+
+/****frame length get****/
+#define BES_FW_MSG_TOTAL_LEN(msg)  (sizeof(struct fw_msg_hdr_t) + ((struct fw_msg_hdr_t )(msg)).len)
+
+/****frame length get****/
+#define BES2600_DPD_ADDR	0x2008C000
+#define BES2600_FACTORY_ADDR	0x2008B000
+
+/***** bes fw error code *****/
+enum ERR_CODE {
+	ERR_NONE = 0x00,
+	ERR_LEN = 0x01,
+};
+
+/***** data struct *****/
+struct frame_struct_t {
+    u8 type;
+    u8 frame_num;
+    u16 len;
+    u32 payload;
+};
+
+struct fw_msg_hdr_t {
+    u8 type;
+    u8 seq;
+    u16 len;
+};
+
+struct fw_msg_replay_t {
+    u32 replay;
+};
+
+struct fw_info_t {
+    u32 len;
+    u32 addr;
+};
+
+struct download_fw_t {
+    u32 addr;
+    u8 data[0];
+};
+
+struct fw_crc_t {
+    u32 crc32;
+};
+
+struct run_fw_t {
+    u32 addr;
+};
+
+struct exec_struct_t {
+	u32 entry;
+	u32 param;
+	u32 sp;
+	u32 exec_addr;
+};
+
+void bes_parse_fw_info(const u8 *data, u32 data_len, u32 *load_addr, u32 *crc32);
+int bes_frame_rsp_check(void *rsp, u8 frame_num);
+const u8* bes2600_get_firmware_version_info(const u8 *data, u32 count);
+
+#endif
\ No newline at end of file
diff --git a/drivers/staging/bes2600/bes_pwr.h b/drivers/staging/bes2600/bes_pwr.h
new file mode 100755
index 000000000000..a196339e8052
--- /dev/null
+++ b/drivers/staging/bes2600/bes_pwr.h
@@ -0,0 +1,138 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __BES_PWR_H__
+#define __BES_PWR_H__
+
+#include "bes2600.h"
+
+enum bes2600_pwr_event_type {
+        BES_PWR_LOCK_ON_SCAN = 1,
+        BES_PWR_LOCK_ON_JOIN,
+        BES_PWR_LOCK_ON_TX,
+        BES_PWR_LOCK_ON_RX,
+        BES_PWR_LOCK_ON_FLUSH,
+        BES_PWR_LOCK_ON_ROC,
+        BES_PWR_LOCK_ON_WSM_TX,
+        BES_PWR_LOCK_ON_WSM_OPER,
+        BES_PWR_LOCK_ON_BSS_LOST,
+        BES_PWR_LOCK_ON_GET_IP,
+        BES_PWR_LOCK_ON_PS_ACTIVE,
+        BES_PWR_LOCK_ON_LMAC_RSP,
+        BES_PWR_LOCK_ON_AP,
+        BES_PWR_LOCK_ON_TEST_CMD,
+        BES_PWR_LOCK_ON_MUL_REQ,
+        BES_PWR_LOCK_ON_ADV_SCAN,
+        BES_PWR_LOCK_ON_DISCON,
+        BES_PWR_LOCK_ON_QUEUE_GC,
+        BES_PWR_LOCK_ON_AP_LP_BAD,
+        /* add new lock event here */
+        BES_PWR_LOCK_ON_EVENT_MAX,
+};
+
+#define BES_PWR_IS_CONSTANT_EVENT(x)    ((x) & 0x80000000)
+#define BES_PWR_EVENT_SET_CONSTANT(x)   (x = (x | 0x80000000))
+#define BES_PWR_EVENT_NUMBER(x)         ((x) & 0x7fffffff)
+
+#define BES2600_POWER_DOWN_DELAY        50       // unit in millisecond
+#define BES2600_DELAY_EVENT_NUM         (BES_PWR_LOCK_ON_EVENT_MAX << 1)
+
+#define BES_PWR_EVENT_TX_TIMEOUT        1500       // unit in millisecond
+#define BES_PWR_EVENT_RX_TIMEOUT        100        // unit in millisecond
+
+struct bes2600_pwr_event_t
+{
+        struct list_head link;
+        unsigned long timeout;
+        unsigned long delay;
+        u8 idx;
+        enum bes2600_pwr_event_type event;
+};
+
+enum power_down_state
+{
+        POWER_DOWN_STATE_LOCKED = 0,
+        POWER_DOWN_STATE_LOCKING,
+        POWER_DOWN_STATE_UNLOCKING,
+        POWER_DOWN_STATE_UNLOCKED,
+};
+
+typedef void (*bes_pwr_enter_lp_cb)(struct bes2600_common *hw_priv);
+typedef void (*bes_pwr_exit_lp_cb)(struct bes2600_common *hw_priv);
+
+struct bes2600_pwr_enter_cb_item
+{
+        struct list_head link;
+        bes_pwr_enter_lp_cb cb;
+};
+
+struct bes2600_pwr_exit_cb_item
+{
+        struct list_head link;
+        bes_pwr_exit_lp_cb cb;
+};
+
+struct bes2600_pwr_t
+{
+        spinlock_t pwr_lock;
+        struct delayed_work power_down_work;
+        struct work_struct power_async_work;
+        struct work_struct power_mcu_down_work;
+        struct list_head async_timeout_list;
+        struct list_head pending_event_list;
+        struct list_head free_event_list;
+        enum power_down_state power_state;
+        struct task_struct *power_down_task;
+        struct task_struct *power_up_task;
+        struct task_struct *sys_suspend_task;
+        struct task_struct *sys_resume_task;
+        struct semaphore sync_lock;
+        bool pending_lock;
+        atomic_t dev_state;
+        struct mutex pwr_mutex;
+        struct bes2600_common *hw_priv;
+        struct completion pm_enter_cmpl;
+        struct mutex pwr_cb_mutex;
+        struct list_head enter_cb_list;
+        struct list_head exit_cb_list;
+        wait_queue_head_t dev_lp_wq;
+        bool ap_lp_bad;
+        struct bes2600_pwr_event_t pwr_events[BES2600_DELAY_EVENT_NUM];
+        atomic_t pm_set_in_process;
+};
+
+static inline void bes2600_pwr_init(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_exit(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_prepare(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_complete(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_start(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_stop(struct bes2600_common *hw_priv) { }
+static inline bool bes2600_pwr_constant_event_is_pending(struct bes2600_common *hw_priv, u32 event) { return false; }
+static inline int bes2600_pwr_set_busy_event(struct bes2600_common *hw_priv, u32 event) { return 0; }
+static inline int bes2600_pwr_set_busy_event_async(struct bes2600_common *hw_priv, u32 event) {return 0; }
+static inline int bes2600_pwr_set_busy_event_with_timeout(struct bes2600_common *hw_priv, u32 event, u32 timeout) { return 0; }
+static inline int bes2600_pwr_set_busy_event_with_timeout_async(struct bes2600_common *hw_priv, u32 event, u32 timeout) { return 0; }
+static inline int bes2600_pwr_clear_busy_event(struct bes2600_common *hw_priv, u32 event) { return 0; }
+static inline void bes2600_pwr_notify_ps_changed(struct bes2600_common *hw_priv, u8 psmode) { }
+static inline bool bes2600_pwr_device_is_idle(struct bes2600_common *hw_priv) { return false; }
+static inline void bes2600_pwr_register_en_lp_cb(struct bes2600_common *hw_priv, bes_pwr_enter_lp_cb cb) { }
+static inline void bes2600_pwr_unregister_en_lp_cb(struct bes2600_common *hw_priv, bes_pwr_enter_lp_cb cb) { }
+static inline void bes2600_pwr_register_exit_lp_cb(struct bes2600_common *hw_priv, bes_pwr_enter_lp_cb cb) { }
+static inline void bes2600_pwr_unregister_exit_lp_cb(struct bes2600_common *hw_priv, bes_pwr_enter_lp_cb cb) { }
+static inline void bes2600_pwr_suspend_start(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_suspend_end(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_resume_start(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_resume_end(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_mcu_sleep_directly(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_mark_ap_lp_bad(struct bes2600_common *hw_priv) { }
+static inline void bes2600_pwr_clear_ap_lp_bad_mark(struct bes2600_common *hw_priv) { }
+static inline int bes2600_pwr_busy_event_dump(struct bes2600_common *hw_priv, char *buffer, u32 buf_len) { return 0; }
+
+#endif
\ No newline at end of file
diff --git a/drivers/staging/bes2600/bh.c b/drivers/staging/bes2600/bh.c
new file mode 100755
index 000000000000..ba646e89a893
--- /dev/null
+++ b/drivers/staging/bes2600/bh.c
@@ -0,0 +1,787 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <net/mac80211.h>
+#include <linux/kthread.h>
+#include <uapi/linux/ip.h>
+#include <uapi/linux/tcp.h>
+#include <uapi/linux/udp.h>
+
+#include "bes2600.h"
+#include "bh.h"
+#include "hwio.h"
+#include "wsm.h"
+#include "sbus.h"
+#include "debug.h"
+#include "epta_coex.h"
+#include "bes_chardev.h"
+#include "txrx_opt.h"
+#include "sta.h"
+
+static int bes2600_bh(void *arg);
+
+extern void sdio_work_debug(struct sbus_priv *self);
+
+/* TODO: Verify these numbers with WSM specification. */
+#define DOWNLOAD_BLOCK_SIZE_WR	(0x1000 - 4)
+/* an SPI message cannot be bigger than (2"12-1)*2 bytes
+ * "*2" to cvt to bytes */
+#define MAX_SZ_RD_WR_BUFFERS	(DOWNLOAD_BLOCK_SIZE_WR*2)
+#define PIGGYBACK_CTRL_REG	(2)
+#define EFFECTIVE_BUF_SIZE	(MAX_SZ_RD_WR_BUFFERS - PIGGYBACK_CTRL_REG)
+
+/* Suspend state privates */
+enum bes2600_bh_pm_state {
+	BES2600_BH_RESUMED = 0,
+	BES2600_BH_SUSPEND,
+	BES2600_BH_SUSPENDED,
+	BES2600_BH_RESUME,
+};
+
+typedef int (*bes2600_wsm_handler)(struct bes2600_common *hw_priv,
+	u8 *data, size_t size);
+
+static void bes2600_bh_work(struct work_struct *work)
+{
+	struct bes2600_common *priv =
+	container_of(work, struct bes2600_common, bh_work);
+	bes2600_bh(priv);
+}
+
+int bes2600_register_bh(struct bes2600_common *hw_priv)
+{
+	int err = 0;
+	/* Realtime workqueue */
+	hw_priv->bh_workqueue = alloc_workqueue("bes2600_bh",
+				WQ_MEM_RECLAIM | WQ_HIGHPRI
+				| WQ_CPU_INTENSIVE, 1);
+
+	if (!hw_priv->bh_workqueue)
+		return -ENOMEM;
+
+	INIT_WORK(&hw_priv->bh_work, bes2600_bh_work);
+
+	bes2600_info(BES2600_DBG_BH, "[BH] register.\n");
+
+	coex_init_mode(hw_priv, 0);
+	atomic_set(&hw_priv->bh_rx, 0);
+	atomic_set(&hw_priv->bh_tx, 0);
+	atomic_set(&hw_priv->bh_term, 0);
+	atomic_set(&hw_priv->bh_suspend, BES2600_BH_RESUMED);
+	hw_priv->buf_id_tx = 0;
+	hw_priv->buf_id_rx = 0;
+	init_waitqueue_head(&hw_priv->bh_wq);
+	init_waitqueue_head(&hw_priv->bh_evt_wq);
+
+	err = !queue_work(hw_priv->bh_workqueue, &hw_priv->bh_work);
+	WARN_ON(err);
+	return err;
+}
+
+void bes2600_unregister_bh(struct bes2600_common *hw_priv)
+{
+	coex_deinit_mode(hw_priv);
+
+	atomic_add(1, &hw_priv->bh_term);
+	wake_up(&hw_priv->bh_wq);
+
+	flush_workqueue(hw_priv->bh_workqueue);
+
+	destroy_workqueue(hw_priv->bh_workqueue);
+	hw_priv->bh_workqueue = NULL;
+
+	bes2600_info(BES2600_DBG_BH, "[BH] unregistered.\n");
+}
+
+void bes2600_irq_handler(struct bes2600_common *hw_priv)
+{
+	bes2600_dbg(BES2600_DBG_BH, "[BH] irq.\n");
+	if(!hw_priv) {
+		bes2600_warn(BES2600_DBG_BH, "%s hw private data is null", __func__);
+		return;
+	}
+
+	if (hw_priv->bh_error) {
+		bes2600_err(BES2600_DBG_BH, "%s bh error", __func__);
+		return;
+	}
+
+	if (atomic_add_return(1, &hw_priv->bh_rx) == 1)
+		wake_up(&hw_priv->bh_wq);
+}
+EXPORT_SYMBOL(bes2600_irq_handler);
+
+void bes2600_bh_wakeup(struct bes2600_common *hw_priv)
+{
+	bes2600_dbg(BES2600_DBG_BH,  "[BH] wakeup.\n");
+	if (WARN_ON(hw_priv->bh_error))
+		return;
+
+	if (atomic_add_return(1, &hw_priv->bh_tx) == 1)
+		wake_up(&hw_priv->bh_wq);
+}
+EXPORT_SYMBOL(bes2600_bh_wakeup);
+
+int bes2600_bh_suspend(struct bes2600_common *hw_priv)
+{
+	bes2600_dbg(BES2600_DBG_BH, "[BH] suspend.\n");
+	if (hw_priv->bh_error) {
+		wiphy_warn(hw_priv->hw->wiphy, "BH error -- can't suspend\n");
+		return -EINVAL;
+	}
+
+	atomic_set(&hw_priv->bh_suspend, BES2600_BH_SUSPEND);
+	wake_up(&hw_priv->bh_wq);
+	return wait_event_timeout(hw_priv->bh_evt_wq, hw_priv->bh_error ||
+		(BES2600_BH_SUSPENDED == atomic_read(&hw_priv->bh_suspend)),
+		 1 * HZ) ? 0 : -ETIMEDOUT;
+}
+EXPORT_SYMBOL(bes2600_bh_suspend);
+
+int bes2600_bh_resume(struct bes2600_common *hw_priv)
+{
+	int ret;
+
+	bes2600_dbg(BES2600_DBG_BH, "[BH] resume.\n");
+	if (hw_priv->bh_error) {
+		wiphy_warn(hw_priv->hw->wiphy, "BH error -- can't resume\n");
+		return -EINVAL;
+	}
+
+	atomic_set(&hw_priv->bh_suspend, BES2600_BH_RESUME);
+	wake_up(&hw_priv->bh_wq);
+	ret = wait_event_timeout(hw_priv->bh_evt_wq, hw_priv->bh_error ||
+		(BES2600_BH_RESUMED == atomic_read(&hw_priv->bh_suspend)),
+		1 * HZ) ? 0 : -ETIMEDOUT;
+
+	return ret;
+}
+EXPORT_SYMBOL(bes2600_bh_resume);
+
+static inline void wsm_alloc_tx_buffer(struct bes2600_common *hw_priv)
+{
+	++hw_priv->hw_bufs_used;
+}
+
+int wsm_release_tx_buffer(struct bes2600_common *hw_priv, int count)
+{
+	int ret = 0;
+	int hw_bufs_used = hw_priv->hw_bufs_used;
+
+	hw_priv->hw_bufs_used -= count;
+
+	if (WARN_ON(hw_priv->hw_bufs_used < 0))
+		ret = -1;
+	/* Tx data patch stops when all but one hw buffers are used.
+	   So, re-start tx path in case we find hw_bufs_used equals
+	   numInputChBufs - 1.
+	 */
+	else if (hw_bufs_used >= (hw_priv->wsm_caps.numInpChBufs - 1))
+		ret = 1;
+	if (!hw_priv->hw_bufs_used) {
+		bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_LMAC_RSP);
+		wake_up(&hw_priv->bh_evt_wq);
+	}
+	return ret;
+}
+EXPORT_SYMBOL(wsm_release_tx_buffer);
+
+int wsm_release_vif_tx_buffer(struct bes2600_common *hw_priv, int if_id,
+				int count)
+{
+	int ret = 0;
+
+	hw_priv->hw_bufs_used_vif[if_id] -= count;
+
+	if (!hw_priv->hw_bufs_used_vif[if_id])
+		wake_up(&hw_priv->bh_evt_wq);
+
+	if (WARN_ON(hw_priv->hw_bufs_used_vif[if_id] < 0))
+		ret = -1;
+	return ret;
+}
+
+/* Must be called from BH thraed. */
+void bes2600_enable_powersave(struct bes2600_vif *priv,
+			     bool enable)
+{
+	bes2600_dbg(BES2600_DBG_BH, "[BH] Powerave is %s.\n",
+			enable ? "enabled" : "disabled");
+	priv->powersave_enabled = enable;
+}
+
+extern int bes2600_bh_read_ctrl_reg(struct bes2600_common *priv, u32 *ctrl_reg);
+
+static void bes2600_bh_parse_ipv4_data(struct iphdr *ip)
+{
+	u8 *tmp_ptr = (u8 *)ip;
+
+	bes2600_info(BES2600_DBG_BH, "IP Addr src:0x%08x dst:0x%08x\n", 
+		__be32_to_cpu(ip->saddr), __be32_to_cpu(ip->daddr));
+
+	if (ip->protocol == IPPROTO_TCP) {
+		struct tcphdr *tcp = (struct tcphdr *)(tmp_ptr + ip->ihl * 4);
+		bes2600_info(BES2600_DBG_BH, "TCP Port src:%d dst:%d\n",
+			__be16_to_cpu(tcp->source), __be16_to_cpu(tcp->dest));
+	} else if (ip->protocol == IPPROTO_UDP) {
+		struct udphdr *udp = (struct udphdr *)(tmp_ptr + ip->ihl * 4);
+		bes2600_info(BES2600_DBG_BH, "UDP Port src:%d dst:%d\n",
+			__be16_to_cpu(udp->source), __be16_to_cpu(udp->dest));
+	}
+}
+
+static void bes2600_bh_parse_data_pkt(struct bes2600_common *hw_priv, struct sk_buff *skb)
+{
+	struct wsm_hdr *wsm = (struct wsm_hdr *)skb->data;
+	u16 wsm_id = __le16_to_cpu(wsm->id) & 0xFFF;
+	int if_id = (wsm_id >> 6) & 0x0F;
+	u8 *data_ptr = (u8 *)&wsm[1];
+	struct ieee80211_hdr *i80211_ptr = (struct ieee80211_hdr *)(data_ptr + 28 /* radio header */);
+	__le16 fctl = *(__le16 *)i80211_ptr;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(hw_priv->vif_list[if_id]);
+	u32 encry_hdr_len = bes2600_bh_get_encry_hdr_len(priv->cipherType);
+	u32 i80211_len = ieee80211_hdrlen(fctl);
+	u8 *tmp_ptr = (u8 *)i80211_ptr;
+	u16 *eth_type_ptr = (u16 *)(tmp_ptr + i80211_len + encry_hdr_len + ETH_ALEN);
+	u16 eth_type = __be16_to_cpu(*eth_type_ptr);
+
+	bes2600_info(BES2600_DBG_BH, "Host was waked by data:\n");
+	bes2600_info(BES2600_DBG_BH, "RA:%pM\n", ieee80211_get_DA(i80211_ptr));
+	bes2600_info(BES2600_DBG_BH, "ETH_TYPE:0x%04x\n", eth_type);
+
+	if (eth_type == ETH_P_IP) {
+		struct iphdr *ip = (struct iphdr *)&eth_type_ptr[1];
+		bes2600_info(BES2600_DBG_BH, "IPVersion:%d\n", ip->version);
+		bes2600_info(BES2600_DBG_BH, "IPProtol:%d\n", ip->protocol);
+
+		if (ip->version == 4) {
+			bes2600_bh_parse_ipv4_data(ip);
+		}
+	}
+}
+
+static void bes2600_bh_parse_wakeup_event(struct bes2600_common *hw_priv, struct sk_buff *skb)
+{
+	struct wsm_hdr *wsm = (struct wsm_hdr *)skb->data;
+	u16 wsm_id = __le16_to_cpu(wsm->id) & 0xFFF;
+
+	if (hw_priv->sbus_ops->wakeup_source &&
+	    hw_priv->sbus_ops->wakeup_source(hw_priv->sbus_priv)) {
+		if (wsm_id == 0x0804) {
+			u8 *data_ptr = (u8 *)&wsm[1];
+			u8 *i80211_ptr = data_ptr + 28/* radio header */;
+			__le16 fctl = *(__le16 *)i80211_ptr;
+
+			if (ieee80211_is_mgmt(fctl)) {
+				u16 type = (fctl & cpu_to_le16(IEEE80211_FCTL_FTYPE)) >> 2;
+				u16 stype = (fctl & cpu_to_le16(IEEE80211_FCTL_STYPE)) >> 4;
+				bes2600_info(BES2600_DBG_BH, "Host was waked by mgmt, type:%d(%d)\n", type, stype);
+			} else if(ieee80211_is_data(fctl)){
+				bes2600_bh_parse_data_pkt(hw_priv, skb);
+			} else {
+				bes2600_info(BES2600_DBG_BH, "Host was waked by unexpected frame, fctl:0x%04x\n", fctl);
+			}
+		} else {
+			bes2600_info(BES2600_DBG_BH, "Host was waked by event:0x%04x.\n", wsm_id);
+		}
+	}
+}
+
+static int bes2600_bh_rx_helper(struct bes2600_common *priv, int *tx)
+{
+	struct sk_buff *skb = NULL;
+	struct wsm_hdr *wsm;
+	size_t wsm_len;
+	u16 wsm_id;
+	u8 wsm_seq;
+	int rx = 0;
+	u32 confirm_label = 0x0; /* wsm to mcu cmd cnfirm label */
+
+	skb = (struct sk_buff *)priv->sbus_ops->pipe_read(priv->sbus_priv);
+	if (!skb)
+		return 0;
+	rx = 1; // always consider rx pipe not empty
+
+	wsm = (struct wsm_hdr *)skb->data;
+	wsm_len = __le16_to_cpu(wsm->len);
+	if (WARN_ON(wsm_len > skb->len)) {
+		bes2600_err(BES2600_DBG_BH, "wsm_len err %d %d\n", (int)wsm_len, (int)skb->len);
+		goto err;
+	}
+
+	if (priv->wsm_enable_wsm_dumps)
+		print_hex_dump_bytes("<-- ",
+				     DUMP_PREFIX_NONE,
+				     skb->data, wsm_len);
+
+	wsm_id  = __le16_to_cpu(wsm->id) & 0xFFF;
+	wsm_seq = (__le16_to_cpu(wsm->id) >> 13) & 7;
+	bes2600_dbg(BES2600_DBG_BH, "bes2600_bh_rx_helper wsm_id:0x%04x seq:%d\n", wsm_id, wsm_seq);
+
+	skb_trim(skb, wsm_len);
+
+	if (wsm_id == 0x0800) {
+		wsm_handle_exception(priv,
+				     &skb->data[sizeof(*wsm)],
+				     wsm_len - sizeof(*wsm));
+		bes2600_err(BES2600_DBG_BH, "wsm exception.!\n");
+		goto err;
+	} else if ((wsm_seq != priv->wsm_rx_seq[WSM_TXRX_SEQ_IDX(wsm_id)])) {
+		bes2600_err(BES2600_DBG_BH, "seq error! %u. %u. 0x%x.", wsm_seq, priv->wsm_rx_seq[WSM_TXRX_SEQ_IDX(wsm_id)], wsm_id);
+		goto err;
+	}
+
+	bes2600_bh_parse_wakeup_event(priv, skb);
+
+	priv->wsm_rx_seq[WSM_TXRX_SEQ_IDX(wsm_id)] = (wsm_seq + 1) & 7;
+
+	if (IS_DRIVER_TO_MCU_CMD(wsm_id))
+		confirm_label = __le32_to_cpu(((struct wsm_mcu_hdr *)wsm)->handle_label);
+
+	if (WSM_CONFIRM_CONDITION(wsm_id, confirm_label)) {
+		int rc = wsm_release_tx_buffer(priv, 1);
+		bes2600_bh_dec_pending_count(priv, WSM_TXRX_SEQ_IDX(wsm->id));
+
+		if (WARN_ON(rc < 0))
+			return rc;
+		else if (rc > 0)
+			*tx = 1;
+	}
+
+	/* bes2600_wsm_rx takes care on SKB livetime */
+	//if (WARN_ON(wsm_handle_rx(priv, wsm_id, wsm, &skb)))
+	if ((wsm_handle_rx(priv, wsm_id, wsm, &skb))) {
+		bes2600_err(BES2600_DBG_BH, "wsm_handle_rx fail\n");
+		goto err;
+	}
+
+	if (skb) {
+		dev_kfree_skb(skb);
+		skb = NULL;
+	}
+	return rx;
+
+err:
+	bes2600_err(BES2600_DBG_BH, "bes2600_bh_rx_helper err\n");
+	if (skb) {
+		dev_kfree_skb(skb);
+		skb = NULL;
+	}
+	return -1;
+}
+
+static int bes2600_bh_tx_helper(struct bes2600_common *hw_priv,
+			       int *pending_tx,
+			       int *tx_burst)
+{
+	size_t tx_len;
+	u8 *data;
+	int ret;
+	struct wsm_hdr *wsm;
+	int vif_selected;
+
+	wsm_alloc_tx_buffer(hw_priv);
+	ret = wsm_get_tx(hw_priv, &data, &tx_len, tx_burst, &vif_selected);
+	if (ret <= 0) {
+		wsm_release_tx_buffer(hw_priv, 1);
+		if (WARN_ON(ret < 0)) {
+			bes2600_err(BES2600_DBG_BH, "bh get tx failed.\n");
+			return ret; /* Error */
+		}
+		return 0; /* No work */
+	}
+
+	wsm = (struct wsm_hdr *)data;
+	BUG_ON(tx_len < sizeof(*wsm));
+	BUG_ON(__le16_to_cpu(wsm->len) != tx_len);
+	tx_len += 4;
+
+	atomic_add(1, &hw_priv->bh_tx);
+
+	tx_len = hw_priv->sbus_ops->align_size(
+		hw_priv->sbus_priv, tx_len);
+
+	/* Check if not exceeding BES2600 capabilities */
+	if (WARN_ON_ONCE(tx_len > EFFECTIVE_BUF_SIZE))
+		bes2600_err(BES2600_DBG_BH,  "Write aligned len: %zu\n", tx_len);
+
+	wsm->id &= __cpu_to_le16(0xffff ^ WSM_TX_SEQ(WSM_TX_SEQ_MAX));
+	wsm->id |= __cpu_to_le16(WSM_TX_SEQ(hw_priv->wsm_tx_seq[WSM_TXRX_SEQ_IDX(wsm->id)]));
+
+	//bes2600_dbg(BES2600_DBG_BH, "usb send buff len:%u.priv->hw_bufs_used:%d.\n", tx_len, priv->hw_bufs_used);
+	bes2600_dbg(BES2600_DBG_BH, "%s id:0x%04x seq:%d\n", __func__,
+		wsm->id, hw_priv->wsm_tx_seq[WSM_TXRX_SEQ_IDX(wsm->id)]);
+
+	if (WARN_ON(hw_priv->sbus_ops->pipe_send(hw_priv->sbus_priv, 1, tx_len, data))) {
+		bes2600_err(BES2600_DBG_BH,  "tx blew up, len %zu\n", tx_len);
+		wsm_release_tx_buffer(hw_priv, 1);
+		return -1; /* Error */
+	}
+
+	if (vif_selected != -1)
+		hw_priv->hw_bufs_used_vif[vif_selected] ++;
+
+	if (hw_priv->wsm_enable_wsm_dumps)
+		print_hex_dump_bytes("--> ",
+				     DUMP_PREFIX_NONE,
+				     data,
+				     __le16_to_cpu(wsm->len));
+
+	wsm_txed(hw_priv, data);
+
+	hw_priv->wsm_tx_seq[WSM_TXRX_SEQ_IDX(wsm->id)] =
+		(hw_priv->wsm_tx_seq[WSM_TXRX_SEQ_IDX(wsm->id)] + 1) & WSM_TX_SEQ_MAX;
+	bes2600_bh_inc_pending_count(hw_priv, WSM_TXRX_SEQ_IDX(wsm->id));
+
+	if (*tx_burst > 1) {
+		bes2600_debug_tx_burst(hw_priv);
+		return 1; /* Work remains */
+	}
+
+	return 0;
+}
+
+static inline bool
+ieee80211_is_tcp_pkt(struct sk_buff *skb)
+{
+
+	if (!skb) {
+		return false;
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_IP)) {
+		struct iphdr *iph = (struct iphdr *)skb_network_header(skb);
+		if (iph->protocol == IPPROTO_TCP) { // TCP
+			bes2600_dbg(BES2600_DBG_BH, "################ %s line =%d.\n",__func__,__LINE__);
+			return true;
+		}
+	}
+	return false;
+}
+
+
+static int bes2600_need_retry_type(struct sk_buff *skb, int status)
+{
+	int ret = 0;
+	if (!skb) {
+		bes2600_info(BES2600_DBG_BH, "################ %s line =%d.\n",__func__,__LINE__);
+		return -1;
+	}
+
+	if (skb->protocol == cpu_to_be16(ETH_P_IP)) {
+		if (ieee80211_is_tcp_pkt(skb)) {
+			ret = 1;
+		}
+	}
+	if (status !=  WSM_STATUS_RETRY_EXCEEDED)
+		ret = 0;
+	return ret;
+}
+
+int bes2600_bh_sw_process(struct bes2600_common *hw_priv,
+			 struct wsm_tx_confirm *tx_confirm)
+{
+	struct bes2600_txpriv *txpriv;
+	struct sk_buff *skb = NULL;
+	unsigned long timestamp = 0;
+	struct bes2600_queue *queue;
+	u8 queue_id, queue_gen;
+
+	long delta_time;
+	if (!tx_confirm) {
+		bes2600_err(BES2600_DBG_BH,  "%s tx_confirm is NULL\n", __func__);
+		return 0;
+	}
+	queue_id = bes2600_queue_get_queue_id(tx_confirm->packetID);
+	queue = &hw_priv->tx_queue[queue_id];
+
+	if (!queue) {
+		bes2600_err(BES2600_DBG_BH,  "%s queue is NULL\n", __func__);
+		return 0;
+	}
+
+	/* don't retry if the connection is already disconnected */
+	queue_gen = bes2600_queue_get_generation(tx_confirm->packetID);
+	if(queue_gen != queue->generation)
+		return -1;
+
+	bes2600_queue_get_skb_and_timestamp(queue, tx_confirm->packetID,
+						&skb, &txpriv, &timestamp);
+	if (skb == NULL) {
+		bes2600_err(BES2600_DBG_BH,  "%s skb is NULL\n", __func__);
+		return -1;
+	}
+	if (timestamp > jiffies)
+		delta_time = jiffies + ((unsigned long)0xffffffff - timestamp);
+	else
+		delta_time =  jiffies - timestamp;
+	bes2600_add_tx_delta_time(delta_time);
+	bes2600_add_tx_ac_delta_time(queue_id, delta_time);
+
+	if (bes2600_need_retry_type(skb, tx_confirm->status) == 0)
+		return -1;
+
+	if (delta_time > 1000)
+		return -1;
+
+	if (txpriv->retry_count < CW1200_MAX_SW_RETRY_CNT ) {
+		struct bes2600_vif *priv =
+		__cw12xx_hwpriv_to_vifpriv(hw_priv, txpriv->if_id);
+		txpriv->retry_count++;
+
+		bes2600_tx_status(priv,skb);
+
+		bes2600_pwr_set_busy_event_with_timeout_async(
+			hw_priv, BES_PWR_LOCK_ON_TX, BES_PWR_EVENT_TX_TIMEOUT);
+
+		bes2600_sw_retry_requeue(hw_priv, queue, tx_confirm->packetID, true);
+		return 0;
+	} else {
+		txpriv->retry_count = 0;
+	}
+
+	return -1;
+}
+
+void bes2600_bh_inc_pending_count(struct bes2600_common *hw_priv, int idx)
+{
+	struct timer_list *timer = (idx == 0) ? &hw_priv->lmac_mon_timer
+	                                      : &hw_priv->mcu_mon_timer;
+
+	if(hw_priv->wsm_tx_pending[idx]++ == 0) {
+		bes2600_dbg(BES2600_DBG_BH,  "start timer in tx, idx:%d\n", idx);
+		mod_timer(timer, jiffies + 3 * HZ);
+	}
+}
+
+void bes2600_bh_dec_pending_count(struct bes2600_common *hw_priv, int idx)
+{
+	struct timer_list *timer = (idx == 0) ? &hw_priv->lmac_mon_timer
+	                                      : &hw_priv->mcu_mon_timer;
+
+	if(hw_priv->wsm_tx_pending[idx] == 0) {
+		bes2600_err(BES2600_DBG_TXRX, "tx pending count error, idx:%d\n", idx);
+		return;
+	}
+
+	if(--hw_priv->wsm_tx_pending[idx] == 0) {
+		del_timer_sync(timer);
+	} else {
+		mod_timer(timer, jiffies + 3 * HZ);
+	}
+}
+
+void bes2600_bh_mcu_active_monitor(struct timer_list* t)
+{
+	struct bes2600_common *hw_priv = from_timer(hw_priv, t, mcu_mon_timer);
+
+	bes2600_err(BES2600_DBG_TXRX, "link break between mcu and host, hw_buf_used:%d pending:%d\n", 
+				hw_priv->hw_bufs_used, hw_priv->wsm_tx_pending[1]);
+	bes2600_chrdev_wifi_force_close(hw_priv, true);
+}
+
+void bes2600_bh_lmac_active_monitor(struct timer_list* t)
+{
+	struct bes2600_common *hw_priv = from_timer(hw_priv, t, lmac_mon_timer);
+
+	bes2600_err(BES2600_DBG_TXRX, "link break between lmac and host, hw_buf_used:%d pending:%d\n", 
+				hw_priv->hw_bufs_used, hw_priv->wsm_tx_pending[0]);
+	bes2600_chrdev_wifi_force_close(hw_priv, true);
+}
+
+#define BH_RX_CONT_LIMIT	3
+#define BH_TX_CONT_LIMIT	20
+static int bes2600_bh(void *arg)
+{
+	struct bes2600_common *hw_priv = arg;
+	int rx, tx, term, suspend;
+	int tx_allowed;
+	int pending_tx = 0;
+	int tx_burst;
+	long status;
+	int ret;
+
+	int tx_cont = 0;
+	int rx_cont = 0;
+
+	for (;;) {
+		rx_cont = 0;
+		tx_cont = 0;
+
+		if (!hw_priv->hw_bufs_used &&
+		    !bes2600_pwr_device_is_idle(hw_priv) &&
+		    !atomic_read(&hw_priv->recent_scan)) {
+			status = 5 * HZ;
+		} else if (hw_priv->hw_bufs_used) {
+			/* Interrupt loss detection */
+			status = 5 * HZ;
+		} else {
+			status = MAX_SCHEDULE_TIMEOUT;
+		}
+
+		status = wait_event_interruptible_timeout(hw_priv->bh_wq, ({
+				rx = atomic_xchg(&hw_priv->bh_rx, 0);
+				tx = atomic_xchg(&hw_priv->bh_tx, 0);
+				term = atomic_xchg(&hw_priv->bh_term, 0);
+				suspend = pending_tx ?
+					0 : atomic_read(&hw_priv->bh_suspend);
+				(rx || tx || term || suspend || hw_priv->bh_error);
+			}), status);
+
+		//bes2600_err(BES2600_DBG_BH,  "[BH] - rx: %d, tx: %d, term: %d, bh_err: %d, suspend: %d, bufused: %d, status: %ld\n",
+				//rx, tx, term, suspend, hw_priv->bh_error, hw_priv->hw_bufs_used, status);
+
+		/* Did an error occur? */
+		if ((status < 0 && status != -ERESTARTSYS) ||
+		    term || hw_priv->bh_error) {
+			break;
+		}
+		if (!status) {  /* wait_event timed out */
+			unsigned long timestamp = jiffies;
+			long timeout;
+			int pending = 0;
+			int i;
+			/* Check to see if we have any outstanding frames */
+			if (hw_priv->hw_bufs_used && (!rx || !tx)) {
+				bes2600_err(BES2600_DBG_BH,  "usedbuf:%u. rx:%u. tx:%u.\n", hw_priv->hw_bufs_used, rx, tx);
+				sdio_work_debug(hw_priv->sbus_priv);
+				bes2600_err(BES2600_DBG_BH,  "Missed interrupt? (%d frames outstanding)\n",
+					   hw_priv->hw_bufs_used);
+				rx = 1;
+
+				/* Get a timestamp of "oldest" frame */
+				for (i = 0; i < 4; ++i)
+					pending += bes2600_queue_get_xmit_timestamp(
+						&hw_priv->tx_queue[i],
+						&timestamp, i,
+						hw_priv->pending_frame_id);
+
+				/* Check if frame transmission is timed out.
+				 * Add an extra second with respect to possible
+				 * interrupt loss.
+				 */
+				timeout = timestamp +
+					WSM_CMD_LAST_CHANCE_TIMEOUT +
+					1 * HZ  -
+					jiffies;
+
+				/* And terminate BH thread if the frame is "stuck" */
+				if (pending && timeout < 0) {
+					wiphy_warn(hw_priv->hw->wiphy,
+						   "Timeout waiting for TX confirm (%d/%d pending, %ld vs %lu).\n",
+						   hw_priv->hw_bufs_used, pending,
+						   timestamp, jiffies);
+				}
+
+				bes2600_chrdev_wifi_force_close(hw_priv, false);
+			}
+			goto rx;
+		} else if (suspend) {
+			bes2600_dbg(BES2600_DBG_BH,  "[BH] Device suspend.\n");
+
+			atomic_set(&hw_priv->bh_suspend, BES2600_BH_SUSPENDED);
+			wake_up(&hw_priv->bh_evt_wq);
+			status = wait_event_interruptible(hw_priv->bh_wq,
+							  BES2600_BH_RESUME == atomic_read(&hw_priv->bh_suspend));
+			if (status < 0) {
+				wiphy_err(hw_priv->hw->wiphy,
+					  "Failed to wait for resume: %ld.\n",
+					  status);
+				break;
+			}
+			bes2600_dbg(BES2600_DBG_BH,  "[BH] Device resume.\n");
+			atomic_set(&hw_priv->bh_suspend, BES2600_BH_RESUMED);
+			wake_up(&hw_priv->bh_evt_wq);
+			atomic_add(1, &hw_priv->bh_rx);
+			goto done;
+		}
+
+	rx:
+		tx += pending_tx;
+		pending_tx = 0;
+		ret = bes2600_bh_rx_helper(hw_priv, &tx);
+		if (ret < 0) {
+			bes2600_err(BES2600_DBG_BH, "bes2600_bh_rx_helper fail\n");
+			sdio_work_debug(hw_priv->sbus_priv);
+			// break; // rx error
+			bes2600_chrdev_wifi_force_close(hw_priv, false);
+		}
+		else if (ret == 1) {
+			rx = 1; // continue rx
+			rx_cont++;
+		}
+		else
+			rx = 0; // wait for a new rx event
+		if (rx && (rx_cont < BH_RX_CONT_LIMIT))
+			goto rx;
+		rx_cont = 0;
+	tx:
+		if (1) {
+
+			tx = 0;
+
+			BUG_ON(hw_priv->hw_bufs_used > hw_priv->wsm_caps.numInpChBufs);
+			tx_burst = hw_priv->wsm_caps.numInpChBufs - hw_priv->hw_bufs_used;
+			tx_allowed = tx_burst > 0;
+
+			if (!tx_allowed) {
+				/* Buffers full.  Ensure we process tx
+				 * after we handle rx..
+				 */
+				pending_tx = tx;
+				goto done_rx;
+			}
+			ret = bes2600_bh_tx_helper(hw_priv, &pending_tx, &tx_burst);
+			if (ret < 0) {
+				bes2600_err(BES2600_DBG_BH, "bes2600_bh_tx_helper fail\n");
+				sdio_work_debug(hw_priv->sbus_priv);
+				break;
+			}
+			if (ret > 0) {
+				/* More to transmit */
+				tx_cont++;
+				tx = ret;
+			}
+
+			if (tx && tx_cont < BH_TX_CONT_LIMIT)
+				goto tx;
+			tx_cont = 0;
+		}
+
+	done_rx:
+		if (hw_priv->bh_error)
+			break;
+		//if (ctrl_reg & ST90TDS_CONT_NEXT_LEN_MASK)
+		if (rx)
+			goto rx;
+		if (tx)
+			goto tx;
+
+	done:
+		/* Re-enable device interrupts */
+		//hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+		//__bes2600_irq_enable(1);
+		//hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+		asm volatile ("nop");
+	}
+
+	/* Explicitly disable device interrupts */
+	hw_priv->sbus_ops->lock(hw_priv->sbus_priv);
+	__bes2600_irq_enable(0);
+	hw_priv->sbus_ops->unlock(hw_priv->sbus_priv);
+
+	if (!term) {
+		bes2600_err(BES2600_DBG_BH,  "[BH] Fatal error, exiting.\n");
+		sdio_work_debug(hw_priv->sbus_priv);
+		hw_priv->bh_error = 1;
+		/* TODO: schedule_work(recovery) */
+	}
+	return 0;
+}
diff --git a/drivers/staging/bes2600/bh.h b/drivers/staging/bes2600/bh.h
new file mode 100755
index 000000000000..2d1df49b16fd
--- /dev/null
+++ b/drivers/staging/bes2600/bh.h
@@ -0,0 +1,45 @@
+/*
+ * Device handling thread interface for mac80211 BES2600 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_BH_H
+#define BES2600_BH_H
+
+#include <linux/version.h>
+
+/* extern */ struct bes2600_common;
+
+#define SDIO_BLOCK_SIZE (528)
+
+#define CW1200_MAX_SW_RETRY_CNT		(2)
+
+
+int bes2600_register_bh(struct bes2600_common *hw_priv);
+void bes2600_unregister_bh(struct bes2600_common *hw_priv);
+void bes2600_irq_handler(struct bes2600_common *hw_priv);
+void bes2600_bh_wakeup(struct bes2600_common *hw_priv);
+int bes2600_bh_suspend(struct bes2600_common *hw_priv);
+int bes2600_bh_resume(struct bes2600_common *hw_priv);
+/* Must be called from BH thread. */
+void bes2600_enable_powersave(struct bes2600_vif *priv,
+			     bool enable);
+int wsm_release_tx_buffer(struct bes2600_common *hw_priv, int count);
+int wsm_release_vif_tx_buffer(struct bes2600_common *hw_priv, int if_id,
+				int count);
+int bes2600_bh_sw_process(struct bes2600_common *hw_priv,
+			 struct wsm_tx_confirm *tx_confirm);
+
+void bes2600_bh_inc_pending_count(struct bes2600_common *hw_priv, int idx);
+void bes2600_bh_dec_pending_count(struct bes2600_common *hw_priv, int idx);
+
+void bes2600_bh_mcu_active_monitor(struct timer_list* t);
+void bes2600_bh_lmac_active_monitor(struct timer_list* t);
+
+#endif /* BES2600_BH_H */
diff --git a/drivers/staging/bes2600/debug.c b/drivers/staging/bes2600/debug.c
new file mode 100755
index 000000000000..db6752cbf375
--- /dev/null
+++ b/drivers/staging/bes2600/debug.c
@@ -0,0 +1,655 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/debugfs.h>
+#include <linux/seq_file.h>
+#include "bes2600.h"
+#include "debug.h"
+
+/* join_status */
+static const char * const bes2600_debug_join_status[] = {
+	"passive",
+	"monitor",
+	"station",
+	"access point",
+};
+
+/* WSM_JOIN_PREAMBLE_... */
+static const char * const bes2600_debug_preamble[] = {
+	"long",
+	"short",
+	"long on 1 and 2 Mbps",
+};
+
+static const char * const bes2600_debug_fw_types[] = {
+	"ETF",
+	"WFM",
+	"WSM",
+	"HI test",
+	"Platform test",
+};
+
+static const char * const bes2600_debug_link_id[] = {
+	"OFF",
+	"REQ",
+	"SOFT",
+	"HARD",
+};
+
+static const char *bes2600_debug_mode(int mode)
+{
+	switch (mode) {
+	case NL80211_IFTYPE_UNSPECIFIED:
+		return "unspecified";
+	case NL80211_IFTYPE_MONITOR:
+		return "monitor";
+	case NL80211_IFTYPE_STATION:
+		return "station";
+	case NL80211_IFTYPE_ADHOC:
+		return "ad-hok";
+	case NL80211_IFTYPE_MESH_POINT:
+		return "mesh point";
+	case NL80211_IFTYPE_AP:
+		return "access point";
+	case NL80211_IFTYPE_P2P_CLIENT:
+		return "p2p client";
+	case NL80211_IFTYPE_P2P_GO:
+		return "p2p go";
+	default:
+		return "unsupported";
+	}
+}
+
+static void bes2600_queue_status_show(struct seq_file *seq,
+				     struct bes2600_queue *q)
+{
+	int i, if_id;
+	seq_printf(seq, "Queue       %d:\n", (int)q->queue_id);
+	seq_printf(seq, "  capacity: %ld\n", (long)q->capacity);
+	seq_printf(seq, "  queued:   %ld\n", (long)q->num_queued);
+	seq_printf(seq, "  pending:  %ld\n", (long)q->num_pending);
+	seq_printf(seq, "  sent:     %ld\n", (long)q->num_sent);
+	seq_printf(seq, "  locked:   %s\n", q->tx_locked_cnt ? "yes" : "no");
+	seq_printf(seq, "  overfull: %s\n", q->overfull ? "yes" : "no");
+	seq_puts(seq,   "  link map: 0-> ");
+	for (if_id = 0; if_id < CW12XX_MAX_VIFS; if_id++) {
+		for (i = 0; i < q->stats->map_capacity; ++i)
+			seq_printf(seq, "%.2d ", q->link_map_cache[if_id][i]);
+		seq_printf(seq, "<-%ld\n", (long)q->stats->map_capacity);
+	}
+}
+
+static void bes2600_debug_print_map(struct seq_file *seq,
+				   struct bes2600_vif *priv,
+				   const char *label,
+				   u32 map)
+{
+	int i;
+	seq_printf(seq, "%s0-> ", label);
+	for (i = 0; i < priv->hw_priv->tx_queue_stats.map_capacity; ++i)
+		seq_printf(seq, "%s ", (map & BIT(i)) ? "**" : "..");
+	seq_printf(seq, "<-%ld\n",
+		   (long)priv->hw_priv->tx_queue_stats.map_capacity - 1);
+}
+
+static int bes2600_status_show_common(struct seq_file *seq, void *v)
+{
+	int i;
+	struct list_head *item;
+	struct bes2600_common *hw_priv = seq->private;
+	struct bes2600_debug_common *d = hw_priv->debug;
+	int ba_cnt, ba_acc, ba_cnt_rx, ba_acc_rx, ba_avg = 0, ba_avg_rx = 0;
+	bool ba_ena;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	ba_cnt = hw_priv->debug->ba_cnt;
+	ba_acc = hw_priv->debug->ba_acc;
+	ba_cnt_rx = hw_priv->debug->ba_cnt_rx;
+	ba_acc_rx = hw_priv->debug->ba_acc_rx;
+	ba_ena = hw_priv->ba_ena;
+	if (ba_cnt)
+		ba_avg = ba_acc / ba_cnt;
+	if (ba_cnt_rx)
+		ba_avg_rx = ba_acc_rx / ba_cnt_rx;
+	spin_unlock_bh(&hw_priv->ba_lock);
+
+	seq_puts(seq,   "BES2600 Wireless LAN driver status\n");
+	seq_printf(seq, "Hardware:   %d.%d\n",
+		hw_priv->wsm_caps.hardwareId,
+		hw_priv->wsm_caps.hardwareSubId);
+	seq_printf(seq, "Firmware:   %s %d.%d\n",
+		bes2600_debug_fw_types[hw_priv->wsm_caps.firmwareType],
+		hw_priv->wsm_caps.firmwareVersion,
+		hw_priv->wsm_caps.firmwareBuildNumber);
+	seq_printf(seq, "FW API:     %d\n",
+		hw_priv->wsm_caps.firmwareApiVer);
+	seq_printf(seq, "FW caps:    0x%.4X\n",
+		hw_priv->wsm_caps.firmwareCap);
+	if (hw_priv->channel)
+		seq_printf(seq, "Channel:    %d%s\n",
+			hw_priv->channel->hw_value,
+			hw_priv->channel_switch_in_progress ?
+			" (switching)" : "");
+	seq_printf(seq, "HT:         %s\n",
+		bes2600_is_ht(&hw_priv->ht_info) ? "on" : "off");
+	if (bes2600_is_ht(&hw_priv->ht_info)) {
+		seq_printf(seq, "Greenfield: %s\n",
+			bes2600_ht_greenfield(&hw_priv->ht_info) ? "yes" : "no");
+		seq_printf(seq, "AMPDU dens: %d\n",
+			bes2600_ht_ampdu_density(&hw_priv->ht_info));
+	}
+	spin_lock_bh(&hw_priv->tx_policy_cache.lock);
+	i = 0;
+	list_for_each(item, &hw_priv->tx_policy_cache.used)
+		++i;
+	spin_unlock_bh(&hw_priv->tx_policy_cache.lock);
+	seq_printf(seq, "RC in use:  %d\n", i);
+	seq_printf(seq, "BA stat:    %d, %d (%d)\n",
+		ba_cnt, ba_acc, ba_avg);
+	seq_printf(seq, "BA RX stat:    %d, %d (%d)\n",
+		ba_cnt_rx, ba_acc_rx, ba_avg_rx);
+	seq_printf(seq, "Block ACK:  %s\n", ba_ena ? "on" : "off");
+
+	seq_puts(seq, "\n");
+	for (i = 0; i < 4; ++i) {
+		bes2600_queue_status_show(seq, &hw_priv->tx_queue[i]);
+		seq_puts(seq, "\n");
+	}
+	seq_printf(seq, "TX burst:   %d\n",
+		d->tx_burst);
+	seq_printf(seq, "RX burst:   %d\n",
+		d->rx_burst);
+	seq_printf(seq, "TX miss:    %d\n",
+		d->tx_cache_miss);
+	seq_printf(seq, "Long retr:  %d\n",
+		hw_priv->long_frame_max_tx_count);
+	seq_printf(seq, "Short retr: %d\n",
+		hw_priv->short_frame_max_tx_count);
+
+	seq_printf(seq, "BH status:  %s\n",
+		atomic_read(&hw_priv->bh_term) ? "terminated" : "alive");
+	seq_printf(seq, "Pending RX: %d\n",
+		atomic_read(&hw_priv->bh_rx));
+	seq_printf(seq, "Pending TX: %d\n",
+		atomic_read(&hw_priv->bh_tx));
+	if (hw_priv->bh_error)
+		seq_printf(seq, "BH errcode: %d\n",
+			hw_priv->bh_error);
+	seq_printf(seq, "TX bufs:    %d x %d bytes\n",
+		hw_priv->wsm_caps.numInpChBufs,
+		hw_priv->wsm_caps.sizeInpChBuf);
+	seq_printf(seq, "Used bufs:  %d\n",
+		hw_priv->hw_bufs_used);
+	seq_printf(seq, "Device:     %s\n",
+		bes2600_pwr_device_is_idle(hw_priv) ? "alseep" : "awake");
+
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	seq_printf(seq, "WSM status: %s\n",
+		hw_priv->wsm_cmd.done ? "idle" : "active");
+	seq_printf(seq, "WSM cmd:    0x%.4X (%ld bytes)\n",
+		hw_priv->wsm_cmd.cmd, (long)hw_priv->wsm_cmd.len);
+	seq_printf(seq, "WSM retval: %d\n",
+		hw_priv->wsm_cmd.ret);
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+
+	seq_printf(seq, "Datapath:   %s\n",
+		atomic_read(&hw_priv->tx_lock) ? "locked" : "unlocked");
+	if (atomic_read(&hw_priv->tx_lock))
+		seq_printf(seq, "TXlock cnt: %d\n",
+			atomic_read(&hw_priv->tx_lock));
+
+	seq_printf(seq, "Scan:       %s\n",
+		atomic_read(&hw_priv->scan.in_progress) ? "active" : "idle");
+	seq_printf(seq, "Led state:  0x%.2X\n",
+		hw_priv->softled_state);
+
+	return 0;
+}
+
+static int bes2600_status_open_common(struct inode *inode, struct file *file)
+{
+	return single_open(file, &bes2600_status_show_common,
+		inode->i_private);
+}
+
+static const struct file_operations fops_status_common = {
+	.open = bes2600_status_open_common,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int bes2600_counters_show(struct seq_file *seq, void *v)
+{
+	int ret;
+	struct bes2600_common *hw_priv = seq->private;
+	struct wsm_counters_table counters;
+
+	ret = wsm_get_counters_table(hw_priv, &counters);
+	if (ret)
+		return ret;
+
+#define CAT_STR(x, y) x ## y
+#define PUT_COUNTER(tab, name) \
+	seq_printf(seq, "%s:" tab "%d\n", #name, \
+		__le32_to_cpu(counters.CAT_STR(count, name)))
+
+	PUT_COUNTER("\t\t", PlcpErrors);
+	PUT_COUNTER("\t\t", FcsErrors);
+	PUT_COUNTER("\t\t", TxPackets);
+	PUT_COUNTER("\t\t", RxPackets);
+	PUT_COUNTER("\t\t", RxPacketErrors);
+	PUT_COUNTER("\t",   RxDecryptionFailures);
+	PUT_COUNTER("\t\t", RxMicFailures);
+	PUT_COUNTER("\t",   RxNoKeyFailures);
+	PUT_COUNTER("\t",   TxMulticastFrames);
+	PUT_COUNTER("\t",   TxFramesSuccess);
+	PUT_COUNTER("\t",   TxFrameFailures);
+	PUT_COUNTER("\t",   TxFramesRetried);
+	PUT_COUNTER("\t",   TxFramesMultiRetried);
+	PUT_COUNTER("\t",   RxFrameDuplicates);
+	PUT_COUNTER("\t\t", RtsSuccess);
+	PUT_COUNTER("\t\t", RtsFailures);
+	PUT_COUNTER("\t\t", AckFailures);
+	PUT_COUNTER("\t",   RxMulticastFrames);
+	PUT_COUNTER("\t",   RxFramesSuccess);
+	PUT_COUNTER("\t",   RxCMACICVErrors);
+	PUT_COUNTER("\t\t", RxCMACReplays);
+	PUT_COUNTER("\t",   RxMgmtCCMPReplays);
+
+#undef PUT_COUNTER
+#undef CAT_STR
+
+	return 0;
+}
+
+static int bes2600_counters_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &bes2600_counters_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_counters = {
+	.open = bes2600_counters_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int bes2600_power_busy_event_show(struct seq_file *seq, void *v)
+{
+	struct bes2600_common *hw_priv = seq->private;
+	char *buffer = NULL;
+
+	buffer = kmalloc(8192, GFP_KERNEL);
+	if(!buffer)
+		return -ENOMEM;
+
+	if(bes2600_pwr_busy_event_dump(hw_priv, buffer, 8192) == 0) {
+		seq_printf(seq, "%s", buffer);
+	} else {
+		return -EFBIG;
+	}
+
+	kfree(buffer);
+
+	return 0;
+}
+
+static int bes2600_power_busy_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, &bes2600_power_busy_event_show,
+		inode->i_private);
+}
+
+static const struct file_operations fops_power_busy_events = {
+	.open = bes2600_power_busy_open,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+static int bes2600_generic_open(struct inode *inode, struct file *file)
+{
+	file->private_data = inode->i_private;
+	return 0;
+}
+
+static ssize_t bes2600_11n_read(struct file *file,
+	char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct bes2600_common *hw_priv = file->private_data;
+	struct ieee80211_supported_band *band =
+		hw_priv->hw->wiphy->bands[NL80211_BAND_2GHZ];
+	return simple_read_from_buffer(user_buf, count, ppos,
+		band->ht_cap.ht_supported ? "1\n" : "0\n", 2);
+}
+
+static ssize_t bes2600_11n_write(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct bes2600_common *hw_priv = file->private_data;
+	struct ieee80211_supported_band *band[2] = {
+		hw_priv->hw->wiphy->bands[NL80211_BAND_2GHZ],
+		hw_priv->hw->wiphy->bands[NL80211_BAND_5GHZ],
+	};
+	char buf[1];
+	int ena = 0;
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 1))
+		return -EFAULT;
+	if (buf[0] == 1)
+		ena = 1;
+
+	band[0]->ht_cap.ht_supported = ena;
+	band[1]->ht_cap.ht_supported = ena;
+
+	return count;
+}
+
+static const struct file_operations fops_bes2600_log_control = {
+	.open = bes2600_log_control_open,
+	.read = bes2600_log_control_read,
+	.write = bes2600_log_control_write,
+	.llseek = default_llseek,
+};
+
+static const struct file_operations fops_11n = {
+	.open = bes2600_generic_open,
+	.read = bes2600_11n_read,
+	.write = bes2600_11n_write,
+	.llseek = default_llseek,
+};
+
+static ssize_t bes2600_wsm_dumps(struct file *file,
+	const char __user *user_buf, size_t count, loff_t *ppos)
+{
+	struct bes2600_common *hw_priv = file->private_data;
+	char buf[1];
+
+	if (!count)
+		return -EINVAL;
+	if (copy_from_user(buf, user_buf, 1))
+		return -EFAULT;
+
+	if (buf[0] == '1')
+		hw_priv->wsm_enable_wsm_dumps = 1;
+	else
+		hw_priv->wsm_enable_wsm_dumps = 0;
+
+	return count;
+}
+
+static const struct file_operations fops_wsm_dumps = {
+	.open = bes2600_generic_open,
+	.write = bes2600_wsm_dumps,
+	.llseek = default_llseek,
+};
+
+int bes2600_debug_init_common(struct bes2600_common *hw_priv)
+{
+	int ret = -ENOMEM;
+	struct bes2600_debug_common *d =
+		kzalloc(sizeof(struct bes2600_debug_common), GFP_KERNEL);
+	hw_priv->debug = d;
+	if (!d)
+		return ret;
+
+	d->debugfs_phy = debugfs_create_dir("bes2600",
+			hw_priv->hw->wiphy->debugfsdir);
+	if (!d->debugfs_phy)
+		goto err;
+
+	if (!debugfs_create_file("status", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_status_common))
+		goto err;
+
+	if (!debugfs_create_file("counters", S_IRUSR, d->debugfs_phy,
+			hw_priv, &fops_counters))
+		goto err;
+
+	if (!debugfs_create_file("11n", S_IRUSR | S_IWUSR,
+			d->debugfs_phy, hw_priv, &fops_11n))
+		goto err;
+
+	if (!debugfs_create_file("bes2600_log_control", S_IRUSR | S_IWUSR,
+			d->debugfs_phy, hw_priv, &fops_bes2600_log_control))
+		goto err;
+
+	if (!debugfs_create_file("wsm_dumps", S_IWUSR, d->debugfs_phy,
+			hw_priv, &fops_wsm_dumps))
+		goto err;
+
+	ret = bes2600_itp_init(hw_priv);
+	if (ret)
+		goto err;
+
+	return 0;
+
+err:
+	hw_priv->debug = NULL;
+	debugfs_remove_recursive(d->debugfs_phy);
+	kfree(d);
+	return ret;
+}
+
+void bes2600_debug_release_common(struct bes2600_common *hw_priv)
+{
+	struct bes2600_debug_common *d = hw_priv->debug;
+	if (d) {
+		bes2600_itp_release(hw_priv);
+		hw_priv->debug = NULL;
+		kfree(d);
+	}
+}
+
+static int bes2600_status_show_priv(struct seq_file *seq, void *v)
+{
+	int i;
+	struct bes2600_vif *priv = seq->private;
+	struct bes2600_debug_priv *d = priv->debug;
+
+	seq_printf(seq, "Mode:       %s%s\n",
+		bes2600_debug_mode(priv->mode),
+		priv->listening ? " (listening)" : "");
+	seq_printf(seq, "Assoc:      %s\n",
+		bes2600_debug_join_status[priv->join_status]);
+	if (priv->rx_filter.promiscuous)
+		seq_puts(seq,   "Filter:     promisc\n");
+	else if (priv->rx_filter.fcs)
+		seq_puts(seq,   "Filter:     fcs\n");
+	if (priv->rx_filter.bssid)
+		seq_puts(seq,   "Filter:     bssid\n");
+	if (priv->bf_control.bcn_count)
+		seq_puts(seq,   "Filter:     beacons\n");
+
+	if (priv->enable_beacon ||
+			priv->mode == NL80211_IFTYPE_AP ||
+			priv->mode == NL80211_IFTYPE_ADHOC ||
+			priv->mode == NL80211_IFTYPE_MESH_POINT ||
+			priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "Beaconing:  %s\n",
+			priv->enable_beacon ?
+			"enabled" : "disabled");
+	if (priv->ssid_length ||
+			priv->mode == NL80211_IFTYPE_AP ||
+			priv->mode == NL80211_IFTYPE_ADHOC ||
+			priv->mode == NL80211_IFTYPE_MESH_POINT ||
+			priv->mode == NL80211_IFTYPE_P2P_GO)
+		seq_printf(seq, "SSID:       %.*s\n",
+			(int)priv->ssid_length, priv->ssid);
+
+	for (i = 0; i < 4; ++i) {
+		seq_printf(seq, "EDCA(%d):    %d, %d, %d, %d, %d\n", i,
+			priv->edca.params[i].cwMin,
+			priv->edca.params[i].cwMax,
+			priv->edca.params[i].aifns,
+			priv->edca.params[i].txOpLimit,
+			priv->edca.params[i].maxReceiveLifetime);
+	}
+	if (priv->join_status == BES2600_JOIN_STATUS_STA) {
+		static const char *pmMode = "unknown";
+		switch (priv->powersave_mode.pmMode) {
+		case WSM_PSM_ACTIVE:
+			pmMode = "off";
+			break;
+		case WSM_PSM_PS:
+			pmMode = "on";
+			break;
+		case WSM_PSM_FAST_PS:
+			pmMode = "dynamic";
+			break;
+		}
+		seq_printf(seq, "Preamble:   %s\n",
+			bes2600_debug_preamble[
+			priv->association_mode.preambleType]);
+		seq_printf(seq, "AMPDU spcn: %d\n",
+			priv->association_mode.mpduStartSpacing);
+		seq_printf(seq, "Basic rate: 0x%.8X\n",
+			le32_to_cpu(priv->association_mode.basicRateSet));
+		seq_printf(seq, "Bss lost:   %d beacons\n",
+			priv->bss_params.beaconLostCount);
+		seq_printf(seq, "AID:        %d\n",
+			priv->bss_params.aid);
+		seq_printf(seq, "Rates:      0x%.8X\n",
+			priv->bss_params.operationalRateSet);
+		seq_printf(seq, "Powersave:  %s\n", pmMode);
+	}
+	seq_printf(seq, "RSSI thold: %d\n",
+		priv->cqm_rssi_thold);
+	seq_printf(seq, "RSSI hyst:  %d\n",
+		priv->cqm_rssi_hyst);
+	seq_printf(seq, "TXFL thold: %d\n",
+		priv->cqm_tx_failure_thold);
+	seq_printf(seq, "Linkloss:   %d\n",
+		priv->cqm_link_loss_count);
+	seq_printf(seq, "Bcnloss:    %d\n",
+		priv->cqm_beacon_loss_count);
+
+	bes2600_debug_print_map(seq, priv, "Link map:   ",
+		priv->link_id_map);
+	bes2600_debug_print_map(seq, priv, "Asleep map: ",
+		priv->sta_asleep_mask);
+	bes2600_debug_print_map(seq, priv, "PSPOLL map: ",
+		priv->pspoll_mask);
+
+	seq_puts(seq, "\n");
+
+	for (i = 0; i < CW1250_MAX_STA_IN_AP_MODE; ++i) {
+		if (priv->link_id_db[i].status) {
+			seq_printf(seq, "Link %d:     %s, %pM\n",
+				i + 1, bes2600_debug_link_id[
+				priv->link_id_db[i].status],
+				priv->link_id_db[i].mac);
+		}
+	}
+
+	seq_puts(seq, "\n");
+
+	seq_printf(seq, "Powermgmt:  %s\n",
+		priv->powersave_enabled ? "on" : "off");
+
+	seq_printf(seq, "TXed:       %d\n",
+		d->tx);
+	seq_printf(seq, "AGG TXed:   %d\n",
+		d->tx_agg);
+	seq_printf(seq, "MULTI TXed: %d (%d)\n",
+		d->tx_multi, d->tx_multi_frames);
+	seq_printf(seq, "RXed:       %d\n",
+		d->rx);
+	seq_printf(seq, "AGG RXed:   %d\n",
+		d->rx_agg);
+	seq_printf(seq, "TX align:   %d\n",
+		d->tx_align);
+	seq_printf(seq, "TX TTL:     %d\n",
+		d->tx_ttl);
+	return 0;
+}
+
+static int bes2600_status_open_priv(struct inode *inode, struct file *file)
+{
+	return single_open(file, &bes2600_status_show_priv,
+		inode->i_private);
+}
+
+static const struct file_operations fops_status_priv = {
+	.open = bes2600_status_open_priv,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
+	.owner = THIS_MODULE,
+};
+
+#define VIF_DEBUGFS_NAME_S 10
+int bes2600_debug_init_priv(struct bes2600_common *hw_priv,
+			   struct bes2600_vif *priv)
+{
+	int ret = -ENOMEM;
+	struct bes2600_debug_priv *d;
+	char name[VIF_DEBUGFS_NAME_S];
+
+	if (WARN_ON(!hw_priv))
+		return ret;
+
+	if (WARN_ON(!hw_priv->debug))
+		return ret;
+
+	d = kzalloc(sizeof(struct bes2600_debug_priv), GFP_KERNEL);
+	priv->debug = d;
+	if (WARN_ON(!d))
+		return ret;
+
+	memset(name, 0, VIF_DEBUGFS_NAME_S);
+	ret = snprintf(name, VIF_DEBUGFS_NAME_S, "vif_%d", priv->if_id);
+	if (WARN_ON(ret < 0))
+		goto err;
+
+	d->debugfs_phy = debugfs_create_dir(name,
+					    hw_priv->debug->debugfs_phy);
+	if (WARN_ON(!d->debugfs_phy))
+		goto err;
+
+	if (!debugfs_create_file("status", S_IRUSR, d->debugfs_phy,
+			priv, &fops_status_priv))
+		goto err;
+
+	return 0;
+err:
+	priv->debug = NULL;
+	debugfs_remove_recursive(d->debugfs_phy);
+	kfree(d);
+	return ret;
+
+}
+
+void bes2600_debug_release_priv(struct bes2600_vif *priv)
+{
+	struct bes2600_debug_priv *d = priv->debug;
+	if (d) {
+		debugfs_remove_recursive(priv->debug->debugfs_phy);
+		priv->debug = NULL;
+		kfree(d);
+	}
+}
+
+int bes2600_print_fw_version(struct bes2600_common *hw_priv, u8* buf, size_t len)
+{
+	return snprintf(buf, len, "%s %d.%d",
+			bes2600_debug_fw_types[hw_priv->wsm_caps.firmwareType],
+			hw_priv->wsm_caps.firmwareVersion,
+			hw_priv->wsm_caps.firmwareBuildNumber);
+}
diff --git a/drivers/staging/bes2600/debug.h b/drivers/staging/bes2600/debug.h
new file mode 100755
index 000000000000..f5ef5b0242cc
--- /dev/null
+++ b/drivers/staging/bes2600/debug.h
@@ -0,0 +1,112 @@
+/*
+ * DebugFS code for BES2600 mac80211 driver
+ *
+ * Copyright (c) 2011, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_DEBUG_H_INCLUDED
+#define BES2600_DEBUG_H_INCLUDED
+
+#include "itp.h"
+
+struct cw200_common;
+
+struct bes2600_debug_common {
+	struct dentry *debugfs_phy;
+	int tx_cache_miss;
+	int tx_burst;
+	int rx_burst;
+	int ba_cnt;
+	int ba_acc;
+	int ba_cnt_rx;
+	int ba_acc_rx;
+};
+
+struct bes2600_debug_priv {
+	struct dentry *debugfs_phy;
+	int tx;
+	int tx_agg;
+	int rx;
+	int rx_agg;
+	int tx_multi;
+	int tx_multi_frames;
+	int tx_align;
+	int tx_ttl;
+};
+
+int bes2600_debug_init_common(struct bes2600_common *hw_priv);
+int bes2600_debug_init_priv(struct bes2600_common *hw_priv,
+			   struct bes2600_vif *priv);
+void bes2600_debug_release_common(struct bes2600_common *hw_priv);
+void bes2600_debug_release_priv(struct bes2600_vif *priv);
+
+static inline void bes2600_debug_txed(struct bes2600_vif *priv)
+{
+	++priv->debug->tx;
+}
+
+static inline void bes2600_debug_txed_agg(struct bes2600_vif *priv)
+{
+	++priv->debug->tx_agg;
+}
+
+static inline void bes2600_debug_txed_multi(struct bes2600_vif *priv,
+					   int count)
+{
+	++priv->debug->tx_multi;
+	priv->debug->tx_multi_frames += count;
+}
+
+static inline void bes2600_debug_rxed(struct bes2600_vif *priv)
+{
+	++priv->debug->rx;
+}
+
+static inline void bes2600_debug_rxed_agg(struct bes2600_vif *priv)
+{
+	++priv->debug->rx_agg;
+}
+
+static inline void bes2600_debug_tx_cache_miss(struct bes2600_common *common)
+{
+	++common->debug->tx_cache_miss;
+}
+
+static inline void bes2600_debug_tx_align(struct bes2600_vif *priv)
+{
+	++priv->debug->tx_align;
+}
+
+static inline void bes2600_debug_tx_ttl(struct bes2600_vif *priv)
+{
+	++priv->debug->tx_ttl;
+}
+
+static inline void bes2600_debug_tx_burst(struct bes2600_common *hw_priv)
+{
+	++hw_priv->debug->tx_burst;
+}
+
+static inline void bes2600_debug_rx_burst(struct bes2600_common *hw_priv)
+{
+	++hw_priv->debug->rx_burst;
+}
+
+static inline void bes2600_debug_ba(struct bes2600_common *hw_priv,
+				   int ba_cnt, int ba_acc, int ba_cnt_rx,
+				   int ba_acc_rx)
+{
+	hw_priv->debug->ba_cnt = ba_cnt;
+	hw_priv->debug->ba_acc = ba_acc;
+	hw_priv->debug->ba_cnt_rx = ba_cnt_rx;
+	hw_priv->debug->ba_acc_rx = ba_acc_rx;
+}
+
+int bes2600_print_fw_version(struct bes2600_common *hw_priv, u8* buf, size_t len);
+
+#endif /* BES2600_DEBUG_H_INCLUDED */
diff --git a/drivers/staging/bes2600/epta_coex.c b/drivers/staging/bes2600/epta_coex.c
new file mode 100755
index 000000000000..e84e9b4e0bbf
--- /dev/null
+++ b/drivers/staging/bes2600/epta_coex.c
@@ -0,0 +1,580 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/version.h>
+
+#include "bes2600.h"
+#include "epta_coex.h"
+#include "epta_request.h"
+
+static bool coex_ps_en;
+static bool coex_fdd_mode;  /* fdd or fdd hybrid */
+static uint8_t epta_conn_state; /* dafault invalid stat */
+static uint32_t epta_freeze_bitmap;  /*bit0: conn, bit1: tp, bit2: tts */
+static int epta_freezed_wlan_duration[EPTA_FREEZE_MAX] = {0};
+static int epta_freezed_wlan_duration_cfg = 0;
+static int wlan_duration_cfg;
+static int bt_duration_cfg;
+static int hw_epta_enable_cfg; /* bit0~bit1: epta mode, bit7: prot flag, other bits: reserved */
+static int epta_ps_mode;	/* 0 - normal mode, 1 - power save mode */
+static int epta_adjust_cnt;
+static int coex_bt_state;
+static uint32_t g_coex_mode;
+
+#define EPTA_MODE_CFG (hw_epta_enable_cfg & 0x03)
+
+/*
+ * This function will send wsm command to set epta module with inputing parameters.
+ * The inputing parameters may not be used really if epta_freeze_bitmap is not zero.
+ * @hw_epta_enable:  when hw_epta_enable is 1, use hardware pta, epta does not work,
+	wlan_duration and bt_duration mean nothing.
+ * @wlan_duration and bt_duration:  need set hw_epta_enable to 0, use software epta.
+	Allow 10~100000 us.
+ * e.g.
+ * coex_set_epta_params(20000, 20000, 0);  means use software epta, wlan get 20ms, bt get 20ms.
+ * coex_set_epta_params(20000, 20000, 1);  means use hardware pta, hardware arbitrate.
+ */
+int coex_set_epta_params(struct bes2600_common *hw_priv, int wlan_duration, int bt_duration, int hw_epta_enable)
+{
+	struct wsm_epta_msg msg;
+
+	if (hw_priv == NULL) {
+		bes2600_dbg(BES2600_DBG_EPTA, "hw_priv is NULL\n");
+		return -1;
+	}
+
+	bes2600_dbg(BES2600_DBG_EPTA, "set epta w:%d hw:%d wc:%d fbit:%x fw:%d\n", wlan_duration, hw_epta_enable,
+		   wlan_duration_cfg, epta_freeze_bitmap, epta_freezed_wlan_duration_cfg);
+
+	if (wlan_duration_cfg == wlan_duration && bt_duration_cfg == bt_duration && hw_epta_enable_cfg == hw_epta_enable) {
+		bes2600_dbg(BES2600_DBG_EPTA, "same epta params\n");
+		return 0;
+	}
+
+	wlan_duration_cfg = wlan_duration;
+	bt_duration_cfg = bt_duration;
+	hw_epta_enable_cfg = hw_epta_enable;
+
+	/* If in freeze mode, use freezed wlan duration; */
+	if (epta_freeze_bitmap) {
+		if (epta_freeze_bitmap & EPTA_FREEZE_SCANNING) {
+			bes2600_info(BES2600_DBG_EPTA, "skip bt state in wifi scanning");
+			return 0;
+		}
+
+		/*
+		 if new wlan duration is more than freezed one, update fw settings with new duration
+		 if new wlan duration is less than freezed one, update fw settings with freezed duration
+		*/
+		if (wlan_duration < epta_freezed_wlan_duration_cfg) {
+			bes2600_info(BES2600_DBG_EPTA, "epta_freeze_bitmap:0x%x, wlan:%u < %u",
+				epta_freeze_bitmap, wlan_duration, epta_freezed_wlan_duration_cfg);
+			wlan_duration = epta_freezed_wlan_duration_cfg;
+			bt_duration = EPTA_FREEZE_TDD_PERIOD - epta_freezed_wlan_duration_cfg;
+		}
+	}
+
+	/* epta disconnect status,force use HW epta */
+	if (epta_conn_state == EPTA_STATE_WIFI_DISCONNECTED && hw_epta_enable == 0)
+		hw_epta_enable = 1;
+
+	msg.wlan_duration = wlan_duration;
+	msg.bt_duration = bt_duration;
+	msg.hw_epta_enable = hw_epta_enable;
+
+	return wsm_epta_cmd(hw_priv, &msg);
+}
+
+static int coex_epta_freeze_update(struct bes2600_common *hw_priv)
+{
+	struct wsm_epta_msg msg;
+	int i = 0;
+	int max_freeze = 0;
+
+	if (hw_priv == NULL) {
+		bes2600_dbg(BES2600_DBG_EPTA, "hw_priv is NULL\n");
+		return -1;
+	}
+
+	bes2600_dbg(BES2600_DBG_EPTA, "epta update. bitmap:0x%x. fw:%d",
+		epta_freeze_bitmap, epta_freezed_wlan_duration_cfg);
+
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, %d", __FUNCTION__, hw_epta_enable_cfg);
+
+	/* Exit freeze mode and recover the configuration of epta module; */
+	if (epta_freeze_bitmap == 0) {
+		epta_freezed_wlan_duration_cfg = 0;
+		return -1;
+	}
+
+	/* Enter freeze mode and set the configuration of the epta module; */
+	/* select max wifi freeze value */
+	for (i = 0; i < EPTA_FREEZE_MAX; i++) {
+		if (max_freeze < epta_freezed_wlan_duration[i])
+			max_freeze = epta_freezed_wlan_duration[i];
+	}
+
+	/* same cfg don't change it */
+	if (max_freeze == epta_freezed_wlan_duration_cfg)
+		return 0;
+
+	epta_freezed_wlan_duration_cfg = max_freeze;
+
+	/* only support epta_freezed_wlan_duration_cfg > wlan_duration_cfg */
+	// wlan_duration_cfg may be override by wsm_epta_cmd
+	// if (max_freeze <= wlan_duration_cfg) {
+	// 	return 0;
+	// }
+	msg.wlan_duration = max_freeze;
+	msg.bt_duration = EPTA_FREEZE_TDD_PERIOD - max_freeze;
+	msg.hw_epta_enable = 0x00;
+
+	return wsm_epta_cmd(hw_priv, &msg);
+}
+
+/*
+ * coex_epta_freeze
+ * freeze coex duration for specific senario
+ * @wlan_duration: 20~100ms
+ * @type:
+ *  EPTA_FREEZE_CONENCTING,
+ *  EPTA_FREEZE_TTS,
+ *  EPTA_FREEZE_THP,
+ * note: the value of wlan_duration should be less than 100000.
+ */
+int coex_epta_freeze(struct bes2600_common *hw_priv, int wlan_duration, uint32_t type)
+{
+	uint32_t i;
+
+	epta_freeze_bitmap |= type;
+
+	for (i = 0; i < EPTA_FREEZE_MAX; ++i) {
+		if (type & (1 << i))
+			epta_freezed_wlan_duration[i] = wlan_duration;
+	}
+	/* reset epta value */
+	epta_ps_mode = 0;
+	epta_adjust_cnt = 0;
+
+	return coex_epta_freeze_update(hw_priv);
+}
+
+static int coex_epta_recover_update(struct bes2600_common *hw_priv)
+{
+	struct wsm_epta_msg msg;
+	int i = 0;
+	int max_freeze = 0;
+
+	if (hw_priv == NULL) {
+		bes2600_dbg(BES2600_DBG_EPTA, "hw_priv is NULL\n");
+		return -1;
+	}
+
+	bes2600_dbg(BES2600_DBG_EPTA, "epta update. bitmap:0x%x. fw:%d",
+		epta_freeze_bitmap, epta_freezed_wlan_duration_cfg);
+
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, %d", __FUNCTION__, hw_epta_enable_cfg);
+
+	/* Exit freeze mode and recover the configuration of epta module; */
+	if (epta_freeze_bitmap == 0) {
+		if (epta_freezed_wlan_duration_cfg == 0)
+			return -1;
+		epta_freezed_wlan_duration_cfg = 0;
+		// coex_set_epta_params will skip epta:0 after got_ip(use connected epta3)
+		msg.wlan_duration = wlan_duration_cfg;
+		msg.bt_duration = bt_duration_cfg;
+		msg.hw_epta_enable = hw_epta_enable_cfg;
+		return wsm_epta_cmd(hw_priv, &msg);
+	}
+
+	/* Enter freeze mode and set the configuration of the epta module; */
+	/* select max wifi freeze value */
+	for (i = 0; i < EPTA_FREEZE_MAX; i++) {
+		if (max_freeze < epta_freezed_wlan_duration[i])
+			max_freeze = epta_freezed_wlan_duration[i];
+	}
+
+	epta_freezed_wlan_duration_cfg = max_freeze;
+	msg.wlan_duration = max_freeze;
+	msg.bt_duration = EPTA_FREEZE_TDD_PERIOD - max_freeze;
+	msg.hw_epta_enable = hw_epta_enable_cfg;
+
+	return wsm_epta_cmd(hw_priv, &msg);
+}
+
+int coex_epta_recover(struct bes2600_common *hw_priv, uint32_t type)
+{
+	uint32_t i;
+
+	if (epta_freeze_bitmap == 0)
+		return 0;
+
+	if (type == EPTA_FREEZE_ALL) {
+		for (i = 0; i < EPTA_FREEZE_MAX; i++) {
+			epta_freezed_wlan_duration[i] = 0;
+		}
+		epta_freeze_bitmap = 0;
+	} else {
+		epta_freeze_bitmap &= (~type);
+		for (i = 0; i < EPTA_FREEZE_MAX; ++i) {
+			if (type & (1 << i))
+				epta_freezed_wlan_duration[i] = 0;
+		}
+	}
+	return coex_epta_recover_update(hw_priv);
+}
+
+int coex_epta_ps(struct bes2600_common *hw_priv, uint8_t enable)
+{
+	struct wsm_epta_msg msg;
+	if (hw_priv == NULL) {
+		bes2600_dbg(BES2600_DBG_EPTA, "hw_priv is NULL\n");
+		return -1;
+	}
+
+	if (enable && !epta_ps_mode) {
+		epta_ps_mode = 1;
+		msg.wlan_duration = EPTA_PS_WLAN_DURATION;
+		msg.bt_duration = EPTA_PS_BT_DURATION;
+		msg.hw_epta_enable = 0;
+		return wsm_epta_cmd(hw_priv, &msg);
+	} else if (!enable && epta_ps_mode) {
+		epta_ps_mode = 0;
+		msg.wlan_duration = wlan_duration_cfg;
+		msg.bt_duration = bt_duration_cfg;
+		msg.hw_epta_enable = 0;
+		return wsm_epta_cmd(hw_priv, &msg);
+	}
+
+	return 0;
+}
+
+int coex_epta_set_connect(struct bes2600_common *hw_priv, int wlan_duration, int bt_duration, int epta)
+{
+	struct wsm_epta_msg msg;
+	if (!hw_priv) {
+		bes2600_dbg(BES2600_DBG_EPTA, "hw_priv is NULL\n");
+		return -1;
+	}
+	if (epta != 4) {
+		msg.wlan_duration = (wlan_duration_cfg >= wlan_duration) ? wlan_duration_cfg : wlan_duration;
+		msg.bt_duration = (wlan_duration_cfg >= wlan_duration) ? bt_duration_cfg : bt_duration;
+	} else {
+		msg.wlan_duration = wlan_duration;
+		msg.bt_duration = bt_duration;
+	}
+	msg.hw_epta_enable = epta;
+	return wsm_epta_cmd(hw_priv, &msg);
+}
+
+static void coex_set_wifi_state_to_fw(struct bes2600_common *hw_priv, uint8_t epta_conn_state)
+{
+	static uint8_t last_state;
+
+	switch (epta_conn_state) {
+	case EPTA_STATE_WIFI_DISCONNECTED:
+	case EPTA_STATE_WIFI_CONNECTED:
+		if (last_state != epta_conn_state) {
+			last_state = epta_conn_state;
+			break;
+		} else {
+			return;
+		}
+	default:
+		return;
+	}
+
+	bes2600_dbg(BES2600_DBG_EPTA, "%s state%u\r", __func__, last_state);
+
+	switch (last_state) {
+	case EPTA_STATE_WIFI_DISCONNECTED:
+		wsm_wifi_status_cmd(hw_priv, (uint32_t)BWIFI_STATUS_IDLE);
+		break;
+	case EPTA_STATE_WIFI_CONNECTED:
+		wsm_wifi_status_cmd(hw_priv, (uint32_t)BWIFI_STATUS_CONNECTED);
+		break;
+	default:
+		break;
+	}
+}
+
+/* TDD mode conn status change */
+void coex_set_wifi_conn(struct bes2600_common *hw_priv, uint8_t connect_status)
+{
+	if (connect_status != EPTA_STATE_WIFI_SCAN_COMP) {
+		if (epta_conn_state == connect_status) {
+			bes2600_dbg(BES2600_DBG_EPTA, "same connect_status:%d\r", connect_status);
+			return;
+		}
+	}
+
+	if (connect_status == EPTA_STATE_WIFI_GOT_IP) {
+		if (epta_conn_state == EPTA_STATE_WIFI_DISCONNECTED || epta_conn_state == EPTA_STATE_WIFI_CONNECTING) {
+			bes2600_dbg(BES2600_DBG_EPTA, "ignore got ip in disconnected\r");
+			return;
+		}
+	}
+	epta_conn_state = connect_status;
+
+	bes2600_dbg(BES2600_DBG_EPTA, "%s connect_status=%d coex_mode=%d\r", __func__, connect_status, g_coex_mode);
+
+	coex_set_wifi_state_to_fw(hw_priv, epta_conn_state);
+
+	if (g_coex_mode &  WIFI_COEX_MODE_FDD_BIT) {
+		if (g_coex_mode &  WIFI_COEX_MODE_FDD_HYBRID_BIT) {
+			if (connect_status == EPTA_STATE_WIFI_CONNECTED) {
+				coex_epta_set_connect(hw_priv, wlan_duration_cfg, bt_duration_cfg, 3);
+			} else if (connect_status == EPTA_STATE_WIFI_DISCONNECTED) {
+				coex_epta_recover(hw_priv, EPTA_FREEZE_ALL); // wifi disconect need to recover all requests
+				/* HYBRID MODE: if wlan is disconnect, default use hw epta */
+				coex_epta_set_connect(hw_priv, 100000, 0, 1);
+			}
+		} else {
+			if (connect_status == EPTA_STATE_WIFI_CONNECTED) {
+				// set bt bad channel according to wifi channel
+				if (hw_priv->channel->band == NL80211_BAND_2GHZ)
+					wsm_epta_wifi_chan_cmd(hw_priv, hw_priv->channel->hw_value, hw_priv->ht_info.channel_type);
+			} else if (connect_status == EPTA_STATE_WIFI_DISCONNECTED) {
+				coex_epta_recover(hw_priv, EPTA_FREEZE_ALL); // wifi disconect need to recover all requests
+				coex_epta_set_connect(hw_priv, 100000, 0, 1);
+				wsm_epta_wifi_chan_cmd(hw_priv, 0, 0);
+			}
+		}
+	} else {
+		int wlan_tdd_duration = EPTA_TDD_CONNECT_WIFI;
+		int bt_tdd_duration = EPTA_TDD_CONNECT_BT;
+
+		/* if wlan_duration_cfg>　EPTA_TDD_CONNECT_WIFI; chose wlan_duration_cfg, in TDD mode */
+		if (wlan_duration_cfg > EPTA_TDD_CONNECT_WIFI) {
+			wlan_tdd_duration = wlan_duration_cfg;
+			bt_tdd_duration = bt_duration_cfg;
+		}
+		if (connect_status == EPTA_STATE_WIFI_CONNECTED) {
+			coex_epta_set_connect(hw_priv, wlan_duration_cfg, bt_duration_cfg, 3);
+		} else if (connect_status == EPTA_STATE_WIFI_SCANNING) {
+			/* in scan status, only valid param 0, others wlan_tdd_duration,bt_tdd_duratio is invalid */
+			coex_epta_freeze(hw_priv, wlan_duration_cfg, EPTA_FREEZE_SCANNING);
+		} else if (connect_status == EPTA_STATE_WIFI_SCAN_COMP) {
+			coex_epta_set_connect(hw_priv, wlan_duration_cfg, bt_duration_cfg, 0);
+		} else if (connect_status == EPTA_STATE_WIFI_GOT_IP) {
+			coex_epta_set_connect(hw_priv, 20000, 80000, 3);
+			coex_epta_recover(hw_priv, EPTA_FREEZE_SCANNING | EPTA_FREEZE_CONNECTING);
+		} else if (connect_status == EPTA_STATE_WIFI_CONNECTING) {
+			coex_epta_freeze(hw_priv, wlan_tdd_duration, EPTA_FREEZE_CONNECTING);
+			if (coex_fdd_mode == 0 && bt_duration_cfg > 50000) //bt audio
+				coex_epta_set_connect(hw_priv, 30000, 15000, 4);
+		} else if (connect_status == EPTA_STATE_WIFI_DISCONNECTED) {
+			coex_epta_recover(hw_priv, EPTA_FREEZE_ALL); // wifi disconect need to recover all requests
+			/* TDD MODE: if wlan is disconnect, default use hw epta */
+			// coex_epta_set_connect(hw_priv, 100000, 0, 1);
+		} else {
+			/* do nothing */
+		}
+	}
+}
+
+bool coex_is_wifi_inactive(void)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, epta_conn_state:%d", __FUNCTION__, epta_conn_state);
+	return epta_conn_state == EPTA_STATE_WIFI_DISCONNECTED;
+}
+/*
+ * coex_set_epta_tts
+ * @tts_state: 0 - tts start, 1 - tts end
+ */
+void coex_set_epta_tts(struct bes2600_common *hw_priv, uint32_t tts_state)
+{
+	if (EPTA_MODE_CFG == 0) {
+		if (tts_state) {
+			coex_epta_recover(hw_priv, EPTA_FREEZE_TTS);
+		} else {
+			coex_epta_freeze(hw_priv, 50000, EPTA_FREEZE_TTS);
+		}
+	}
+}
+
+void coex_set_epta_thp(struct bes2600_common *hw_priv, uint32_t total_bps)
+{
+	int epta_adjust_inv = 3;
+	int wlan_tp_low;
+
+	if (coex_fdd_mode && epta_conn_state >= EPTA_STATE_WIFI_GOT_IP)
+		return;
+
+	//bes2600_dbg(BES2600_DBG_EPTA, "coex_set_epta_thp %d bt_state %d epta_freeze_bitmap=%d epta_adjust_cnt=%d coex_ps_en=%d fw=%d\n",
+	//       total_bps, coex_bt_state, epta_freeze_bitmap, epta_adjust_cnt, coex_ps_en, epta_freezed_wlan_duration_cfg);
+
+	/* sniffer mode always work with ble and tts, need adjust more quickly */
+	// wlan_tp_low = netdev_sniffer_get_stat() ? EPTA_WLAN_TP_LOW : 500;
+	wlan_tp_low = 500;
+
+	/* only need adjust in sw epta mode */
+	if (EPTA_MODE_CFG != 0)
+		return;
+
+	if ((coex_bt_state == 0) && (total_bps > EPTA_WLAN_TP_HIGH)) {
+		coex_epta_freeze(hw_priv, EPTA_ADJUST_WLAN_DURATION_HIGH, EPTA_FREEZE_THP);
+	} else if (total_bps > EPTA_WLAN_TP_MEDIUM) {
+		coex_epta_freeze(hw_priv, EPTA_ADJUST_WLAN_DURATION_MEDIUM, EPTA_FREEZE_THP);
+	} else if (total_bps > wlan_tp_low) {
+		coex_epta_freeze(hw_priv, EPTA_ADJUST_WLAN_DURATION_LOW, EPTA_FREEZE_THP);
+	} else {
+		if ((epta_freeze_bitmap & (1 << EPTA_FREEZE_THP)) &&
+			(((++epta_adjust_cnt) % epta_adjust_inv) == 0)) {
+			// recover if wifi idle 3 secs
+			epta_adjust_cnt = 0;
+			coex_epta_recover(hw_priv, EPTA_FREEZE_THP);
+		} else if (coex_ps_en && !epta_freeze_bitmap) {
+			if ((total_bps > EPTA_WLAN_TP_PS)) {
+				coex_epta_ps(hw_priv, 0);
+				epta_adjust_cnt = 0;
+			} else if ((total_bps < EPTA_WLAN_TP_PS) &&
+				   (((++epta_adjust_cnt) % epta_adjust_inv) == 0)) {
+				coex_epta_ps(hw_priv, 1);
+			}
+		}
+	}
+}
+
+// void coex_band_update(struct bes2600_common *hw_priv, enum nl80211_band band)
+// {
+// 	bes2600_info(BES2600_DBG_EPTA, "coex_band_update band:%u\n", (uint32_t)band);
+// }
+
+void coex_rssi_update(struct bes2600_common *hw_priv, int rssi, int channel, int connected)
+{
+	bool fdd_en = 0;
+
+	if (g_coex_mode == 0 || // tdd
+		g_coex_mode == (WIFI_COEX_MODE_FDD_HYBRID_BIT | WIFI_COEX_MODE_FDD_BIT)) {
+
+		bes2600_info(BES2600_DBG_EPTA, "coex_rssi_update rssi:%d, ch:%d, con:%d\n",
+			rssi, channel, connected);
+		if (channel > 14) {
+			fdd_en = 1;
+		///TODO: HYBRID mode
+		// } else if (rssi >= COEX_FDD_RSSI_THR) {
+		// 	fdd_en = 1;
+		// } else if (rssi < COEX_TDD_RSSI_THR) {
+		// 	fdd_en = 0;
+		}
+
+		if (fdd_en != coex_fdd_mode) {
+			coex_fdd_mode = fdd_en;
+			coex_set_epta_params(hw_priv, wlan_duration_cfg, bt_duration_cfg, hw_epta_enable_cfg);
+		}
+	}
+}
+
+void coex_set_bt_state(struct bes2600_common *hw_priv, int state)
+{
+	bes2600_info(BES2600_DBG_EPTA, "coex_set_bt_state %d\n", state);
+	coex_bt_state = state;
+}
+
+void coex_peroid_handle(struct bes2600_common *hw_priv, int connected, int rssi, int channel, uint32_t tp)
+{
+	if (connected) {
+		/*
+		 * Adjust wifi/bt duration dynamically according to throughput for a better performance;
+		 */
+		coex_set_epta_thp(hw_priv, tp);
+	}
+
+	if (g_coex_mode == 0 || // tdd
+		g_coex_mode == (WIFI_COEX_MODE_FDD_HYBRID_BIT | WIFI_COEX_MODE_FDD_BIT)) {
+		coex_rssi_update(hw_priv, rssi, channel, connected);
+	}
+}
+
+/*
+ * set fdd or fdd hybrid
+ * 1: fdd
+ * 0: fddhybrid
+ */
+void coex_set_fdd_mode(bool fdd_mode)
+{
+	if (g_coex_mode == 0 || // tdd
+		g_coex_mode == (WIFI_COEX_MODE_FDD_HYBRID_BIT | WIFI_COEX_MODE_FDD_BIT)) { //hybrid
+		bes2600_dbg(BES2600_DBG_EPTA, "%s, %d", __FUNCTION__, fdd_mode);
+		coex_fdd_mode = fdd_mode;
+	}
+}
+
+bool coex_is_fdd_mode(void)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, %d", __FUNCTION__, coex_fdd_mode);
+	return coex_fdd_mode;
+}
+
+bool coex_is_bt_a2dp(void)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, coex_bt_state:%d", __FUNCTION__, coex_bt_state);
+	return coex_bt_state == 3;
+}
+
+bool coex_is_bt_inactive(void)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s, coex_bt_state:%d", __FUNCTION__, coex_bt_state);
+	return coex_bt_state == 0;
+}
+
+int coex_init_mode(struct bes2600_common *hw_priv, int coex_mode)
+{
+	bes2600_info(BES2600_DBG_EPTA, "coex_init_mode coex_mode %d\n", coex_mode);
+
+	g_coex_mode = coex_mode;
+
+	if (coex_mode & WIFI_COEX_MODE_FDD_BIT)
+		coex_fdd_mode = true;
+	else
+		coex_fdd_mode = false;
+
+	coex_wifi_bt_ts_thread_init(hw_priv);
+	return 0;
+}
+
+int coex_deinit_mode(struct bes2600_common *hw_priv)
+{
+	bes2600_info(BES2600_DBG_EPTA, "coex_deinit_mode\n");
+
+	coex_wifi_bt_ts_thread_deinit(hw_priv);
+
+	return 0;
+}
+
+int coex_start(struct bes2600_common *hw_priv)
+{
+	bes2600_info(BES2600_DBG_EPTA, "%s\n", __FUNCTION__);
+
+	coex_ps_en = false;
+	if (g_coex_mode & WIFI_COEX_MODE_FDD_BIT)
+		coex_fdd_mode = true;
+	else
+		coex_fdd_mode = false;
+	epta_conn_state = 0xff;
+	epta_freeze_bitmap = 0;
+	epta_freezed_wlan_duration_cfg = 0;
+	wlan_duration_cfg = 20000;
+	bt_duration_cfg = 80000;
+	hw_epta_enable_cfg = 0;
+	epta_ps_mode = 0;
+	epta_adjust_cnt = 0;
+	coex_bt_state = 0;
+
+	return 0;
+}
+
+int coex_stop(struct bes2600_common *hw_priv)
+{
+	bes2600_info(BES2600_DBG_EPTA, "%s\n", __FUNCTION__);
+	return 0;
+}
diff --git a/drivers/staging/bes2600/epta_coex.h b/drivers/staging/bes2600/epta_coex.h
new file mode 100755
index 000000000000..05f8395d503e
--- /dev/null
+++ b/drivers/staging/bes2600/epta_coex.h
@@ -0,0 +1,82 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __EPTA_COEX_H__
+#define __EPTA_COEX_H__
+
+#include <linux/types.h>
+#include <linux/nl80211.h>
+
+#include "bes2600.h"
+
+#define WIFI_COEX_MODE_FDD_BIT          (1<<0)
+#define WIFI_COEX_MODE_FDD_HYBRID_BIT   (1<<1)
+
+enum bwifi_epta_state {
+	EPTA_STATE_WIFI_DISCONNECTED     = 0,
+	EPTA_STATE_WIFI_SCANNING         = 1,
+	EPTA_STATE_WIFI_SCAN_COMP		 = 2,
+	EPTA_STATE_WIFI_CONNECTING       = 3,
+	EPTA_STATE_WIFI_CONNECTED        = 4,
+	EPTA_STATE_WIFI_GOT_IP           = 5,
+	EPTA_STATE_WIFI_TTS_START        = 6,
+	EPTA_STATE_WIFI_TTS_END          = 7,
+
+	EPTA_STATE_NUM
+};
+
+/* max FREEZE BIT */
+#define EPTA_FREEZE_MAX 32
+typedef enum {
+	EPTA_FREEZE_SCANNING = 1 << 0,
+	EPTA_FREEZE_CONNECTING = 1 << 1,
+	EPTA_FREEZE_TTS = 1 << 2,
+	EPTA_FREEZE_THP = 1 << 3,
+	/* clear all FREEZE BIT */
+	EPTA_FREEZE_ALL
+} EPTA_FREEZE_TYPE_T;
+
+#define COEX_TDD_RSSI_THR                 (-15)
+#define COEX_FDD_RSSI_THR                 (-10)
+
+#define EPTA_PS_WLAN_DURATION             (20000)
+#define EPTA_PS_BT_DURATION               (80000)
+#define EPTA_ADJUST_WLAN_DURATION_HIGH    (80000)
+#define EPTA_ADJUST_WLAN_DURATION_MEDIUM  (55000)
+#define EPTA_ADJUST_WLAN_DURATION_LOW     (40000)
+#define EPTA_WLAN_TP_HIGH                 (4000)
+#define EPTA_WLAN_TP_MEDIUM               (2000)
+#define EPTA_WLAN_TP_LOW                  (100)
+#define EPTA_WLAN_TP_PS                   (50)
+#define EPTA_FREEZE_TDD_PERIOD	          (102400)
+#define EPTA_TDD_CONNECT_WIFI             (50000)
+#define EPTA_TDD_CONNECT_BT               (50000)
+
+int coex_set_epta_params(struct bes2600_common *hw_priv, int wlan_duraiton, int bt_duration, int hw_epta_enable);
+void coex_peroid_handle(struct bes2600_common *hw_priv, int connected, int rssi, int channel, uint32_t tp);
+void coex_set_bt_state(struct bes2600_common *hw_priv, int state);
+void coex_set_wifi_conn(struct bes2600_common *hw_priv, uint8_t connect_status);
+void coex_set_epta_tts(struct bes2600_common *hw_priv, uint32_t tts_state);
+int coex_init_mode(struct bes2600_common *hw_priv, int coex_mode);
+int coex_deinit_mode(struct bes2600_common *hw_priv);
+int coex_start(struct bes2600_common *hw_priv);
+int coex_stop(struct bes2600_common *hw_priv);
+
+void coex_rssi_update(struct bes2600_common *hw_priv, int rssi, int channel, int connected);
+// void coex_band_update(struct bes2600_common *hw_priv, enum nl80211_band band);
+bool coex_is_fdd_mode(void);
+void coex_set_fdd_mode(bool fdd_mode);
+bool coex_is_bt_a2dp(void);
+bool coex_is_bt_inactive(void);
+bool coex_is_wifi_inactive(void);
+
+#endif
+
+
diff --git a/drivers/staging/bes2600/epta_request.c b/drivers/staging/bes2600/epta_request.c
new file mode 100755
index 000000000000..44676dcbc6d7
--- /dev/null
+++ b/drivers/staging/bes2600/epta_request.c
@@ -0,0 +1,650 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/list.h>
+
+#include "epta_coex.h"
+#include "epta_request.h"
+
+#define EPTA_PERIOD_TIME					102400
+
+#define BT_TIME_MAX							80000
+
+#define BT_SHUTDOWN_TIME					0
+#define BT_SHUTDOWN_MIN_TIME				0
+#define BT_DISCONNECTED_TIME				0
+#define BT_DISCONNECTED_MIN_TIME			0
+#define BT_CONNECTING_TIME					60000
+#define BT_CONNECTING_MIN_TIME				0
+#define BT_CONNECTED_TIME					0
+#define BT_CONNECTED_MIN_TIME				25000
+#define BT_CONNECTED_SNIFF_TIME				0
+#define BT_CONNECTED_SNIFF_MIN_TIME			20000
+
+#define BT_BOTHSCAN_DISABLE_TIME			0
+#define BT_BOTHSCAN_DISABLE_MIN_TIME		0
+#define BT_BOTHSCAN_ENABLE_TIME				0
+#define BT_BOTHSCAN_ENABLE_MIN_TIME			20000
+#define BT_PSCAN_ENABLE_TIME				0
+#define BT_PSCAN_ENABLE_MIN_TIME			20000
+#define BT_ISCAN_ENABLE_TIME				0
+#define BT_ISCAN_ENABLE_MIN_TIME			20000
+
+#define BT_AUDIO_NONE_TIME					0
+#define BT_AUDIO_NONE_MIN_TIME				0
+#define BT_AUDIO_A2DP_TIME					60000
+#define BT_AUDIO_A2DP_MIN_TIME				0
+#define BT_AUDIO_SCO_TIME					80000
+#define BT_AUDIO_SCO_MIN_TIME				0
+
+#define BT_INQ_START_TIME					20000
+#define BT_INQ_START_MIN_TIME				30000
+#define BT_INQ_STOP_TIME					0
+#define BT_INQ_STOP_MIN_TIME				0
+
+#define BT_LE_SCAN_START_TIME				20000
+#define BT_LE_SCAN_START_MIN_TIME			30000
+#define BT_LE_SCAN_STOP_TIME				0
+#define BT_LE_SCAN_STOP_MIN_TIME			0
+
+#define BT_LE_ADV_START_TIME				20000
+#define BT_LE_ADV_START_MIN_TIME			40000
+#define BT_LE_ADV_STOP_TIME					0
+#define BT_LE_ADV_STOP_MIN_TIME				0
+
+#define BT_LE_CONNECTED_TIME				0
+#define BT_LE_CONNECTED_MIN_TIME			50000
+#define BT_LE_DISCONNECTED_TIME				0
+#define BT_LE_DISCONNECTED_MIN_TIME			0
+
+// BIT[2:0]
+#define BT_REQUEST_STATUS_SHIFT       0
+#define BT_REQUEST_STATUS_MASK        (0x7 << BT_REQUEST_STATUS_SHIFT)
+#define BT_REQUEST_STATUS_VALUE(n)    (((n) & BT_REQUEST_STATUS_MASK) >> BT_REQUEST_STATUS_SHIFT)
+
+// BIT[5:3]
+#define BT_REQUEST_SCAN_SHIFT         3
+#define BT_REQUEST_SCAN_MASK          (0x7 << BT_REQUEST_SCAN_SHIFT)
+#define BT_REQUEST_SCAN_VALUE(n)      (((n) & BT_REQUEST_SCAN_MASK) >> BT_REQUEST_SCAN_SHIFT)
+
+// BIT[8:6]
+#define BT_REQUEST_AUDIO_SHIFT        6
+#define BT_REQUEST_AUDIO_MASK         (0x7 << BT_REQUEST_AUDIO_SHIFT)
+#define BT_REQUEST_AUDIO_VALUE(n)     (((n) & BT_REQUEST_AUDIO_MASK) >> BT_REQUEST_AUDIO_SHIFT)
+
+// BIT[10:9]
+#define BT_REQUEST_INQ_SHIFT          9
+#define BT_REQUEST_INQ_MASK           (0x3 << BT_REQUEST_INQ_SHIFT)
+#define BT_REQUEST_INQ_VALUE(n)       (((n) & BT_REQUEST_INQ_MASK) >> BT_REQUEST_INQ_SHIFT)
+
+// BIT[12:11]
+#define BT_REQUEST_LE_SCAN_SHIFT      11
+#define BT_REQUEST_LE_SCAN_MASK       (0x3 << BT_REQUEST_LE_SCAN_SHIFT)
+#define BT_REQUEST_LE_SCAN_VALUE(n)   (((n) & BT_REQUEST_LE_SCAN_MASK) >> BT_REQUEST_LE_SCAN_SHIFT)
+
+// BIT[15:13]
+#define BT_REQUEST_LE_ADV_SHIFT       13
+#define BT_REQUEST_LE_ADV_MASK        (0x7 << BT_REQUEST_LE_ADV_SHIFT)
+#define BT_REQUEST_LE_ADV_VALUE(n)    (((n) & BT_REQUEST_LE_ADV_MASK) >> BT_REQUEST_LE_ADV_SHIFT)
+
+// BIT[17:16]
+#define BT_REQUEST_LE_STATUS_SHIFT    16
+#define BT_REQUEST_LE_STATUS_MASK     (0x3 << BT_REQUEST_LE_STATUS_SHIFT)
+#define BT_REQUEST_LE_STATUS_VALUE(n) (((n) & BT_REQUEST_LE_STATUS_MASK) >> BT_REQUEST_LE_STATUS_SHIFT)
+
+typedef enum {
+	BWIFI_BT_STATUS_SHUTDOWN          = 0,
+	BWIFI_BT_STATUS_DISCONNECTED      = 1,
+	BWIFI_BT_STATUS_CONNECTING        = 2,
+	BWIFI_BT_STATUS_CONNECTED_SNIFF   = 3,//
+	BWIFI_BT_STATUS_CONNECTED         = 4,//
+} BWIFI_BT_STATUS_T;
+
+typedef enum {
+	BWIFI_BT_BOTHSCAN_DISABLE         = 0,
+	BWIFI_BT_BOTHSCAN_ENABLE          = 1,
+	BWIFI_BT_PSCAN_ENABLE             = 2,
+	BWIFI_BT_ISCAN_ENABLE             = 3,
+} BWIFI_BT_SCAN_T;
+
+typedef enum {
+	BWIFI_BT_AUDIO_NONE               = 0,
+	BWIFI_BT_AUDIO_A2DP               = 1,
+	BWIFI_BT_AUDIO_SCO                = 2,
+} BWIFI_BT_AUDIO_T;
+
+typedef enum {
+	BWIFI_BT_INQ_STOP                 = 0,//
+	BWIFI_BT_INQ_START                = 1,//
+} BWIFI_BT_INQ_T;
+
+typedef enum {
+	BWIFI_LE_SCAN_STOP                = 0,//
+	BWIFI_LE_SCAN_START               = 1,//
+} BWIFI_BT_LE_SCAN_T;
+
+typedef enum {
+	BWIFI_LE_ADV_STOP                 = 0,//
+	BWIFI_LE_ADV_START                = 1,//
+} BWIFI_BT_LE_ADV_T;
+
+typedef enum {
+	BWIFI_LE_DISCONNECTED             = 0,//
+	BWIFI_LE_CONNECTED                = 1,//
+} BWIFI_BT_LE_STATUS_T;
+
+enum COEX_BT_OPER_T {
+	COEX_BT_OPER_STATUS,
+	COEX_BT_OPER_SCAN,
+	COEX_BT_OPER_AUDIO,
+	COEX_BT_OPER_INQ,
+	COEX_BT_OPER_LE_SCAN,
+	COEX_BT_OPER_LE_ADV,
+	COEX_BT_OPER_LE_STATUS,
+
+	COEX_BT_OPER_NUM,
+};
+
+union COEX_BT_OPER_TYPE_T {
+	BWIFI_BT_STATUS_T status;
+	BWIFI_BT_SCAN_T scan;
+	BWIFI_BT_AUDIO_T audio;
+	BWIFI_BT_INQ_T inq;
+	BWIFI_BT_LE_SCAN_T le_scan;
+	BWIFI_BT_LE_ADV_T le_adv;
+	BWIFI_BT_LE_STATUS_T le_status;
+};
+
+struct COEX_BT_OPER_TIME_T {
+	enum COEX_BT_OPER_T oper;
+	union COEX_BT_OPER_TYPE_T type;
+	uint32_t time;
+	uint32_t min_time;
+};
+
+struct COEX_BT_OPER_TIME_T g_coex_bt_oper[COEX_BT_OPER_NUM];
+
+static void coex_bt_time_init(void)
+{
+	memset(g_coex_bt_oper, 0, sizeof(g_coex_bt_oper));
+	g_coex_bt_oper[COEX_BT_OPER_STATUS].type.status = BWIFI_BT_STATUS_SHUTDOWN;
+	g_coex_bt_oper[COEX_BT_OPER_SCAN].type.scan = BWIFI_BT_BOTHSCAN_DISABLE;
+	g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_NONE;
+	g_coex_bt_oper[COEX_BT_OPER_INQ].type.inq = BWIFI_BT_INQ_STOP;
+	g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].type.le_scan = BWIFI_LE_SCAN_STOP;
+	g_coex_bt_oper[COEX_BT_OPER_LE_ADV].type.le_adv = BWIFI_LE_ADV_STOP;
+	g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].type.le_status = BWIFI_LE_DISCONNECTED;
+}
+
+static uint32_t coex_calc_bt_time(void)
+{
+	uint32_t i;
+	uint32_t time = 0, min_time = 0;
+
+	for (i = 0; i < COEX_BT_OPER_NUM; ++i) {
+		time += g_coex_bt_oper[i].time;
+		if (min_time < g_coex_bt_oper[i].min_time)
+			min_time = g_coex_bt_oper[i].min_time;
+	}
+
+	bes2600_dbg(BES2600_DBG_EPTA, "%s time:%u, min_time:%u", __func__, time, min_time);
+	time = time < min_time ? min_time : time;
+	return time < BT_TIME_MAX ? time : BT_TIME_MAX;
+}
+
+void coex_calc_wifi_scan_time(uint32_t *min_chan, uint32_t *max_chan)
+{
+	uint32_t time = coex_calc_bt_time();
+
+	if (time == 0) {
+		*min_chan = 90;
+		*max_chan = 90;
+	} else if (time < 40000) {
+		*min_chan = 50;
+		*max_chan = 110;
+	} else if (time < 60000) {
+		*min_chan = 40;
+		*max_chan = 110;
+	} else if (time < 80000) {
+		*min_chan = 30;
+		*max_chan = 120;
+	} else {
+		*min_chan = 30;
+		*max_chan = 130;
+	}
+}
+
+static void coex_bt_state_notify(struct bes2600_common *hw_priv)
+{
+	int32_t wifi_dur, bt_dur, mode;
+
+	bt_dur = coex_calc_bt_time();
+	wifi_dur = EPTA_PERIOD_TIME - bt_dur;
+	mode = 0;
+	coex_set_epta_params(hw_priv, wifi_dur, bt_dur, mode);
+}
+
+static void coex_bt_oper_status(struct bes2600_common *hw_priv, BWIFI_BT_STATUS_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_BT_STATUS_SHUTDOWN:
+		coex_bt_time_init();
+		break;
+	case BWIFI_BT_STATUS_DISCONNECTED:
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].type.status = BWIFI_BT_STATUS_DISCONNECTED;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].time = BT_DISCONNECTED_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].min_time = BT_DISCONNECTED_MIN_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_NONE;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].time = BT_AUDIO_NONE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].min_time = BT_AUDIO_NONE_MIN_TIME;
+		break;
+	case BWIFI_BT_STATUS_CONNECTING:
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].type.status = BWIFI_BT_STATUS_CONNECTING;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].time = BT_CONNECTING_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].min_time = BT_CONNECTING_MIN_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_NONE;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].time = BT_AUDIO_NONE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].min_time = BT_AUDIO_NONE_MIN_TIME;
+		break;
+	case BWIFI_BT_STATUS_CONNECTED:
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].type.status = BWIFI_BT_STATUS_CONNECTED;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].time = BT_CONNECTED_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].min_time = BT_CONNECTED_MIN_TIME;
+		break;
+	case BWIFI_BT_STATUS_CONNECTED_SNIFF:
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].type.status = BWIFI_BT_STATUS_CONNECTED_SNIFF;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].time = BT_CONNECTED_SNIFF_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_STATUS].min_time = BT_CONNECTED_SNIFF_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_scan(struct bes2600_common *hw_priv, BWIFI_BT_SCAN_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_BT_BOTHSCAN_DISABLE:
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].type.scan = BWIFI_BT_BOTHSCAN_DISABLE;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].time = BT_BOTHSCAN_DISABLE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].min_time = BT_BOTHSCAN_DISABLE_MIN_TIME;
+		break;
+	case BWIFI_BT_BOTHSCAN_ENABLE:
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].type.scan = BWIFI_BT_BOTHSCAN_ENABLE;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].time = BT_BOTHSCAN_ENABLE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].min_time = BT_BOTHSCAN_ENABLE_MIN_TIME;
+		break;
+	case BWIFI_BT_PSCAN_ENABLE:
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].type.scan = BWIFI_BT_PSCAN_ENABLE;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].time = BT_PSCAN_ENABLE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].min_time = BT_PSCAN_ENABLE_MIN_TIME;
+		break;
+	case BWIFI_BT_ISCAN_ENABLE:
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].type.scan = BWIFI_BT_ISCAN_ENABLE;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].time = BT_ISCAN_ENABLE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_SCAN].min_time = BT_ISCAN_ENABLE_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_audio(struct bes2600_common *hw_priv, BWIFI_BT_AUDIO_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_BT_AUDIO_NONE:
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_NONE;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].time = BT_AUDIO_NONE_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].min_time = BT_AUDIO_NONE_MIN_TIME;
+		break;
+	case BWIFI_BT_AUDIO_A2DP:
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_A2DP;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].time = BT_AUDIO_A2DP_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].min_time = BT_AUDIO_A2DP_MIN_TIME;
+		break;
+	case BWIFI_BT_AUDIO_SCO:
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].type.audio = BWIFI_BT_AUDIO_SCO;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].time = BT_AUDIO_SCO_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_AUDIO].min_time = BT_AUDIO_SCO_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_inq(struct bes2600_common *hw_priv, BWIFI_BT_INQ_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_BT_INQ_START:
+		g_coex_bt_oper[COEX_BT_OPER_INQ].type.inq = BWIFI_BT_INQ_START;
+		g_coex_bt_oper[COEX_BT_OPER_INQ].time = BT_INQ_START_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_INQ].min_time = BT_INQ_START_MIN_TIME;
+		break;
+	case BWIFI_BT_INQ_STOP:
+		g_coex_bt_oper[COEX_BT_OPER_INQ].type.inq = BWIFI_BT_INQ_STOP;
+		g_coex_bt_oper[COEX_BT_OPER_INQ].time = BT_INQ_STOP_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_INQ].min_time = BT_INQ_STOP_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_le_scan(struct bes2600_common *hw_priv, BWIFI_BT_LE_SCAN_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_LE_SCAN_START:
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].type.le_scan = BWIFI_LE_SCAN_START;
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].time = BT_LE_SCAN_START_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].min_time = BT_LE_SCAN_START_MIN_TIME;
+		break;
+	case BWIFI_LE_SCAN_STOP:
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].type.le_scan = BWIFI_LE_SCAN_STOP;
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].time = BT_LE_SCAN_STOP_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_SCAN].min_time = BT_LE_SCAN_STOP_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_le_adv(struct bes2600_common *hw_priv, BWIFI_BT_LE_ADV_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_LE_ADV_START:
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].type.le_adv = BWIFI_LE_ADV_START;
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].time = BT_LE_ADV_START_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].min_time = BT_LE_ADV_START_MIN_TIME;
+		break;
+	case BWIFI_LE_ADV_STOP:
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].type.le_adv = BWIFI_LE_ADV_STOP;
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].time = BT_LE_ADV_STOP_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_ADV].min_time = BT_LE_ADV_STOP_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static void coex_bt_oper_le_status(struct bes2600_common *hw_priv, BWIFI_BT_LE_STATUS_T type)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s type:%d", __func__, type);
+
+	switch (type) {
+	case BWIFI_LE_CONNECTED:
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].type.le_status = BWIFI_LE_CONNECTED;
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].time = BT_LE_CONNECTED_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].min_time = BT_LE_CONNECTED_MIN_TIME;
+		break;
+	case BWIFI_LE_DISCONNECTED:
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].type.le_status = BWIFI_LE_DISCONNECTED;
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].time = BT_LE_DISCONNECTED_TIME;
+		g_coex_bt_oper[COEX_BT_OPER_LE_STATUS].min_time = BT_LE_DISCONNECTED_MIN_TIME;
+		break;
+	default:
+		bes2600_err(BES2600_DBG_EPTA, "%s type error:%d", __func__, type);
+		break;
+	}
+}
+
+static int coex_wifi_state_notify(struct bes2600_common *hw_priv, enum bwifi_epta_state state)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s state:%d", __func__, state);
+	switch (state) {
+	case EPTA_STATE_WIFI_DISCONNECTED:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_SCANNING:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_SCAN_COMP:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_CONNECTING:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_CONNECTED:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_GOT_IP:
+		coex_set_wifi_conn(hw_priv, state);
+		break;
+	case EPTA_STATE_WIFI_TTS_START:
+		coex_set_epta_tts(hw_priv, 0);
+		break;
+	case EPTA_STATE_WIFI_TTS_END:
+		coex_set_epta_tts(hw_priv, 1);
+		break;
+	default:
+		return -1;
+	}
+	return 0;
+}
+
+static void coex_wifi_idle(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(false);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_DISCONNECTED);
+}
+
+static void coex_wifi_scanning(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(false); //scan use tdd
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_SCANNING);
+}
+
+static void coex_wifi_scan_comp(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_SCAN_COMP);
+}
+
+static void coex_wifi_connecting(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(false);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_CONNECTING);
+}
+
+static void coex_wifi_connecting_5g(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(true);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_CONNECTING);
+}
+
+static void coex_wifi_connected(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_CONNECTED);
+}
+
+static void coex_wifi_connected_5g(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(true);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_CONNECTED);
+}
+
+static void coex_wifi_got_ip(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_GOT_IP);
+}
+
+static void coex_wifi_got_ip_5g(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(true); // used for scan -> got ip 5g
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_GOT_IP);
+}
+
+static void coex_wifi_disconnecting(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+}
+
+static void coex_wifi_disconnected(struct bes2600_common *hw_priv, BWIFI_STATUS_T value)
+{
+	bes2600_dbg(BES2600_DBG_EPTA, "%s", __func__);
+	coex_set_fdd_mode(false);
+	coex_wifi_state_notify(hw_priv, EPTA_STATE_WIFI_DISCONNECTED);
+}
+
+static int coex_wifi_bt_ts_request(struct bes2600_common *hw_priv, COEX_TS_TYPE_T type, uint32_t value)
+{
+	COEX_WIFI_BT_TS_T *wifi_bt_ts_event;
+
+	bes2600_info(BES2600_DBG_EPTA, "%s type:%u, value:0x%x", __func__, type, value);
+
+	if (atomic_read(&hw_priv->netdevice_start) == 0) {
+		bes2600_info(BES2600_DBG_EPTA, "net down. skip");
+		return 0;
+	}
+
+	/* called from spin lock vif_lock context */
+	wifi_bt_ts_event = kmalloc(sizeof(COEX_WIFI_BT_TS_T), GFP_ATOMIC);
+	if (wifi_bt_ts_event == NULL) {
+		bes2600_err(BES2600_DBG_EPTA, "ts_event: malloc fail");
+		return -ENOMEM;
+	}
+
+	INIT_LIST_HEAD(&wifi_bt_ts_event->node);
+	wifi_bt_ts_event->type = type;
+	wifi_bt_ts_event->value = value;
+
+	spin_lock(&hw_priv->coex_event_lock);
+	list_add_tail(&wifi_bt_ts_event->node, &hw_priv->coex_event_list);
+	spin_unlock(&hw_priv->coex_event_lock);
+
+	schedule_work(&hw_priv->coex_work);
+
+	return 0;
+}
+
+void bbt_change_current_status(struct bes2600_common *hw_priv, uint32_t new_status)
+{
+	coex_wifi_bt_ts_request(hw_priv, COEX_TS_TYPE_BT, new_status);
+}
+
+void bwifi_change_current_status(struct bes2600_common *hw_priv, BWIFI_STATUS_T new_status)
+{
+	coex_wifi_bt_ts_request(hw_priv, COEX_TS_TYPE_WIFI, new_status);
+}
+
+static void coex_wifi_bt_ts_cb(struct bes2600_common *hw_priv, COEX_WIFI_BT_TS_T *evt)
+{
+	if (evt->type == COEX_TS_TYPE_BT) {
+		coex_bt_oper_scan(hw_priv, (BWIFI_BT_SCAN_T)BT_REQUEST_SCAN_VALUE(evt->value));
+		coex_bt_oper_audio(hw_priv, (BWIFI_BT_AUDIO_T)BT_REQUEST_AUDIO_VALUE(evt->value));
+		coex_bt_oper_inq(hw_priv, (BWIFI_BT_INQ_T)BT_REQUEST_INQ_VALUE(evt->value));
+		coex_bt_oper_le_scan(hw_priv, (BWIFI_BT_LE_SCAN_T)BT_REQUEST_LE_SCAN_VALUE(evt->value));
+		coex_bt_oper_le_adv(hw_priv, (BWIFI_BT_LE_ADV_T)BT_REQUEST_LE_ADV_VALUE(evt->value));
+		coex_bt_oper_le_status(hw_priv, (BWIFI_BT_LE_STATUS_T)BT_REQUEST_LE_STATUS_VALUE(evt->value));
+		// process BT STATUS in the end
+		coex_bt_oper_status(hw_priv, (BWIFI_BT_STATUS_T)BT_REQUEST_STATUS_VALUE(evt->value));
+		coex_bt_state_notify(hw_priv);
+	} else if (evt->type == COEX_TS_TYPE_WIFI) {
+		switch (evt->value) {
+		case BWIFI_STATUS_IDLE:
+			coex_wifi_idle(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_SCANNING:
+			coex_wifi_scanning(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_SCANNING_COMP:
+			coex_wifi_scan_comp(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_CONNECTING:
+			coex_wifi_connecting(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_CONNECTING_5G:
+			coex_wifi_connecting_5g(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_CONNECTED:
+			coex_wifi_connected(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_CONNECTED_5G:
+			coex_wifi_connected_5g(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_GOT_IP:
+			coex_wifi_got_ip(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_GOT_IP_5G:
+			coex_wifi_got_ip_5g(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_DISCONNECTING:
+			coex_wifi_disconnecting(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		case BWIFI_STATUS_DISCONNECTED:
+			coex_wifi_disconnected(hw_priv, (BWIFI_STATUS_T)evt->value);
+			break;
+		default:
+			bes2600_err(BES2600_DBG_EPTA, "UNKNOWN WIFI type %d", evt->value);
+			break;
+		}
+	} else {
+		bes2600_err(BES2600_DBG_EPTA, "UNKNOWN EPTA type %d, %d", evt->type, evt->value);
+	}
+}
+
+static void coex_wifi_bt_ts_thread(struct work_struct *work)
+{
+	COEX_WIFI_BT_TS_T *coex_event;
+	struct bes2600_common *hw_priv = container_of(work, struct bes2600_common, coex_work);
+
+	spin_lock(&hw_priv->coex_event_lock);
+	while (!list_empty(&hw_priv->coex_event_list)) {
+		coex_event = list_first_entry(&hw_priv->coex_event_list, COEX_WIFI_BT_TS_T, node);
+		spin_unlock(&hw_priv->coex_event_lock);
+		coex_wifi_bt_ts_cb(hw_priv, coex_event);
+		list_del(&coex_event->node);
+		kfree(coex_event);
+
+		spin_lock(&hw_priv->coex_event_lock);
+	}
+	spin_unlock(&hw_priv->coex_event_lock);
+}
+
+void coex_wifi_bt_ts_thread_init(struct bes2600_common *hw_priv)
+{
+	coex_bt_time_init();
+
+	INIT_WORK(&hw_priv->coex_work, coex_wifi_bt_ts_thread);
+	INIT_LIST_HEAD(&hw_priv->coex_event_list);
+	spin_lock_init(&hw_priv->coex_event_lock);
+}
+
+void coex_wifi_bt_ts_thread_deinit(struct bes2600_common *hw_priv)
+{
+	cancel_work_sync(&hw_priv->coex_work);
+}
diff --git a/drivers/staging/bes2600/epta_request.h b/drivers/staging/bes2600/epta_request.h
new file mode 100755
index 000000000000..f0217c2c859d
--- /dev/null
+++ b/drivers/staging/bes2600/epta_request.h
@@ -0,0 +1,52 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef EPTA_REQUEST_H
+#define EPTA_REQUEST_H
+
+#include "linux/list.h"
+#include "bes2600.h"
+
+typedef enum {
+	BWIFI_STATUS_IDLE                 = 0,
+	BWIFI_STATUS_DISCONNECTING        = 1,
+	BWIFI_STATUS_SCANNING             = 2,
+	BWIFI_STATUS_CONNECTING           = 3,
+	BWIFI_STATUS_WPS_CONNECTING       = 4,
+	BWIFI_STATUS_CONNECTED            = 5,
+	BWIFI_STATUS_DHCPING              = 6,
+	BWIFI_STATUS_GOT_IP               = 7,
+	/* Warning: don't change enum value above, it's aligned with fw */
+
+	BWIFI_STATUS_CONNECTING_5G        = 8,
+	BWIFI_STATUS_CONNECTED_5G         = 9,
+	BWIFI_STATUS_DISCONNECTED         = 10,
+	BWIFI_STATUS_GOT_IP_5G            = 11,
+	BWIFI_STATUS_SCANNING_5G          = 12,
+	BWIFI_STATUS_SCANNING_COMP        = 13,
+} BWIFI_STATUS_T;
+
+typedef enum {
+	COEX_TS_TYPE_BT,
+	COEX_TS_TYPE_WIFI,
+} COEX_TS_TYPE_T;
+
+typedef struct {
+	struct list_head node;
+	COEX_TS_TYPE_T type;
+	uint32_t value;
+} COEX_WIFI_BT_TS_T;
+
+void bbt_change_current_status(struct bes2600_common *hw_priv, uint32_t new_status);
+void bwifi_change_current_status(struct bes2600_common *hw_priv, BWIFI_STATUS_T new_status);
+void coex_wifi_bt_ts_thread_init(struct bes2600_common *hw_priv);
+void coex_wifi_bt_ts_thread_deinit(struct bes2600_common *hw_priv);
+void coex_calc_wifi_scan_time(uint32_t *min_chan, uint32_t *max_chan);
+#endif /*EPTA_REQUEST_H*/
\ No newline at end of file
diff --git a/drivers/staging/bes2600/fwio.c b/drivers/staging/bes2600/fwio.c
new file mode 100755
index 000000000000..80591e506e3f
--- /dev/null
+++ b/drivers/staging/bes2600/fwio.c
@@ -0,0 +1,33 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+
+#include "bes2600.h"
+#include "fwio.h"
+#include "hwio.h"
+#include "sbus.h"
+#include "bh.h"
+
+extern int bes2600_load_firmware_sdio(struct sbus_ops *ops, struct sbus_priv *priv);
+
+int bes2600_load_firmware(struct sbus_ops *ops, struct sbus_priv *priv)
+{
+	int ret = 0;
+
+	if ((ret = bes2600_load_firmware_sdio(ops, priv)))
+		return ret;
+
+	return ret;
+}
diff --git a/drivers/staging/bes2600/fwio.h b/drivers/staging/bes2600/fwio.h
new file mode 100755
index 000000000000..cb9c71661f28
--- /dev/null
+++ b/drivers/staging/bes2600/fwio.h
@@ -0,0 +1,36 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef FWIO_H_INCLUDED
+#define FWIO_H_INCLUDED
+
+#define FIRMWARE_1250_CUT11	("wsm_5011.bin")
+#define FIRMWARE_CUT22		("wsm_22.bin")
+#define FIRMWARE_CUT20		("wsm_20.bin")
+#define FIRMWARE_CUT11		("wsm_11.bin")
+#define FIRMWARE_CUT10		("wsm_10.bin")
+#define SDD_FILE_1250_11	("sdd_5011.bin")
+#define SDD_FILE_22		("sdd_22.bin")
+#define SDD_FILE_20		("sdd_20.bin")
+#define SDD_FILE_11		("sdd_11.bin")
+#define SDD_FILE_10		("sdd_10.bin")
+
+#define BES2600_HW_REV_CUT10	(10)
+#define BES2600_HW_REV_CUT11	(11)
+#define BES2600_HW_REV_CUT20	(20)
+#define BES2600_HW_REV_CUT22	(22)
+#define CW1250_HW_REV_CUT10	(110)
+#define CW1250_HW_REV_CUT11	(5011)
+struct sbus_ops;
+struct sbus_priv;
+
+int bes2600_load_firmware(struct sbus_ops *ops, struct sbus_priv *priv);
+
+#endif
diff --git a/drivers/staging/bes2600/ht.h b/drivers/staging/bes2600/ht.h
new file mode 100755
index 000000000000..b5caa291936a
--- /dev/null
+++ b/drivers/staging/bes2600/ht.h
@@ -0,0 +1,43 @@
+/*
+ *  HT-related code for BES2600 driver
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_HT_H_INCLUDED
+#define BES2600_HT_H_INCLUDED
+
+#include <net/mac80211.h>
+
+struct bes2600_ht_info {
+	struct ieee80211_sta_ht_cap	ht_cap;
+	enum nl80211_channel_type	channel_type;
+	u16				operation_mode;
+};
+
+static inline int bes2600_is_ht(const struct bes2600_ht_info *ht_info)
+{
+	return ht_info->channel_type != NL80211_CHAN_NO_HT;
+}
+
+static inline int bes2600_ht_greenfield(const struct bes2600_ht_info *ht_info)
+{
+	return bes2600_is_ht(ht_info) &&
+		(ht_info->ht_cap.cap & IEEE80211_HT_CAP_GRN_FLD) &&
+		!(ht_info->operation_mode &
+			IEEE80211_HT_OP_MODE_NON_GF_STA_PRSNT);
+}
+
+static inline int bes2600_ht_ampdu_density(const struct bes2600_ht_info *ht_info)
+{
+	if (!bes2600_is_ht(ht_info))
+		return 0;
+	return ht_info->ht_cap.ampdu_density;
+}
+
+#endif /* BES2600_HT_H_INCLUDED */
diff --git a/drivers/staging/bes2600/hwio.c b/drivers/staging/bes2600/hwio.c
new file mode 100755
index 000000000000..6560bd05f99c
--- /dev/null
+++ b/drivers/staging/bes2600/hwio.c
@@ -0,0 +1,263 @@
+/*
+ * Low-level device IO routines for BES2600 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/types.h>
+
+#include "bes2600.h"
+#include "hwio.h"
+#include "sbus.h"
+
+ /* Sdio addr is 4*spi_addr */
+#define SPI_REG_ADDR_TO_SDIO(spi_reg_addr) ((spi_reg_addr) << 2)
+#define SDIO_ADDR17BIT(buf_id, mpf, rfu, reg_id_ofs) \
+				((((buf_id)    & 0x1F) << 7) \
+				| (((mpf)        & 1) << 6) \
+				| (((rfu)        & 1) << 5) \
+				| (((reg_id_ofs) & 0x1F) << 0))
+#define MAX_RETRY		3
+
+static struct sbus_ops *bes2600_subs_ops = NULL;
+static struct sbus_priv *bes2600_sbus_priv = NULL;
+
+static int __bes2600_reg_read(u16 addr, void *buf, size_t buf_len, int buf_id)
+{
+	u16 addr_sdio;
+	u32 sdio_reg_addr_17bit ;
+
+	/* Check if buffer is aligned to 4 byte boundary */
+	if (WARN_ON(((unsigned long)buf & 3) && (buf_len > 4))) {
+		bes2600_err(BES2600_DBG_SBUS,
+			   "%s: buffer is not aligned.\n", __func__);
+		return -EINVAL;
+	}
+
+	/* Convert to SDIO Register Address */
+	addr_sdio = SPI_REG_ADDR_TO_SDIO(addr);
+	sdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);
+
+	BUG_ON(!bes2600_subs_ops);
+	return bes2600_subs_ops->sbus_memcpy_fromio(bes2600_sbus_priv,
+					sdio_reg_addr_17bit,
+					buf, buf_len);
+}
+
+static int __bes2600_reg_write(u16 addr, const void *buf, size_t buf_len, int buf_id)
+{
+	u16 addr_sdio;
+	u32 sdio_reg_addr_17bit ;
+
+	/* Convert to SDIO Register Address */
+	addr_sdio = SPI_REG_ADDR_TO_SDIO(addr);
+	sdio_reg_addr_17bit = SDIO_ADDR17BIT(buf_id, 0, 0, addr_sdio);
+
+	BUG_ON(!bes2600_subs_ops);
+	return bes2600_subs_ops->sbus_memcpy_toio(bes2600_sbus_priv,
+					sdio_reg_addr_17bit,
+					buf, buf_len);
+}
+
+static inline int __bes2600_reg_read_32(u16 addr, u32 *val)
+{
+	return __bes2600_reg_read(addr, val, sizeof(val), 0);
+}
+
+static inline int __bes2600_reg_write_32(u16 addr, u32 val)
+{
+	return __bes2600_reg_write(addr, &val, sizeof(val), 0);
+}
+
+void bes2600_reg_set_object(struct sbus_ops *ops, struct sbus_priv *priv)
+{
+	bes2600_subs_ops = ops;
+	bes2600_sbus_priv = priv;
+}
+
+int bes2600_reg_read(u32 addr, void *buf, size_t buf_len)
+{
+	int ret;
+	BUG_ON(!bes2600_subs_ops);
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+	ret = bes2600_subs_ops->sbus_reg_read(bes2600_sbus_priv, addr, buf, buf_len);
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int bes2600_reg_write(u32 addr, const void *buf, size_t buf_len)
+{
+	int ret;
+	BUG_ON(!bes2600_subs_ops);
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+	ret = bes2600_subs_ops->sbus_reg_write(bes2600_sbus_priv, addr, buf, buf_len);
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int bes2600_data_read(void *buf, size_t buf_len)
+{
+	int ret, retry = 1;
+	BUG_ON(!bes2600_subs_ops);
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+	while (retry <= MAX_RETRY) {
+		ret = bes2600_subs_ops->sbus_memcpy_fromio(bes2600_sbus_priv,
+				BES_TX_DATA_ADDR, buf, buf_len);
+		if (ret) {
+			retry ++;
+			mdelay(1);
+			bes2600_dbg(BES2600_DBG_SBUS, "%s error :[%d]\n",
+					__func__, ret);
+		} else {
+			break;
+		}
+	}
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int bes2600_data_write(const void *buf, size_t buf_len)
+{
+	int ret, retry = 1;
+	u32 addr = 0;
+
+	BUG_ON(!bes2600_subs_ops);
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+	while (retry <= MAX_RETRY) {
+		ret = bes2600_subs_ops->sbus_memcpy_toio(bes2600_sbus_priv, addr, buf, buf_len);
+		if (ret) {
+			retry++;
+			mdelay(1);
+			bes2600_dbg(BES2600_DBG_SBUS, "%s,error :[%d]\n",
+					__func__, ret);
+		} else {
+			break;
+		}
+	}
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int bes2600_indirect_read(u32 addr, void *buf, size_t buf_len, u32 prefetch, u16 port_addr)
+{
+	u32 val32 = 0;
+	int i, ret;
+
+	if ((buf_len / 2) >= 0x1000) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't read more than 0xfff words.\n",
+				__func__);
+		WARN_ON(1);
+		return -EINVAL;
+		goto out;
+	}
+
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+	/* Write address */
+	ret = __bes2600_reg_write_32(ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't write address register.\n",
+				__func__);
+		goto out;
+	}
+
+	/* Read CONFIG Register Value - We will read 32 bits */
+	ret = __bes2600_reg_read_32(ST90TDS_CONFIG_REG_ID, &val32);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't read config register.\n",
+				__func__);
+		goto out;
+	}
+
+	/* Set PREFETCH bit */
+	ret = __bes2600_reg_write_32(ST90TDS_CONFIG_REG_ID, val32 | prefetch);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't write prefetch bit.\n",
+				__func__);
+		goto out;
+	}
+
+	/* Check for PRE-FETCH bit to be cleared */
+	for (i = 0; i < 20; i++) {
+		ret = __bes2600_reg_read_32(ST90TDS_CONFIG_REG_ID, &val32);
+		if (ret < 0) {
+			bes2600_err(BES2600_DBG_SBUS,
+					"%s: Can't check prefetch bit.\n",
+					__func__);
+			goto out;
+		}
+		if (!(val32 & prefetch))
+			break;
+
+		mdelay(i);
+	}
+
+	if (val32 & prefetch) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Prefetch bit is not cleared.\n",
+				__func__);
+		goto out;
+	}
+
+	/* Read data port */
+	ret = __bes2600_reg_read(port_addr, buf, buf_len, 0);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't read data port.\n",
+				__func__);
+		goto out;
+	}
+
+out:
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int bes2600_apb_write(u32 addr, const void *buf, size_t buf_len)
+{
+	int ret;
+
+	if ((buf_len / 2) >= 0x1000) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't wrire more than 0xfff words.\n",
+				__func__);
+		WARN_ON(1);
+		return -EINVAL;
+	}
+
+	bes2600_subs_ops->lock(bes2600_sbus_priv);
+
+	/* Write address */
+	ret = __bes2600_reg_write_32(ST90TDS_SRAM_BASE_ADDR_REG_ID, addr);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS,
+				"%s: Can't write address register.\n",
+				__func__);
+		goto out;
+	}
+
+	/* Write data port */
+	ret = __bes2600_reg_write(ST90TDS_SRAM_DPORT_REG_ID, buf, buf_len, 0);
+	if (ret < 0) {
+		bes2600_err(BES2600_DBG_SBUS, "%s: Can't write data port.\n",
+				__func__);
+		goto out;
+	}
+
+out:
+	bes2600_subs_ops->unlock(bes2600_sbus_priv);
+	return ret;
+}
+
+int __bes2600_irq_enable(int enable)
+{
+	return 0;
+}
diff --git a/drivers/staging/bes2600/hwio.h b/drivers/staging/bes2600/hwio.h
new file mode 100755
index 000000000000..e9d93ebf49d7
--- /dev/null
+++ b/drivers/staging/bes2600/hwio.h
@@ -0,0 +1,283 @@
+/*
+ * Low-level API for mac80211 BES2600 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * Based on:
+ * UMAC BES2600 driver which is
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_HWIO_H_INCLUDED
+#define BES2600_HWIO_H_INCLUDED
+
+/* extern */ struct sbus_ops;
+/* extern */ struct sbus_priv;
+
+/* DPLL initial values */
+#define DPLL_INIT_VAL_9000		(0x00000191)
+#define DPLL_INIT_VAL_BES2600		(0x0EC4F121)
+
+/* Hardware Type Definitions */
+#define HIF_8601_VERSATILE		(0)
+#define HIF_8601_SILICON		(1)
+#define HIF_9000_SILICON_VERSTAILE	(2)
+
+#define BES2600_CUT_11_ID_STR		(0x302E3830)
+#define BES2600_CUT_22_ID_STR1		(0x302e3132)
+#define BES2600_CUT_22_ID_STR2		(0x32302e30)
+#define BES2600_CUT_22_ID_STR3		(0x3335)
+#define CW1250_CUT_11_ID_STR1		(0x302e3033)
+#define CW1250_CUT_11_ID_STR2		(0x33302e32)
+#define CW1250_CUT_11_ID_STR3		(0x3535)
+#define BES2600_CUT_ID_ADDR		(0xFFF17F90)
+#define BES2600_CUT2_ID_ADDR		(0xFFF1FF90)
+
+/* Download control area */
+/* boot loader start address in SRAM */
+#define DOWNLOAD_BOOT_LOADER_OFFSET	(0x00000000)
+/* 32K, 0x4000 to 0xDFFF */
+#define DOWNLOAD_FIFO_OFFSET		(0x00004000)
+/* 32K */
+#define DOWNLOAD_FIFO_SIZE		(0x00008000)
+/* 128 bytes, 0xFF80 to 0xFFFF */
+#define DOWNLOAD_CTRL_OFFSET		(0x0000FF80)
+#define DOWNLOAD_CTRL_DATA_DWORDS	(32-6)
+
+struct download_cntl_t {
+	/* size of whole firmware file (including Cheksum), host init */
+	u32 ImageSize;
+	/* downloading flags */
+	u32 Flags;
+	/* No. of bytes put into the download, init & updated by host */
+	u32 Put;
+	/* last traced program counter, last ARM reg_pc */
+	u32 TracePc;
+	/* No. of bytes read from the download, host init, device updates */
+	u32 Get;
+	/* r0, boot losader status, host init to pending, device updates */
+	u32 Status;
+	/* Extra debug info, r1 to r14 if status=r0=DOWNLOAD_EXCEPTION */
+	u32 DebugData[DOWNLOAD_CTRL_DATA_DWORDS];
+};
+
+#define	DOWNLOAD_IMAGE_SIZE_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, ImageSize))
+#define	DOWNLOAD_FLAGS_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Flags))
+#define DOWNLOAD_PUT_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Put))
+#define DOWNLOAD_TRACE_PC_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, TracePc))
+#define	DOWNLOAD_GET_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Get))
+#define	DOWNLOAD_STATUS_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, Status))
+#define DOWNLOAD_DEBUG_DATA_REG		\
+	(DOWNLOAD_CTRL_OFFSET + offsetof(struct download_cntl_t, DebugData))
+#define DOWNLOAD_DEBUG_DATA_LEN		(108)
+
+#define DOWNLOAD_BLOCK_SIZE		(1024)
+
+/* For boot loader detection */
+#define DOWNLOAD_ARE_YOU_HERE		(0x87654321)
+#define DOWNLOAD_I_AM_HERE		(0x12345678)
+
+/* Download error code */
+#define DOWNLOAD_PENDING		(0xFFFFFFFF)
+#define DOWNLOAD_SUCCESS		(0)
+#define DOWNLOAD_EXCEPTION		(1)
+#define DOWNLOAD_ERR_MEM_1		(2)
+#define DOWNLOAD_ERR_MEM_2		(3)
+#define DOWNLOAD_ERR_SOFTWARE		(4)
+#define DOWNLOAD_ERR_FILE_SIZE		(5)
+#define DOWNLOAD_ERR_CHECKSUM		(6)
+#define DOWNLOAD_ERR_OVERFLOW		(7)
+#define DOWNLOAD_ERR_IMAGE		(8)
+#define DOWNLOAD_ERR_HOST		(9)
+#define DOWNLOAD_ERR_ABORT		(10)
+
+
+#define SYS_BASE_ADDR_SILICON		(0)
+#define PAC_BASE_ADDRESS_SILICON	(SYS_BASE_ADDR_SILICON + 0x09000000)
+#define PAC_SHARED_MEMORY_SILICON	(PAC_BASE_ADDRESS_SILICON)
+
+#define BES26000_APB(addr)		(PAC_SHARED_MEMORY_SILICON + (addr))
+
+/* ***************************************************************
+*Device register definitions
+*************************************************************** */
+/* WBF - SPI Register Addresses */
+#define ST90TDS_ADDR_ID_BASE		(0x0000)
+/* 16/32 bits */
+#define ST90TDS_CONFIG_REG_ID		(0x0000)
+/* 16/32 bits */
+#define ST90TDS_CONTROL_REG_ID		(0x0001)
+/* 16 bits, Q mode W/R */
+#define ST90TDS_IN_OUT_QUEUE_REG_ID	(0x0002)
+/* 32 bits, AHB bus R/W */
+#define ST90TDS_AHB_DPORT_REG_ID	(0x0003)
+/* 16/32 bits */
+#define ST90TDS_SRAM_BASE_ADDR_REG_ID   (0x0004)
+/* 32 bits, APB bus R/W */
+#define ST90TDS_SRAM_DPORT_REG_ID	(0x0005)
+/* 32 bits, t_settle/general */
+#define ST90TDS_TSET_GEN_R_W_REG_ID	(0x0006)
+/* 16 bits, Q mode read, no length */
+#define ST90TDS_FRAME_OUT_REG_ID	(0x0007)
+#define ST90TDS_ADDR_ID_MAX		(ST90TDS_FRAME_OUT_REG_ID)
+
+/* WBF - Control register bit set */
+/* next o/p length, bit 11 to 0 */
+#define ST90TDS_CONT_NEXT_LEN_MASK	(0x0FFF)
+#define ST90TDS_CONT_WUP_BIT		(BIT(12))
+#define ST90TDS_CONT_RDY_BIT		(BIT(13))
+#define ST90TDS_CONT_IRQ_ENABLE		(BIT(14))
+#define ST90TDS_CONT_RDY_ENABLE		(BIT(15))
+#define ST90TDS_CONT_IRQ_RDY_ENABLE	(BIT(14)|BIT(15))
+
+/* SPI Config register bit set */
+#define ST90TDS_CONFIG_FRAME_BIT	(BIT(2))
+#define ST90TDS_CONFIG_WORD_MODE_BITS	(BIT(3)|BIT(4))
+#define ST90TDS_CONFIG_WORD_MODE_1	(BIT(3))
+#define ST90TDS_CONFIG_WORD_MODE_2	(BIT(4))
+#define ST90TDS_CONFIG_ERROR_0_BIT	(BIT(5))
+#define ST90TDS_CONFIG_ERROR_1_BIT	(BIT(6))
+#define ST90TDS_CONFIG_ERROR_2_BIT	(BIT(7))
+/* TBD: Sure??? */
+#define ST90TDS_CONFIG_CSN_FRAME_BIT	(BIT(7))
+#define ST90TDS_CONFIG_ERROR_3_BIT	(BIT(8))
+#define ST90TDS_CONFIG_ERROR_4_BIT	(BIT(9))
+/* QueueM */
+#define ST90TDS_CONFIG_ACCESS_MODE_BIT	(BIT(10))
+/* AHB bus */
+#define ST90TDS_CONFIG_AHB_PFETCH_BIT	(BIT(11))
+#define ST90TDS_CONFIG_CPU_CLK_DIS_BIT	(BIT(12))
+/* APB bus */
+#define ST90TDS_CONFIG_PFETCH_BIT	(BIT(13))
+/* cpu reset */
+#define ST90TDS_CONFIG_CPU_RESET_BIT	(BIT(14))
+#define ST90TDS_CONFIG_CLEAR_INT_BIT	(BIT(15))
+
+/* For BES2600 the IRQ Enable and Ready Bits are in CONFIG register */
+#define ST90TDS_CONF_IRQ_RDY_ENABLE	(BIT(16)|BIT(17))
+
+void bes2600_reg_set_object(struct sbus_ops *ops, struct sbus_priv *priv);
+int bes2600_data_read(void *buf, size_t buf_len);
+int bes2600_data_write(const void *buf, size_t buf_len);
+
+int bes2600_reg_read(u32 addr, void *buf, size_t buf_len);
+int bes2600_reg_write(u32 addr, const void *buf, size_t buf_len);
+
+static inline int bes2600_reg_read_16(u16 addr, u16 *val)
+{
+	return bes2600_reg_read(addr, val, sizeof(*val));
+}
+
+static inline int bes2600_reg_write_16(u16 addr, u16 val)
+{
+	return bes2600_reg_write(addr, &val, sizeof(val));
+}
+
+static inline int bes2600_reg_read_32(u16 addr, u32 *val)
+{
+	return bes2600_reg_read(addr, val, sizeof(val));
+}
+
+static inline int bes2600_reg_write_32(u16 addr, u32 val)
+{
+	return bes2600_reg_write(addr, &val, sizeof(val));
+}
+
+int bes2600_indirect_read(u32 addr, void *buf, size_t buf_len, u32 prefetch, u16 port_addr);
+int bes2600_apb_write(u32 addr, const void *buf, size_t buf_len);
+int bes2600_ahb_write(u32 addr, const void *buf, size_t buf_len);
+
+static inline int bes2600_apb_read(u32 addr, void *buf, size_t buf_len)
+{
+	return bes2600_indirect_read(addr, buf, buf_len,
+		ST90TDS_CONFIG_PFETCH_BIT, ST90TDS_SRAM_DPORT_REG_ID);
+}
+
+static inline int bes2600_ahb_read(u32 addr, void *buf, size_t buf_len)
+{
+	return bes2600_indirect_read(addr, buf, buf_len,
+		ST90TDS_CONFIG_AHB_PFETCH_BIT, ST90TDS_AHB_DPORT_REG_ID);
+}
+
+static inline int bes2600_apb_read_32(u32 addr, u32 *val)
+{
+	return bes2600_apb_read(addr, val, sizeof(val));
+}
+
+static inline int bes2600_apb_write_32(u32 addr, u32 val)
+{
+	return bes2600_apb_write(addr, &val, sizeof(val));
+}
+
+static inline int bes2600_ahb_read_32(u32 addr, u32 *val)
+{
+	return bes2600_ahb_read(addr, val, sizeof(val));
+}
+
+#define BES_TX_CTRL_REG_ID	(0x0)
+
+#define BES_TX_NEXT_LEN_REG_ID	(0x104)
+
+#define BES_TX_NEXT_LEN_MASK	(0xffff)
+#define BES_TX_DATA_ADDR	(0x0)
+
+#define BES_HOST_INT_REG_ID		(0x120)
+#define BES_HOST_INT			(1 << 0)
+#define BES_AP_WAKEUP_CFG		(1 << 1)
+#define BES_SUBSYSTEM_MCU_DEACTIVE	(1 << 2)
+#define BES_SUBSYSTEM_MCU_ACTIVE	(1 << 3)
+#define BES_SUBSYSTEM_WIFI_DEACTIVE	(1 << 4)
+#define BES_SUBSYSTEM_WIFI_ACTIVE	(1 << 5)
+#define BES_SUBSYSTEM_WIFI_DEBUG	(1 << 6)
+#define BES_SUBSYSTEM_BT_DEACTIVE	(1 << 7)
+#define BES_SUBSYSTEM_BT_ACTIVE		(1 << 8)
+#define BES_SUBSYSTEM_SYSTEM_CLOSE	(1 << 9)
+#define BES_SUBSYSTEM_BT_WAKEUP		(1 << 10)
+#define BES_SUBSYSTEM_BT_SLEEP		(1 << 11)
+
+#define BES_AP_WAKEUP_TYPE_MASK		0xC
+#define BES_AP_WAKEUP_TYPE_SHIFT	2
+#define BES_AP_WAKEUP_TYPE_GPIO		0
+#define BES_AP_WAKEUP_TYPE_IF		1
+
+#define BES_AP_WAKEUP_REG_ID		(0x124)
+#define BES_AP_WAKEUP_CFG_VALID		(0x80)
+
+#define BES_AP_WAKEUP_GPIO_MASK		(0x3)
+#define BES_AP_WAKEUP_GPIO_HIGH		(0x0)
+#define BES_AP_WAKEUP_GPIO_LOW		(0x1)
+#define BES_AP_WAKEUP_GPIO_RISE		(0x2)
+#define BES_AP_WAKEUP_GPIO_FALL		(0x3)
+
+#define BES_SLAVE_STATUS_REG_ID			(0x10c)
+#define BES_SLAVE_STATUS_MCU_READY		(1 << 0)
+#define BES_SLAVE_STATUS_DPD_READY		(1 << 1)
+#define BES_SLAVE_STATUS_WIFI_READY		(1 << 2)
+#define BES_SLAVE_STATUS_BT_READY		(1 << 3)
+#define BES_SLAVE_STATUS_MCU_WAKEUP_READY	(1 << 4)
+#define BES_SLAVE_STATUS_BT_WAKE_READY		(1 << 5)
+#define BES_SLAVE_STATUS_DPD_LOG_READY		(1 << 6)
+
+#define PACKET_TOTAL_LEN(len) 		((len) & 0xffff)
+#define PACKET_COUNT(len) 		(((len) >> 16) & 0xff)
+#define PAKCET_CRC8(len) 		(((len) >> 24) & 0xff)
+
+#define BES_SDIO_RX_MULTIPLE_NUM (16)
+#define BES_SDIO_TX_MULTIPLE_NUM (16)
+#define BES_SDIO_TX_MULTIPLE_NUM_NOSIGNAL (1)
+
+#define MAX_SDIO_TRANSFER_LEN (32768)
+
+#endif /* BES2600_HWIO_H_INCLUDED */
diff --git a/drivers/staging/bes2600/itp.h b/drivers/staging/bes2600/itp.h
new file mode 100755
index 000000000000..54a0cb4b07dd
--- /dev/null
+++ b/drivers/staging/bes2600/itp.h
@@ -0,0 +1,60 @@
+/*
+ * ITP code for BES2600 mac80211 driver
+ *
+ * Copyright (c) 2011, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_ITP_H_INCLUDED
+#define BES2600_ITP_H_INCLUDED
+
+struct cw200_common;
+struct wsm_tx_confirm;
+struct dentry;
+
+static inline int
+bes2600_itp_init(struct bes2600_common *priv)
+{
+	return 0;
+}
+
+static inline void bes2600_itp_release(struct bes2600_common *priv)
+{
+}
+
+static inline bool bes2600_is_itp(struct bes2600_common *priv)
+{
+	return false;
+}
+
+static inline bool bes2600_itp_rxed(struct bes2600_common *priv,
+		struct sk_buff *skb)
+{
+	return false;
+}
+
+
+static inline void bes2600_itp_consume_txed(struct bes2600_common *priv)
+{
+}
+
+static inline void bes2600_itp_wake_up_tx(struct bes2600_common *priv)
+{
+}
+
+static inline int bes2600_itp_get_tx(struct bes2600_common *priv, u8 **data,
+		size_t *tx_len, int *burst)
+{
+	return 0;
+}
+
+static inline bool bes2600_itp_tx_running(struct bes2600_common *priv)
+{
+	return false;
+}
+
+#endif /* BES2600_ITP_H_INCLUDED */
diff --git a/drivers/staging/bes2600/main.c b/drivers/staging/bes2600/main.c
new file mode 100755
index 000000000000..36454108af7a
--- /dev/null
+++ b/drivers/staging/bes2600/main.c
@@ -0,0 +1,681 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/module.h>
+#include <linux/init.h>
+#include <linux/firmware.h>
+#include <linux/etherdevice.h>
+#include <linux/vmalloc.h>
+#include <linux/random.h>
+#include <linux/sched.h>
+#include <net/mac80211.h>
+
+#include "bes2600.h"
+#include "txrx.h"
+#include "sbus.h"
+#include "fwio.h"
+#include "hwio.h"
+#include "bh.h"
+#include "sta.h"
+#include "ap.h"
+#include "scan.h"
+#include "debug.h"
+#include "pm.h"
+#include "bes2600_cfgvendor.h"
+#include "bes2600_driver_mode.h"
+#include "bes2600_factory.h"
+#include "bes_chardev.h"
+#include "txrx_opt.h"
+
+MODULE_AUTHOR("Dmitry Tarnyagin <dmitry.tarnyagin@stericsson.com>");
+MODULE_DESCRIPTION("Softmac BES2600 common code");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("bes2600");
+
+static u8 bes2600_mac_template[ETH_ALEN] = {
+	0x02, 0x80, 0xe1, 0x00, 0x00, 0x00 /* To use macaddr of customers */
+};
+
+/* TODO: use rates and channels from the device */
+#define RATETAB_ENT(_rate, _rateid, _flags)		\
+	{						\
+		.bitrate	= (_rate),		\
+		.hw_value	= (_rateid),		\
+		.flags		= (_flags),		\
+	}
+
+static struct ieee80211_rate bes2600_rates[] = {
+	RATETAB_ENT(10,  0,   0),
+	RATETAB_ENT(20,  1,   0),
+	RATETAB_ENT(55,  2,   0),
+	RATETAB_ENT(110, 3,   0),
+	RATETAB_ENT(60,  6,  0),
+	RATETAB_ENT(90,  7,  0),
+	RATETAB_ENT(120, 8,  0),
+	RATETAB_ENT(180, 9,  0),
+	RATETAB_ENT(240, 10, 0),
+	RATETAB_ENT(360, 11, 0),
+	RATETAB_ENT(480, 12, 0),
+	RATETAB_ENT(540, 13, 0),
+};
+
+static struct ieee80211_rate bes2600_mcs_rates[] = {
+	RATETAB_ENT(65,  14, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(130, 15, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(195, 16, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(260, 17, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(390, 18, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(520, 19, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(585, 20, IEEE80211_TX_RC_MCS),
+	RATETAB_ENT(650, 21, IEEE80211_TX_RC_MCS),
+};
+
+#define bes2600_a_rates		(bes2600_rates + 4)
+#define bes2600_a_rates_size	(ARRAY_SIZE(bes2600_rates) - 4)
+#define bes2600_g_rates		(bes2600_rates + 0)
+#define bes2600_g_rates_size	(ARRAY_SIZE(bes2600_rates))
+#define bes2600_n_rates		(bes2600_mcs_rates)
+#define bes2600_n_rates_size	(ARRAY_SIZE(bes2600_mcs_rates))
+
+
+#define CHAN2G(_channel, _freq, _flags) {			\
+	.band			= NL80211_BAND_2GHZ,		\
+	.center_freq		= (_freq),			\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+#define CHAN5G(_channel, _flags) {				\
+	.band			= NL80211_BAND_5GHZ,		\
+	.center_freq	= 5000 + (5 * (_channel)),		\
+	.hw_value		= (_channel),			\
+	.flags			= (_flags),			\
+	.max_antenna_gain	= 0,				\
+	.max_power		= 30,				\
+}
+
+static struct ieee80211_channel bes2600_2ghz_chantable[] = {
+	CHAN2G(1, 2412, 0),
+	CHAN2G(2, 2417, 0),
+	CHAN2G(3, 2422, 0),
+	CHAN2G(4, 2427, 0),
+	CHAN2G(5, 2432, 0),
+	CHAN2G(6, 2437, 0),
+	CHAN2G(7, 2442, 0),
+	CHAN2G(8, 2447, 0),
+	CHAN2G(9, 2452, 0),
+	CHAN2G(10, 2457, 0),
+	CHAN2G(11, 2462, 0),
+	CHAN2G(12, 2467, 0),
+	CHAN2G(13, 2472, 0),
+	CHAN2G(14, 2484, 0),
+};
+
+static struct ieee80211_channel bes2600_5ghz_chantable[] = {
+	CHAN5G(34, 0),		CHAN5G(36, 0),
+	CHAN5G(38, 0),		CHAN5G(40, 0),
+	CHAN5G(42, 0),		CHAN5G(44, 0),
+	CHAN5G(46, 0),		CHAN5G(48, 0),
+	CHAN5G(52, 0),		CHAN5G(56, 0),
+	CHAN5G(60, 0),		CHAN5G(64, 0),
+	CHAN5G(100, 0),		CHAN5G(104, 0),
+	CHAN5G(108, 0),		CHAN5G(112, 0),
+	CHAN5G(116, 0),		CHAN5G(120, 0),
+	CHAN5G(124, 0),		CHAN5G(128, 0),
+	CHAN5G(132, 0),		CHAN5G(136, 0),
+	CHAN5G(140, 0),		CHAN5G(149, 0),
+	CHAN5G(153, 0),		CHAN5G(157, 0),
+	CHAN5G(161, 0),		CHAN5G(165, 0),
+	CHAN5G(184, 0),		CHAN5G(188, 0),
+	CHAN5G(192, 0),		CHAN5G(196, 0),
+	CHAN5G(200, 0),		CHAN5G(204, 0),
+	CHAN5G(208, 0),		CHAN5G(212, 0),
+	CHAN5G(216, 0),
+};
+
+static struct ieee80211_supported_band bes2600_band_2ghz = {
+	.channels = bes2600_2ghz_chantable,
+	.n_channels = ARRAY_SIZE(bes2600_2ghz_chantable),
+	.bitrates = bes2600_g_rates,
+	.n_bitrates = bes2600_g_rates_size,
+	.ht_cap = {
+		.cap = IEEE80211_HT_CAP_GRN_FLD |
+			(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) |
+			IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+			IEEE80211_HT_CAP_SGI_20 |
+			IEEE80211_HT_CAP_SGI_40 |
+			IEEE80211_HT_CAP_MAX_AMSDU,
+		.ht_supported = 1,
+		.ampdu_factor = IEEE80211_HT_MAX_AMPDU_32K,
+		.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,
+		.mcs = {
+			.rx_mask[0] = 0xFF,
+			.rx_highest = __cpu_to_le16(0),
+			.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
+		},
+	},
+};
+
+static struct ieee80211_supported_band bes2600_band_5ghz = {
+	.channels = bes2600_5ghz_chantable,
+	.n_channels = ARRAY_SIZE(bes2600_5ghz_chantable),
+	.bitrates = bes2600_a_rates,
+	.n_bitrates = bes2600_a_rates_size,
+	.ht_cap = {
+		.cap = IEEE80211_HT_CAP_GRN_FLD |
+			(1 << IEEE80211_HT_CAP_RX_STBC_SHIFT) |
+			IEEE80211_HT_CAP_SUP_WIDTH_20_40 |
+			IEEE80211_HT_CAP_SGI_20 |
+			IEEE80211_HT_CAP_SGI_40 |
+			IEEE80211_HT_CAP_MAX_AMSDU,
+		.ht_supported = 1,
+		.ampdu_factor = IEEE80211_HT_MAX_AMPDU_32K,
+		.ampdu_density = IEEE80211_HT_MPDU_DENSITY_NONE,
+		.mcs = {
+			.rx_mask[0] = 0xFF,
+			.rx_highest = __cpu_to_le16(0x41),
+			.tx_params = IEEE80211_HT_MCS_TX_DEFINED,
+		},
+	},
+};
+
+static const unsigned long bes2600_ttl[] = {
+	1 * HZ,	/* VO */
+	2 * HZ,	/* VI */
+	5 * HZ, /* BE */
+	10 * HZ	/* BK */
+};
+
+static const struct ieee80211_iface_limit bes2600_if_limits[] = {
+	{ .max = 2, .types = BIT(NL80211_IFTYPE_STATION) },
+	{ .max = 1, .types = BIT(NL80211_IFTYPE_AP) |
+			     BIT(NL80211_IFTYPE_P2P_CLIENT) |
+			     BIT(NL80211_IFTYPE_P2P_GO) },
+	{ .max = 1, .types = BIT(NL80211_IFTYPE_P2P_DEVICE) },
+};
+
+
+
+static const struct ieee80211_iface_combination bes2600_if_comb[] = {
+	{
+		.limits = bes2600_if_limits,
+		.n_limits = ARRAY_SIZE(bes2600_if_limits),
+		.max_interfaces = CW12XX_MAX_VIFS,
+		.num_different_channels = 1,
+	},
+};
+
+
+static const struct ieee80211_ops bes2600_ops = {
+	.start			= bes2600_start,
+	.stop			= bes2600_stop,
+	.add_interface		= bes2600_add_interface,
+	.remove_interface	= bes2600_remove_interface,
+	.change_interface	= bes2600_change_interface,
+	.tx			= bes2600_tx,
+	.wake_tx_queue		= ieee80211_handle_wake_tx_queue,
+	.hw_scan		= bes2600_hw_scan,
+	.cancel_hw_scan         = bes2600_cancel_hw_scan,
+	.set_tim		= bes2600_set_tim,
+	.sta_notify		= bes2600_sta_notify,
+	.sta_add		= bes2600_sta_add,
+	.sta_remove		= bes2600_sta_remove,
+	.set_key		= bes2600_set_key,
+	.set_rts_threshold	= bes2600_set_rts_threshold,
+	.config			= bes2600_config,
+	.bss_info_changed	= bes2600_bss_info_changed,
+	.prepare_multicast	= bes2600_prepare_multicast,
+	.configure_filter	= bes2600_configure_filter,
+	.conf_tx		= bes2600_conf_tx,
+	.get_stats		= bes2600_get_stats,
+	.ampdu_action		= bes2600_ampdu_action,
+	.flush			= bes2600_flush,
+#ifdef CONFIG_PM
+	.suspend		= bes2600_wow_suspend,
+	.resume			= bes2600_wow_resume,
+#endif
+	/* Intentionally not offloaded:					*/
+	/*.channel_switch	= bes2600_channel_switch,		*/
+	.remain_on_channel	= bes2600_remain_on_channel,
+	.cancel_remain_on_channel = bes2600_cancel_remain_on_channel,
+};
+
+#ifdef CONFIG_PM
+static const struct wiphy_wowlan_support bes2600_wowlan_support = {
+	/* Support only for limited wowlan functionalities */
+	.flags = WIPHY_WOWLAN_ANY | WIPHY_WOWLAN_DISCONNECT,
+};
+#endif
+
+static void bes2600_get_base_mac(struct bes2600_common *hw_priv)
+{
+	memcpy(hw_priv->addresses[0].addr, bes2600_mac_template, ETH_ALEN);
+
+	if (hw_priv->addresses[0].addr[3] == 0 &&
+	    hw_priv->addresses[0].addr[4] == 0 &&
+	    hw_priv->addresses[0].addr[5] == 0)
+		get_random_bytes(&hw_priv->addresses[0].addr[3], 3);
+}
+
+static void bes2600_derive_mac(struct bes2600_common *hw_priv)
+{
+	memcpy(hw_priv->addresses[1].addr, hw_priv->addresses[0].addr, ETH_ALEN);
+	hw_priv->addresses[1].addr[5] =
+			hw_priv->addresses[0].addr[5] + 1;
+
+	memcpy(hw_priv->addresses[2].addr, hw_priv->addresses[1].addr,
+	       ETH_ALEN);
+	hw_priv->addresses[2].addr[4] ^= 0x80;
+}
+
+struct ieee80211_hw *bes2600_init_common(size_t hw_priv_data_len)
+{
+	int i;
+	struct ieee80211_hw *hw;
+	struct bes2600_common *hw_priv;
+	struct ieee80211_supported_band *sband;
+	int band;
+
+	hw = ieee80211_alloc_hw(hw_priv_data_len, &bes2600_ops);
+	if (!hw)
+		return NULL;
+
+	hw_priv = hw->priv;
+	/* TODO:COMBO this debug message can be removed */
+	bes2600_err(BES2600_DBG_INIT, "Allocated hw_priv @ %p\n", hw_priv);
+	hw_priv->if_id_slot = 0;
+	hw_priv->roc_if_id = -1;
+	hw_priv->scan_switch_if_id = -1;
+	atomic_set(&hw_priv->num_vifs, 0);
+	atomic_set(&hw_priv->netdevice_start, 0);
+
+	bes2600_get_base_mac(hw_priv);
+	bes2600_derive_mac(hw_priv);
+
+	hw_priv->hw = hw;
+	hw_priv->rates = bes2600_rates; /* TODO: fetch from FW */
+	hw_priv->mcs_rates = bes2600_n_rates;
+	/* Enable block ACK for 4 TID (BE,VI,VI,VO). */
+	/*due to HW limitations*/
+	hw_priv->ba_tid_mask = 0xB1;
+
+	/* Init tx retry limit */
+	hw_priv->long_frame_max_tx_count = 31;
+	hw_priv->short_frame_max_tx_count = 31;
+	hw_priv->hw->max_rate_tries = hw_priv->short_frame_max_tx_count;
+
+	ieee80211_hw_set(hw, SIGNAL_DBM);
+	ieee80211_hw_set(hw, SUPPORTS_PS);
+	ieee80211_hw_set(hw, SUPPORTS_DYNAMIC_PS);
+	ieee80211_hw_set(hw, REPORTS_TX_ACK_STATUS);
+	ieee80211_hw_set(hw, NEED_DTIM_BEFORE_ASSOC);
+	ieee80211_hw_set(hw, TX_AMPDU_SETUP_IN_HW);
+	ieee80211_hw_set(hw, AMPDU_AGGREGATION);
+	ieee80211_hw_set(hw, CONNECTION_MONITOR);
+	ieee80211_hw_set(hw, MFP_CAPABLE);
+
+	hw->wiphy->interface_modes = BIT(NL80211_IFTYPE_STATION) |
+					  BIT(NL80211_IFTYPE_ADHOC) |
+					  BIT(NL80211_IFTYPE_AP) |
+					  BIT(NL80211_IFTYPE_MESH_POINT) |
+					  BIT(NL80211_IFTYPE_P2P_CLIENT) |
+					  BIT(NL80211_IFTYPE_P2P_GO);
+	hw->wiphy->interface_modes |= BIT(NL80211_IFTYPE_P2P_DEVICE);
+
+	/* Support only for limited wowlan functionalities */
+#ifdef CONFIG_PM
+	hw->wiphy->wowlan = &bes2600_wowlan_support;
+#endif
+
+	hw->wiphy->n_addresses = CW12XX_MAX_VIFS;
+	hw->wiphy->addresses = hw_priv->addresses;
+	hw->wiphy->max_remain_on_channel_duration = 500;
+	hw->wiphy->reg_notifier = bes2600_reg_notifier;
+	//hw->channel_change_time = 500;	/* TODO: find actual value */
+	/* hw_priv->beacon_req_id = cpu_to_le32(0); */
+	hw->queues = 4;
+	hw_priv->noise = -94;
+
+	hw->max_rates = 8;
+	hw->max_rate_tries = 15;
+	hw->extra_tx_headroom = WSM_TX_EXTRA_HEADROOM +
+		8  /* TKIP IV */ +
+		12 /* TKIP ICV and MIC */;
+
+	hw->sta_data_size = sizeof(struct bes2600_sta_priv);
+	hw->vif_data_size = sizeof(struct bes2600_vif);
+
+	hw->wiphy->bands[NL80211_BAND_2GHZ] = &bes2600_band_2ghz;
+	hw->wiphy->bands[NL80211_BAND_5GHZ] = &bes2600_band_5ghz;
+
+	/* Channel params have to be cleared before registering wiphy again */
+	for (band = 0; band < NUM_NL80211_BANDS; band++) {
+		sband = hw->wiphy->bands[band];
+		if (!sband)
+			continue;
+		for (i = 0; i < sband->n_channels; i++) {
+			sband->channels[i].flags = 0;
+			sband->channels[i].max_antenna_gain = 0;
+			sband->channels[i].max_power = 30;
+		}
+	}
+
+	hw->wiphy->max_scan_ssids = WSM_SCAN_MAX_NUM_OF_SSIDS;
+	hw->wiphy->max_scan_ie_len = IEEE80211_MAX_DATA_LEN;
+
+	hw->wiphy->iface_combinations = bes2600_if_comb;
+	hw->wiphy->n_iface_combinations = ARRAY_SIZE(bes2600_if_comb);
+
+	SET_IEEE80211_PERM_ADDR(hw, hw_priv->addresses[0].addr);
+
+	spin_lock_init(&hw_priv->vif_list_lock);
+	sema_init(&hw_priv->wsm_cmd_sema, 1);
+	sema_init(&hw_priv->conf_lock, 1);
+	sema_init(&hw_priv->wsm_oper_lock, 1);
+	hw_priv->workqueue = create_singlethread_workqueue("bes2600_wq");
+	sema_init(&hw_priv->scan.lock, 1);
+	INIT_WORK(&hw_priv->scan.work, bes2600_scan_work);
+	INIT_DELAYED_WORK(&hw_priv->scan.probe_work, bes2600_probe_work);
+	INIT_DELAYED_WORK(&hw_priv->scan.timeout, bes2600_scan_timeout);
+	INIT_DELAYED_WORK(&hw_priv->rem_chan_timeout, bes2600_rem_chan_timeout);
+	hw_priv->rtsvalue = 0;
+	spin_lock_init(&hw_priv->rtsvalue_lock);
+	INIT_WORK(&hw_priv->dynamic_opt_txrx_work, bes2600_dynamic_opt_txrx_work);
+	INIT_WORK(&hw_priv->tx_policy_upload_work, tx_policy_upload_work);
+	spin_lock_init(&hw_priv->event_queue_lock);
+	INIT_LIST_HEAD(&hw_priv->event_queue);
+	INIT_WORK(&hw_priv->event_handler, bes2600_event_handler);
+	INIT_WORK(&hw_priv->ba_work, bes2600_ba_work);
+	spin_lock_init(&hw_priv->ba_lock);
+	timer_setup(&hw_priv->ba_timer, bes2600_ba_timer, 0);
+
+	if (unlikely(bes2600_queue_stats_init(&hw_priv->tx_queue_stats,
+			WLAN_LINK_ID_MAX,
+			bes2600_skb_dtor,
+			hw_priv))) {
+		ieee80211_free_hw(hw);
+		return NULL;
+	}
+
+	for (i = 0; i < 4; ++i) {
+		if (unlikely(bes2600_queue_init(&hw_priv->tx_queue[i],
+				&hw_priv->tx_queue_stats, i, CW12XX_MAX_QUEUE_SZ,
+				bes2600_ttl[i]))) {
+			for (; i > 0; i--)
+				bes2600_queue_deinit(&hw_priv->tx_queue[i - 1]);
+			bes2600_queue_stats_deinit(&hw_priv->tx_queue_stats);
+			ieee80211_free_hw(hw);
+			return NULL;
+		}
+	}
+
+	init_waitqueue_head(&hw_priv->channel_switch_done);
+	init_waitqueue_head(&hw_priv->wsm_cmd_wq);
+	init_waitqueue_head(&hw_priv->wsm_startup_done);
+	init_waitqueue_head(&hw_priv->offchannel_wq);
+	hw_priv->offchannel_done = 0;
+	wsm_buf_init(&hw_priv->wsm_cmd_buf);
+	spin_lock_init(&hw_priv->wsm_cmd.lock);
+	timer_setup(&hw_priv->mcu_mon_timer, bes2600_bh_mcu_active_monitor, 0);
+	timer_setup(&hw_priv->lmac_mon_timer, bes2600_bh_lmac_active_monitor, 0);
+
+	bes2600_tx_loop_init(hw_priv);
+
+	bes2600_set_vendor_command(hw->wiphy);
+
+	for (i = 0; i < CW12XX_MAX_VIFS; i++)
+		hw_priv->hw_bufs_used_vif[i] = 0;
+
+	hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+	hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+	return hw;
+}
+EXPORT_SYMBOL_GPL(bes2600_init_common);
+
+
+int bes2600_register_common(struct ieee80211_hw *dev)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	int err;
+
+	err = ieee80211_register_hw(dev);
+	if (err) {
+		bes2600_err(BES2600_DBG_INIT, "Cannot register device (%d).\n",
+				err);
+		return err;
+	}
+
+	bes2600_debug_init_common(hw_priv);
+
+	bes2600_info(BES2600_DBG_INIT, "is registered as '%s'\n",
+			wiphy_name(dev->wiphy));
+	return 0;
+}
+EXPORT_SYMBOL_GPL(bes2600_register_common);
+
+void bes2600_free_common(struct ieee80211_hw *dev)
+{
+	/* struct bes2600_common *hw_priv = dev->priv; */
+
+	bes2600_vendor_command_detach(dev->wiphy);
+
+	ieee80211_free_hw(dev);
+}
+EXPORT_SYMBOL_GPL(bes2600_free_common);
+
+void bes2600_unregister_common(struct ieee80211_hw *dev)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	int i;
+
+	ieee80211_unregister_hw(dev);
+
+	del_timer_sync(&hw_priv->ba_timer);
+
+	hw_priv->sbus_ops->irq_unsubscribe(hw_priv->sbus_priv);
+	bes2600_unregister_bh(hw_priv);
+
+	bes2600_debug_release_common(hw_priv);
+
+	wsm_buf_deinit(&hw_priv->wsm_cmd_buf);
+	destroy_workqueue(hw_priv->workqueue);
+	hw_priv->workqueue = NULL;
+	if (hw_priv->skb_cache) {
+		dev_kfree_skb(hw_priv->skb_cache);
+		hw_priv->skb_cache = NULL;
+	}
+	if (hw_priv->sdd) {
+		hw_priv->sdd = NULL;
+	}
+	for (i = 0; i < 4; ++i)
+		bes2600_queue_deinit(&hw_priv->tx_queue[i]);
+	bes2600_queue_stats_deinit(&hw_priv->tx_queue_stats);
+	for (i = 0; i < CW12XX_MAX_VIFS; i++) {
+		kfree(hw_priv->vif_list[i]);
+		hw_priv->vif_list[i] = NULL;
+	}
+
+	bes2600_pwr_exit(hw_priv);
+}
+EXPORT_SYMBOL_GPL(bes2600_unregister_common);
+
+static int bes2600_sbus_comm_init(struct bes2600_common *hw_priv)
+{
+	int ret = 0;
+
+	if (hw_priv->sbus_ops->init)
+		hw_priv->sbus_ops->init(hw_priv->sbus_priv, hw_priv);
+
+	/* Register Interrupt Handler */
+	hw_priv->sbus_ops->irq_subscribe(hw_priv->sbus_priv,
+	        (sbus_irq_handler)bes2600_irq_handler, hw_priv);
+	hw_priv->hw_type = HIF_8601_SILICON;
+	hw_priv->hw_revision = BES2600_HW_REV_CUT10;
+
+	return ret;
+}
+
+int bes2600_core_probe(const struct sbus_ops *sbus_ops,
+		      struct sbus_priv *sbus,
+		      struct device *pdev,
+		      struct bes2600_common **pself)
+{
+	int err = -ENOMEM;
+	//u16 ctrl_reg;
+	struct ieee80211_hw *dev;
+	struct bes2600_common *hw_priv;
+
+	dev = bes2600_init_common(sizeof(struct bes2600_common));
+	if (!dev)
+		goto err;
+
+	hw_priv = dev->priv;
+	hw_priv->sbus_ops = sbus_ops;
+	hw_priv->sbus_priv = sbus;
+	hw_priv->pdev = pdev;
+	SET_IEEE80211_DEV(hw_priv->hw, pdev);
+
+	/* WSM callbacks. */
+	hw_priv->wsm_cbc.scan_complete = bes2600_scan_complete_cb;
+	hw_priv->wsm_cbc.tx_confirm = bes2600_tx_confirm_cb;
+	hw_priv->wsm_cbc.rx = bes2600_rx_cb;
+	hw_priv->wsm_cbc.suspend_resume = bes2600_suspend_resume;
+	/* hw_priv->wsm_cbc.set_pm_complete = bes2600_set_pm_complete_cb; */
+	hw_priv->wsm_cbc.channel_switch = bes2600_channel_switch_cb;
+
+	bes2600_pwr_init(hw_priv);
+
+	err = bes2600_register_bh(hw_priv);
+	if (err)
+		goto err1;
+
+	err = bes2600_sbus_comm_init(hw_priv);
+	if (err)
+		goto err2;
+
+	if (bes2600_chrdev_get_fw_type() == BES2600_FW_TYPE_BT) {
+	} else if (bes2600_chrdev_get_fw_type() == BES2600_FW_TYPE_WIFI_NO_SIGNAL) {
+		*pself = dev->priv;
+		if (bes2600_wifi_start(hw_priv))
+			goto err3;
+	}
+
+	err = bes2600_register_common(dev);
+	if (err) {
+		goto err3;
+	}
+
+	*pself = dev->priv;
+	return err;
+
+err3:
+	hw_priv->sbus_ops->irq_unsubscribe(hw_priv->sbus_priv);
+	if (sbus_ops->reset)
+		sbus_ops->reset(sbus);
+err2:
+	bes2600_unregister_bh(hw_priv);
+err1:
+	bes2600_free_common(dev);
+err:
+	return err;
+}
+
+void bes2600_core_release(struct bes2600_common *self)
+{
+	bes2600_unregister_common(self->hw);
+	bes2600_free_common(self->hw);
+	return;
+}
+
+int bes2600_wifi_start(struct bes2600_common *hw_priv)
+{
+	int ret, if_id;
+
+	if(hw_priv->sbus_ops->gpio_wake) {
+		hw_priv->sbus_ops->gpio_wake(hw_priv->sbus_priv, GPIO_WAKE_FLAG_WIFI_ON);
+	}
+
+	if (hw_priv->sbus_ops->sbus_active &&
+		WARN_ON((ret = hw_priv->sbus_ops->sbus_active(hw_priv->sbus_priv, SUBSYSTEM_WIFI))))
+		goto err;
+
+	if (wait_event_interruptible_timeout(hw_priv->wsm_startup_done,
+			hw_priv->wsm_caps.firmwareReady, 10*HZ) <= 0) {
+
+		/* TODO: Needs to find how to reset device */
+		/*       in QUEUE mode properly.           */
+		bes2600_info(BES2600_DBG_INIT, "startup timeout!!!\n");
+		ret = -ENODEV;
+		goto err;
+	}
+
+	if (bes2600_chrdev_is_signal_mode()) {
+		for (if_id = 0; if_id < 2; if_id++) {
+			/* Enable multi-TX confirmation */
+			if (WARN_ON((ret = wsm_use_multi_tx_conf(hw_priv, true, if_id)))) {
+				goto err;
+			}
+		}
+	}
+	bes2600_pwr_start(hw_priv);
+
+err:
+	if(hw_priv->sbus_ops->gpio_sleep) {
+		hw_priv->sbus_ops->gpio_sleep(hw_priv->sbus_priv, GPIO_WAKE_FLAG_WIFI_ON);
+	}
+
+	return ret;
+}
+
+int bes2600_wifi_stop(struct bes2600_common *hw_priv)
+{
+	int ret = 0;
+	unsigned long status = 0;
+
+	status = wait_event_timeout(hw_priv->bh_evt_wq, (!hw_priv->hw_bufs_used), 3 * HZ);
+	bes2600_err_with_cond((!status), BES2600_DBG_INIT, "communication exception!");
+
+	if(hw_priv->sbus_ops->gpio_wake) {
+		hw_priv->sbus_ops->gpio_wake(hw_priv->sbus_priv, GPIO_WAKE_FLAG_WIFI_OFF);
+	}
+
+	bes2600_pwr_stop(hw_priv);
+
+	if (hw_priv->sbus_ops->sbus_deactive &&
+		WARN_ON(ret = hw_priv->sbus_ops->sbus_deactive(hw_priv->sbus_priv, SUBSYSTEM_WIFI))) {
+		goto err;
+	}
+
+	if(hw_priv->sbus_ops->gpio_sleep) {
+		hw_priv->sbus_ops->gpio_sleep(hw_priv->sbus_priv, GPIO_WAKE_FLAG_WIFI_OFF);
+	}
+
+	memset(&hw_priv->wsm_caps, 0, sizeof(hw_priv->wsm_caps));
+	hw_priv->wsm_rx_seq[0] = 0;
+	hw_priv->wsm_rx_seq[1] = 0;
+	hw_priv->wsm_tx_seq[0] = 0;
+	hw_priv->wsm_tx_seq[1] = 0;
+	hw_priv->wsm_tx_pending[0] = 0;
+	hw_priv->wsm_tx_pending[1] = 0;
+	del_timer_sync(&hw_priv->mcu_mon_timer);
+	del_timer_sync(&hw_priv->lmac_mon_timer);
+	hw_priv->sdd = NULL;
+	return ret;
+
+err:
+	if(hw_priv->sbus_ops->gpio_sleep) {
+		hw_priv->sbus_ops->gpio_sleep(hw_priv->sbus_priv, GPIO_WAKE_FLAG_WIFI_OFF);
+	}
+
+	return ret;
+}
diff --git a/drivers/staging/bes2600/pm.c b/drivers/staging/bes2600/pm.c
new file mode 100755
index 000000000000..ad53d312d83e
--- /dev/null
+++ b/drivers/staging/bes2600/pm.c
@@ -0,0 +1,411 @@
+/*
+ * Mac80211 power management API for BES2600 drivers
+ *
+ * Copyright (c) 2011, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/platform_device.h>
+#include <linux/if_ether.h>
+#include "bes2600.h"
+#include "pm.h"
+#include "sta.h"
+#include "bh.h"
+#include "sbus.h"
+#include "bes2600_driver_mode.h"
+#include "bes_chardev.h"
+
+#define BES2600_BEACON_SKIPPING_MULTIPLIER 3
+
+struct bes2600_udp_port_filter {
+	struct wsm_udp_port_filter_hdr hdr;
+	struct wsm_udp_port_filter dhcp;
+	struct wsm_udp_port_filter upnp;
+	struct wsm_udp_port_filter mdns;
+} __packed;
+
+struct bes2600_ether_type_filter {
+	struct wsm_ether_type_filter_hdr hdr;
+	struct wsm_ether_type_filter ip;
+	struct wsm_ether_type_filter pae;
+	struct wsm_ether_type_filter wapi;
+} __packed;
+
+static struct bes2600_udp_port_filter bes2600_udp_port_filter_on = {
+	.hdr.nrFilters = 3,
+	.dhcp = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.portType = WSM_FILTER_PORT_TYPE_DST,
+		.udpPort = __cpu_to_le16(67),
+	},
+	.upnp = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.portType = WSM_FILTER_PORT_TYPE_DST,
+		.udpPort = __cpu_to_le16(1900),
+	},
+	.mdns = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.portType = WSM_FILTER_PORT_TYPE_DST,
+		.udpPort = __cpu_to_le16(5353),
+	},
+	/* Please add other known ports to be filtered out here and
+	 * update nrFilters field in the header.
+	 * Up to 4 filters are allowed. */
+};
+
+static struct wsm_udp_port_filter_hdr bes2600_udp_port_filter_off = {
+	.nrFilters = 0,
+};
+
+#define ETH_P_WAPI     0x88B4
+
+static struct bes2600_ether_type_filter bes2600_ether_type_filter_on = {
+	.hdr.nrFilters = 3,
+	.ip = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_OUT,
+		.etherType = __cpu_to_le16(ETH_P_IPV6),
+	},
+	.pae = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_PAE),
+	},
+	.wapi = {
+		.filterAction = WSM_FILTER_ACTION_FILTER_IN,
+		.etherType = __cpu_to_le16(ETH_P_WAPI),
+	},
+	/* Please add other known ether types to be filtered out here and
+	 * update nrFilters field in the header.
+	 * Up to 4 filters are allowed. */
+};
+
+static struct wsm_ether_type_filter_hdr bes2600_ether_type_filter_off = {
+	.nrFilters = 0,
+};
+
+static int __bes2600_wow_suspend(struct bes2600_vif *priv,
+				struct cfg80211_wowlan *wowlan);
+static int __bes2600_wow_resume(struct bes2600_vif *priv);
+
+
+/* private */
+struct bes2600_suspend_state {
+	unsigned long bss_loss_tmo;
+	unsigned long connection_loss_tmo;
+	unsigned long join_tmo;
+	unsigned long direct_probe;
+	unsigned long link_id_gc;
+};
+
+static long bes2600_suspend_work(struct delayed_work *work)
+{
+	int ret = cancel_delayed_work(work);
+	long tmo;
+	if (ret > 0) {
+		/* Timer is pending */
+		tmo = work->timer.expires - jiffies;
+		if (tmo < 0)
+			tmo = 0;
+	} else {
+		tmo = -1;
+	}
+	return tmo;
+}
+
+static int bes2600_resume_work(struct bes2600_common *hw_priv,
+			       struct delayed_work *work,
+			       unsigned long tmo)
+{
+	if ((long)tmo < 0)
+		return 1;
+
+	return queue_delayed_work(hw_priv->workqueue, work, tmo);
+}
+
+int bes2600_can_suspend(struct bes2600_common *priv)
+{
+	if (atomic_read(&priv->bh_rx)) {
+		wiphy_dbg(priv->hw->wiphy, "Suspend interrupted.\n");
+		return 0;
+	}
+	return 1;
+}
+EXPORT_SYMBOL_GPL(bes2600_can_suspend);
+
+int bes2600_wow_suspend(struct ieee80211_hw *hw, struct cfg80211_wowlan *wowlan)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv;
+	int i, ret = 0;
+	unsigned long begin, end, diff;
+
+	bes2600_info(BES2600_DBG_PM, "bes2600_wow_suspend enter\n");
+
+	WARN_ON(!atomic_read(&hw_priv->num_vifs));
+
+	/* reset wakeup reason to default */
+	bes2600_chrdev_wifi_update_wakeup_reason(0);
+
+	/* Do not suspend when datapath is not idle */
+	if (hw_priv->tx_queue_stats.num_queued[0]
+			+ hw_priv->tx_queue_stats.num_queued[1])
+		return -EBUSY;
+
+
+	/* Make sure there is no configuration requests in progress. */
+	if (down_trylock(&hw_priv->conf_lock))
+		return -EBUSY;
+
+	/* Do not suspend when scanning or ROC*/
+	if (down_trylock(&hw_priv->scan.lock))
+		goto revert1;
+
+	/* Do not suspend when probe is doing */
+	if (delayed_work_pending(&hw_priv->scan.probe_work))
+		goto revert2;
+
+	/* record suspend start time */
+	begin = jiffies;
+
+	/* wait uitil bes2600 finish current pending operation */
+	if (!bes2600_pwr_device_is_idle(hw_priv)) {
+		/* clear power busy event */
+		bes2600_pwr_set_busy_event_with_timeout(hw_priv, BES_PWR_LOCK_ON_TX, 10);
+
+		/* wait device enter lp mode */
+		if (wait_event_timeout(hw_priv->bes_power.dev_lp_wq,
+			bes2600_pwr_device_is_idle(hw_priv), HZ * 5) <= 0) {
+			bes2600_err(BES2600_DBG_PM, "wait device idle timeout\n");
+			goto revert2;
+		}
+	}
+
+	/* Lock TX. */
+	wsm_lock_tx_async(hw_priv);
+
+	/* mark suspend start to avoid device to exit ps mode when setting device */
+	bes2600_pwr_suspend_start(hw_priv);
+
+	/* set filters and offload based on interface */
+	bes2600_for_each_vif(hw_priv, priv, i) {
+		if ((i == (CW12XX_MAX_VIFS - 1)) || !priv)
+			continue;
+
+		ret = __bes2600_wow_suspend(priv,
+						wowlan);
+		if (ret) {
+			for (; i >= 0; i--) {
+				if (!hw_priv->vif_list[i])
+					continue;
+				priv = (struct bes2600_vif *)
+					hw_priv->vif_list[i]->drv_priv;
+				__bes2600_wow_resume(priv);
+			}
+			goto revert3;
+		}
+	}
+
+	/* mark suspend end */
+	bes2600_pwr_suspend_end(hw_priv);
+
+	/* Stop serving thread */
+	if (bes2600_bh_suspend(hw_priv)) {
+		bes2600_err(BES2600_DBG_PM, "%s: bes2600_bh_suspend failed\n",
+				__func__);
+		bes2600_wow_resume(hw);
+		return -EBUSY;
+	}
+
+	/* Force resume if event is coming from the device. */
+	if (atomic_read(&hw_priv->bh_rx)) {
+		bes2600_info(BES2600_DBG_PM, "%s: incoming event present - resume\n",
+				__func__);
+		bes2600_wow_resume(hw);
+		return -EAGAIN;
+	}
+
+	/* calculate the time consumed by bes2600 suspend flow */
+	end = jiffies;
+	diff = end - begin;
+	bes2600_info(BES2600_DBG_PM, "%s consume %d ms\n", __func__, jiffies_to_msecs(diff));
+
+	return 0;
+
+revert3:
+	bes2600_pwr_suspend_end(hw_priv);
+	wsm_unlock_tx(hw_priv);
+revert2:
+	up(&hw_priv->scan.lock);
+revert1:
+	up(&hw_priv->conf_lock);
+	return -EBUSY;
+}
+
+static void bes2600_set_ehter_and_udp_filter(struct bes2600_common *hw_priv,
+				struct wsm_ether_type_filter_hdr *ether_type, struct wsm_udp_port_filter_hdr *udp_type,
+				int if_id)
+{
+	/* Set UDP filter */
+	wsm_set_udp_port_filter(hw_priv, udp_type, if_id);
+
+	/* Set ethernet frame type filter */
+	wsm_set_ether_type_filter(hw_priv, ether_type, if_id);
+}
+
+static int __bes2600_wow_suspend(struct bes2600_vif *priv,
+				struct cfg80211_wowlan *wowlan)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct bes2600_pm_state_vif *pm_state_vif = &priv->pm_state_vif;
+	struct bes2600_suspend_state *state;
+	int ret;
+
+	/* Do not suspend when join work is scheduled */
+	if (work_pending(&priv->join_work))
+		goto revert1;
+
+	bes2600_set_ehter_and_udp_filter(hw_priv, &bes2600_ether_type_filter_on.hdr,
+				&bes2600_udp_port_filter_on.hdr, priv->if_id);
+
+  	if (priv->join_status == BES2600_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, true));
+
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = __cpu_to_le32(2);
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter, priv->if_id);
+       }
+
+	/* Allocate state */
+	state = kzalloc(sizeof(struct bes2600_suspend_state), GFP_KERNEL);
+	if (!state)
+		goto revert2;
+
+	/* Store delayed work states. */
+	state->bss_loss_tmo =
+		bes2600_suspend_work(&priv->bss_loss_work);
+	state->connection_loss_tmo =
+		bes2600_suspend_work(&priv->connection_loss_work);
+	state->join_tmo =
+		bes2600_suspend_work(&priv->join_timeout);
+	state->link_id_gc =
+		bes2600_suspend_work(&priv->link_id_gc_work);
+
+	ret = timer_pending(&priv->mcast_timeout);
+	if (ret)
+		goto revert3;
+
+	/* Store suspend state */
+	pm_state_vif->suspend_state = state;
+
+	return 0;
+
+revert3:
+	bes2600_resume_work(hw_priv, &priv->bss_loss_work,
+			state->bss_loss_tmo);
+	bes2600_resume_work(hw_priv, &priv->connection_loss_work,
+			state->connection_loss_tmo);
+	bes2600_resume_work(hw_priv, &priv->join_timeout,
+			state->join_tmo);
+	bes2600_resume_work(hw_priv, &priv->link_id_gc_work,
+			state->link_id_gc);
+	kfree(state);
+revert2:
+	wsm_set_udp_port_filter(hw_priv, &bes2600_udp_port_filter_off,
+				priv->if_id);
+	wsm_set_ether_type_filter(hw_priv, &bes2600_ether_type_filter_off,
+				  priv->if_id);
+
+	if (priv->join_status == BES2600_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, false));
+
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = __cpu_to_le32(1);
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter, priv->if_id);
+       }
+
+revert1:
+	up(&hw_priv->conf_lock);
+	return -EBUSY;
+}
+
+int bes2600_wow_resume(struct ieee80211_hw *hw)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv;
+	int i, ret = 0;
+
+	bes2600_info(BES2600_DBG_PM, "bes2600_wow_resume enter\n");
+	WARN_ON(!atomic_read(&hw_priv->num_vifs));
+
+	up(&hw_priv->scan.lock);
+
+	/* Resume BH thread */
+	WARN_ON(bes2600_bh_resume(hw_priv));
+
+	/* mark resume start to avoid device to exit ps mode when setting device */
+	bes2600_pwr_resume_start(hw_priv);
+
+	/* set filters and offload based on interface */
+	bes2600_for_each_vif(hw_priv, priv, i) {
+		if ((i == (CW12XX_MAX_VIFS - 1)) || !priv)
+			continue;
+		ret = __bes2600_wow_resume(priv);
+		if (ret)
+			break;
+	}
+
+	/* mark resume end */
+	bes2600_pwr_resume_end(hw_priv);
+
+	wsm_unlock_tx(hw_priv);
+	/* Unlock configuration mutex */
+	up(&hw_priv->conf_lock);
+
+	return ret;
+}
+
+static int __bes2600_wow_resume(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct bes2600_pm_state_vif *pm_state_vif = &priv->pm_state_vif;
+	struct bes2600_suspend_state *state;
+
+	state = pm_state_vif->suspend_state;
+	pm_state_vif->suspend_state = NULL;
+
+	if (priv->join_status == BES2600_JOIN_STATUS_AP)
+		WARN_ON(wsm_set_keepalive_filter(priv, false));
+
+	/* Set Multicast Address Filter */
+	if (priv->multicast_filter.numOfAddresses) {
+		priv->multicast_filter.enable = __cpu_to_le32(1);
+		wsm_set_multicast_filter(hw_priv, &priv->multicast_filter, priv->if_id);
+       }
+
+	/* Resume delayed work */
+	bes2600_resume_work(hw_priv, &priv->bss_loss_work,
+			state->bss_loss_tmo);
+	bes2600_resume_work(hw_priv, &priv->connection_loss_work,
+			state->connection_loss_tmo);
+	bes2600_resume_work(hw_priv, &priv->join_timeout,
+			state->join_tmo);
+	bes2600_resume_work(hw_priv, &priv->link_id_gc_work,
+			state->link_id_gc);
+
+	/* Remove UDP port filter */
+	wsm_set_udp_port_filter(hw_priv, &bes2600_udp_port_filter_off,
+				priv->if_id);
+
+	/* Remove ethernet frame type filter */
+	wsm_set_ether_type_filter(hw_priv, &bes2600_ether_type_filter_off,
+				  priv->if_id);
+	/* Free memory */
+	kfree(state);
+
+	return 0;
+}
diff --git a/drivers/staging/bes2600/pm.h b/drivers/staging/bes2600/pm.h
new file mode 100755
index 000000000000..dbf887367877
--- /dev/null
+++ b/drivers/staging/bes2600/pm.h
@@ -0,0 +1,35 @@
+/*
+ * Mac80211 power management interface for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2011, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef PM_H_INCLUDED
+#define PM_H_INCLUDED
+
+#ifdef CONFIG_PM
+
+/* extern */  struct bes2600_common;
+/* private */ struct bes2600_suspend_state;
+
+struct bes2600_pm_state_vif {
+	struct bes2600_suspend_state *suspend_state;
+};
+
+int bes2600_can_suspend(struct bes2600_common *priv);
+int bes2600_wow_suspend(struct ieee80211_hw *hw,
+		       struct cfg80211_wowlan *wowlan);
+int bes2600_wow_resume(struct ieee80211_hw *hw);
+#else
+static inline int bes2600_can_suspend(struct bes2600_common *priv)
+{
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+#endif
diff --git a/drivers/staging/bes2600/queue.c b/drivers/staging/bes2600/queue.c
new file mode 100755
index 000000000000..85ac64a69039
--- /dev/null
+++ b/drivers/staging/bes2600/queue.c
@@ -0,0 +1,788 @@
+/*
+ * O(1) TX queue with built-in allocator for BES2600 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/mac80211.h>
+#include <linux/sched.h>
+#include <linux/version.h>
+#include "bes2600.h"
+#include "queue.h"
+#include "debug.h"
+
+/* private */ struct bes2600_queue_item
+{
+	struct list_head	head;
+	struct sk_buff		*skb;
+	u32			packetID;
+	unsigned long		queue_timestamp;
+	unsigned long		xmit_timestamp;
+	struct bes2600_txpriv	txpriv;
+	u8			generation;
+};
+
+int bes2600_queue_get_skb_and_timestamp(struct bes2600_queue *queue, u32 packetID,
+			struct sk_buff **skb, struct bes2600_txpriv **txpriv,
+			unsigned long *timestamp)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct bes2600_queue_item *item;
+	bes2600_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+	if (unlikely(item_id >= (u8) queue->capacity))
+		return -EINVAL;
+	item = &queue->pool[item_id];
+	spin_lock_bh(&queue->lock);
+	BUG_ON(queue_id != queue->queue_id);
+	if (unlikely(queue_generation != queue->generation)) {
+		WARN(1, "queue generation mismatch, %u, expect %u, if_id: %u.\n",
+		queue_generation, queue->generation, if_id);
+		ret = -ENOENT;
+	} else if (unlikely(item_generation != item->generation)) {
+		WARN(1, "item generation mismatch, %u, expect %u.\n",
+		item_generation, item->generation);
+		ret = -ENOENT;
+	} else if (unlikely(WARN_ON(!item->skb))) {
+		ret = -ENOENT;
+	} else {
+		*skb = item->skb;
+		*txpriv = &item->txpriv;
+		*timestamp = item->xmit_timestamp;
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+
+static inline void __bes2600_queue_lock(struct bes2600_queue *queue)
+{
+	struct bes2600_queue_stats *stats = queue->stats;
+	if (queue->tx_locked_cnt++ == 0) {
+		bes2600_dbg(BES2600_DBG_TXRX, "[TX] Queue %d is locked.\n",
+				queue->queue_id);
+		ieee80211_stop_queue(stats->hw_priv->hw, queue->queue_id);
+	}
+}
+
+static inline void __bes2600_queue_unlock(struct bes2600_queue *queue)
+{
+	struct bes2600_queue_stats *stats = queue->stats;
+	BUG_ON(!queue->tx_locked_cnt);
+	if (--queue->tx_locked_cnt == 0) {
+		bes2600_dbg(BES2600_DBG_TXRX, "[TX] Queue %d is unlocked.\n",
+				queue->queue_id);
+		ieee80211_wake_queue(stats->hw_priv->hw, queue->queue_id);
+	}
+}
+
+
+
+static inline u32 bes2600_queue_make_packet_id(u8 queue_generation, u8 queue_id,
+						u8 item_generation, u8 item_id,
+						u8 if_id, u8 link_id)
+{
+	/*TODO:COMBO: Add interfaceID to the packetID */
+	return ((u32)item_id << 0) |
+		((u32)item_generation << 8) |
+		((u32)queue_id << 16) |
+		((u32)if_id << 20) |
+		((u32)link_id << 24) |
+		((u32)queue_generation << 28);
+}
+
+static void bes2600_queue_post_gc(struct bes2600_queue_stats *stats,
+				 struct list_head *gc_list)
+{
+	struct bes2600_queue_item *item;
+
+	while (!list_empty(gc_list)) {
+		item = list_first_entry(
+			gc_list, struct bes2600_queue_item, head);
+		list_del(&item->head);
+		stats->skb_dtor(stats->hw_priv, item->skb, &item->txpriv);
+		kfree(item);
+	}
+}
+
+static void bes2600_queue_register_post_gc(struct list_head *gc_list,
+				     struct bes2600_queue_item *item)
+{
+	struct bes2600_queue_item *gc_item;
+	gc_item = kmalloc(sizeof(struct bes2600_queue_item),
+			GFP_ATOMIC);
+	BUG_ON(!gc_item);
+	memcpy(gc_item, item, sizeof(struct bes2600_queue_item));
+	list_add_tail(&gc_item->head, gc_list);
+}
+
+static void __bes2600_queue_gc(struct bes2600_queue *queue,
+			      struct list_head *head,
+			      bool unlock)
+{
+	struct bes2600_queue_stats *stats = queue->stats;
+	struct bes2600_queue_item *item = NULL;
+	struct bes2600_vif *priv;
+	int if_id;
+	bool wakeup_stats = false;
+
+	while (!list_empty(&queue->queue)) {
+		struct bes2600_txpriv *txpriv;
+		item = list_first_entry(
+			&queue->queue, struct bes2600_queue_item, head);
+		if (jiffies - item->queue_timestamp < queue->ttl)
+			break;
+
+		txpriv = &item->txpriv;
+		if_id = txpriv->if_id;
+		--queue->num_queued;
+		--queue->num_queued_vif[if_id];
+		--queue->link_map_cache[if_id][txpriv->link_id];
+		spin_lock_bh(&stats->lock);
+		--stats->num_queued[if_id];
+		if (!--stats->link_map_cache[if_id][txpriv->link_id])
+			wakeup_stats = true;
+		spin_unlock_bh(&stats->lock);
+		priv = cw12xx_hwpriv_to_vifpriv(stats->hw_priv, if_id);
+		if (priv) {
+			bes2600_debug_tx_ttl(priv);
+			spin_unlock(&priv->vif_lock);
+		}
+		bes2600_queue_register_post_gc(head, item);
+		item->skb = NULL;
+		list_move_tail(&item->head, &queue->free_pool);
+	}
+
+	if (wakeup_stats)
+		wake_up(&stats->wait_link_id_empty);
+
+	if (queue->overfull) {
+		if (queue->num_queued <= ((stats->hw_priv->vif0_throttle +
+						stats->hw_priv->vif1_throttle + 2)/2)) {
+			queue->overfull = false;
+			if (unlock)
+				__bes2600_queue_unlock(queue);
+		} else if (item) {
+			unsigned long tmo = item->queue_timestamp + queue->ttl;
+			mod_timer(&queue->gc, tmo);
+			bes2600_pwr_set_busy_event_with_timeout_async(stats->hw_priv,
+				BES_PWR_LOCK_ON_QUEUE_GC, jiffies_to_msecs(tmo - jiffies));
+		}
+	}
+}
+
+static void bes2600_queue_gc(struct timer_list *t)
+{
+	LIST_HEAD(list);
+	struct bes2600_queue *queue = from_timer(queue, t, gc);
+
+	spin_lock_bh(&queue->lock);
+	__bes2600_queue_gc(queue, &list, true);
+	spin_unlock_bh(&queue->lock);
+	bes2600_queue_post_gc(queue->stats, &list);
+}
+
+int bes2600_queue_stats_init(struct bes2600_queue_stats *stats,
+			    size_t map_capacity,
+			    bes2600_queue_skb_dtor_t skb_dtor,
+			    struct bes2600_common *hw_priv)
+{
+	int i;
+
+	memset(stats, 0, sizeof(*stats));
+	stats->map_capacity = map_capacity;
+	stats->skb_dtor = skb_dtor;
+	stats->hw_priv = hw_priv;
+	spin_lock_init(&stats->lock);
+	init_waitqueue_head(&stats->wait_link_id_empty);
+	for (i = 0; i < CW12XX_MAX_VIFS; i++) {
+		stats->link_map_cache[i] = kzalloc(map_capacity * sizeof(int),
+			GFP_KERNEL);
+		if (!stats->link_map_cache[i]) {
+			for (; i >= 0; i--)
+				kfree(stats->link_map_cache[i]);
+			return -ENOMEM;
+		}
+	}
+
+	return 0;
+}
+
+int bes2600_queue_init(struct bes2600_queue *queue,
+		      struct bes2600_queue_stats *stats,
+		      u8 queue_id,
+		      size_t capacity,
+		      unsigned long ttl)
+{
+	int i;
+
+	memset(queue, 0, sizeof(*queue));
+	queue->stats = stats;
+	queue->capacity = capacity;
+	queue->queue_id = queue_id;
+	queue->ttl = ttl;
+	INIT_LIST_HEAD(&queue->queue);
+	INIT_LIST_HEAD(&queue->pending);
+	INIT_LIST_HEAD(&queue->free_pool);
+	spin_lock_init(&queue->lock);
+	timer_setup(&queue->gc, bes2600_queue_gc, 0);
+	queue->pool = kzalloc(sizeof(struct bes2600_queue_item) * capacity,
+			GFP_KERNEL);
+	if (!queue->pool)
+		return -ENOMEM;
+
+	for (i = 0; i < CW12XX_MAX_VIFS; i++) {
+		queue->link_map_cache[i] =
+				kzalloc(stats->map_capacity * sizeof(int),
+			GFP_KERNEL);
+		if (!queue->link_map_cache[i]) {
+			for (; i >= 0; i--)
+				kfree(queue->link_map_cache[i]);
+			kfree(queue->pool);
+			queue->pool = NULL;
+			return -ENOMEM;
+		}
+	}
+
+	for (i = 0; i < capacity; ++i)
+		list_add_tail(&queue->pool[i].head, &queue->free_pool);
+
+	return 0;
+}
+
+/* TODO:COMBO: Flush only a particular interface specific parts */
+int bes2600_queue_clear(struct bes2600_queue *queue, int if_id)
+{
+	int i, cnt, iter;
+	struct bes2600_queue_stats *stats = queue->stats;
+	LIST_HEAD(gc_list);
+
+	cnt = 0;
+	spin_lock_bh(&queue->lock);
+	queue->generation++;
+	queue->generation &= 0xf;
+	list_splice_tail_init(&queue->queue, &queue->pending);
+	while (!list_empty(&queue->pending)) {
+		struct bes2600_queue_item *item = list_first_entry(
+			&queue->pending, struct bes2600_queue_item, head);
+		WARN_ON(!item->skb);
+		if (CW12XX_ALL_IFS == if_id || item->txpriv.if_id == if_id) {
+			bes2600_queue_register_post_gc(&gc_list, item);
+			item->skb = NULL;
+			list_move_tail(&item->head, &queue->free_pool);
+			cnt++;
+		}
+	}
+	queue->num_queued -= cnt;
+	queue->num_pending -= cnt;
+	if (CW12XX_ALL_IFS != if_id) {
+		queue->num_queued_vif[if_id] = 0;
+		queue->num_pending_vif[if_id] = 0;
+	} else {
+		for (iter = 0; iter < CW12XX_MAX_VIFS; iter++) {
+			queue->num_queued_vif[iter] = 0;
+			queue->num_pending_vif[iter] = 0;
+		}
+	}
+	spin_lock_bh(&stats->lock);
+	if (CW12XX_ALL_IFS != if_id) {
+		for (i = 0; i < stats->map_capacity; ++i) {
+			stats->num_queued[if_id] -=
+				queue->link_map_cache[if_id][i];
+			stats->link_map_cache[if_id][i] -=
+				queue->link_map_cache[if_id][i];
+			queue->link_map_cache[if_id][i] = 0;
+		}
+	} else {
+		for (iter = 0; iter < CW12XX_MAX_VIFS; iter++) {
+			for (i = 0; i < stats->map_capacity; ++i) {
+				stats->num_queued[iter] -=
+					queue->link_map_cache[iter][i];
+				stats->link_map_cache[iter][i] -=
+					queue->link_map_cache[iter][i];
+				queue->link_map_cache[iter][i] = 0;
+			}
+		}
+	}
+	spin_unlock_bh(&stats->lock);
+	if (unlikely(queue->overfull)) {
+		queue->overfull = false;
+		__bes2600_queue_unlock(queue);
+	}
+	spin_unlock_bh(&queue->lock);
+	wake_up(&stats->wait_link_id_empty);
+	bes2600_queue_post_gc(stats, &gc_list);
+	return 0;
+}
+
+void bes2600_queue_stats_deinit(struct bes2600_queue_stats *stats)
+{
+	int i;
+
+	for (i = 0; i < CW12XX_MAX_VIFS ; i++) {
+		kfree(stats->link_map_cache[i]);
+		stats->link_map_cache[i] = NULL;
+	}
+}
+
+void bes2600_queue_deinit(struct bes2600_queue *queue)
+{
+	int i;
+
+	bes2600_queue_clear(queue, CW12XX_ALL_IFS);
+	del_timer_sync(&queue->gc);
+	INIT_LIST_HEAD(&queue->free_pool);
+	kfree(queue->pool);
+	for (i = 0; i < CW12XX_MAX_VIFS; i++) {
+		kfree(queue->link_map_cache[i]);
+		queue->link_map_cache[i] = NULL;
+	}
+	queue->pool = NULL;
+	queue->capacity = 0;
+}
+
+size_t bes2600_queue_get_num_queued(struct bes2600_vif *priv,
+				   struct bes2600_queue *queue,
+				   u32 link_id_map)
+{
+	size_t ret;
+	int i, bit;
+	size_t map_capacity = queue->stats->map_capacity;
+
+	if (!link_id_map)
+		return 0;
+
+	spin_lock_bh(&queue->lock);
+	if (likely(link_id_map == (u32) -1)) {
+		ret = queue->num_queued_vif[priv->if_id] -
+			queue->num_pending_vif[priv->if_id];
+	} else {
+		ret = 0;
+		for (i = 0, bit = 1; i < map_capacity; ++i, bit <<= 1) {
+			if (link_id_map & bit)
+				ret +=
+				queue->link_map_cache[priv->if_id][i];
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+int bes2600_queue_put(struct bes2600_queue *queue,
+		     struct sk_buff *skb,
+		     struct bes2600_txpriv *txpriv)
+{
+	int ret = 0;
+
+	LIST_HEAD(gc_list);
+	struct bes2600_queue_stats *stats = queue->stats;
+	/* TODO:COMBO: Add interface ID info to queue item */
+
+	if (txpriv->link_id >= queue->stats->map_capacity)
+		return -EINVAL;
+
+	spin_lock_bh(&queue->lock);
+	if (!WARN_ON(list_empty(&queue->free_pool))) {
+		struct bes2600_queue_item *item = list_first_entry(
+			&queue->free_pool, struct bes2600_queue_item, head);
+		BUG_ON(item->skb);
+
+		list_move_tail(&item->head, &queue->queue);
+		item->skb = skb;
+		item->txpriv = *txpriv;
+		item->generation = 0;
+		item->packetID = bes2600_queue_make_packet_id(
+			queue->generation, queue->queue_id,
+			item->generation, item - queue->pool,
+			txpriv->if_id, txpriv->raw_link_id);
+		item->queue_timestamp = jiffies;
+		if (skb_tailroom(skb) >= 4) {
+			u32 *extra_data;
+			extra_data = (u32 *)skb_tail_pointer(skb);
+			*extra_data = (u32)jiffies_to_msecs(item->queue_timestamp);
+		}
+
+		++queue->num_queued;
+		++queue->num_queued_vif[txpriv->if_id];
+		++queue->link_map_cache[txpriv->if_id][txpriv->link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[txpriv->if_id];
+		++stats->link_map_cache[txpriv->if_id][txpriv->link_id];
+		spin_unlock_bh(&stats->lock);
+
+		/*
+		 * TX may happen in parallel sometimes.
+		 * Leave extra queue slots so we don't overflow.
+		 */
+		if (queue->overfull == false &&
+				queue->num_queued >=
+		((stats->hw_priv->vif0_throttle +
+			stats->hw_priv->vif1_throttle + 2)
+				- (num_present_cpus() - 1))) {
+			queue->overfull = true;
+			__bes2600_queue_lock(queue);
+			mod_timer(&queue->gc, jiffies);
+		}
+	} else {
+		ret = -ENOENT;
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+int bes2600_queue_get(struct bes2600_queue *queue,
+			int if_id,
+		     u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct bes2600_txpriv **txpriv)
+{
+	int ret = -ENOENT;
+	struct bes2600_queue_item *item = NULL;
+	struct bes2600_queue_stats *stats = queue->stats;
+	bool wakeup_stats = false;
+
+	spin_lock_bh(&queue->lock);
+	list_for_each_entry(item, &queue->queue, head) {
+		if ((item->txpriv.if_id == if_id) &&
+			(link_id_map & BIT(item->txpriv.link_id))) {
+			ret = 0;
+			break;
+		}
+	}
+
+	if (!ret) {
+		*tx = (struct wsm_tx *)item->skb->data;
+		*tx_info = IEEE80211_SKB_CB(item->skb);
+		*txpriv = &item->txpriv;
+		(*tx)->packetID = __cpu_to_le32(item->packetID);
+		list_move_tail(&item->head, &queue->pending);
+		++queue->num_pending;
+		++queue->num_pending_vif[item->txpriv.if_id];
+		--queue->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+		item->xmit_timestamp = jiffies;
+
+		spin_lock_bh(&stats->lock);
+		--stats->num_queued[item->txpriv.if_id];
+		if (!--stats->link_map_cache[item->txpriv.if_id]
+					[item->txpriv.link_id])
+			wakeup_stats = true;
+
+		spin_unlock_bh(&stats->lock);
+	} else {
+		bes2600_warn(BES2600_DBG_TXRX, "%s: queue get failed, if_id = %d, link_id_map = %u\n", __func__, if_id, link_id_map);
+	}
+
+	spin_unlock_bh(&queue->lock);
+	if (wakeup_stats)
+		wake_up(&stats->wait_link_id_empty);
+	return ret;
+}
+
+int bes2600_queue_requeue(struct bes2600_queue *queue, u32 packetID, bool check)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct bes2600_queue_item *item;
+	struct bes2600_queue_stats *stats = queue->stats;
+
+	bes2600_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+	if (check && item->txpriv.if_id == CW12XX_GENERIC_IF_ID) {
+		bes2600_dbg(BES2600_DBG_TXRX, "Requeued frame dropped for "
+						"generic interface id.\n");
+		bes2600_queue_remove(queue, packetID);
+		return 0;
+	}
+
+	/*if_id = item->txpriv.if_id;*/
+
+	spin_lock_bh(&queue->lock);
+	BUG_ON(queue_id != queue->queue_id);
+	if (unlikely(queue_generation != queue->generation)) {
+		bes2600_info(BES2600_DBG_TXRX, "%s, Queue Generation is not equal\n", __func__);
+		ret = 0;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		WARN_ON(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		WARN_ON(1);
+		ret = -ENOENT;
+	} else {
+		--queue->num_pending;
+		--queue->num_pending_vif[if_id];
+		++queue->link_map_cache[if_id][item->txpriv.link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[item->txpriv.if_id];
+		++stats->link_map_cache[if_id][item->txpriv.link_id];
+		spin_unlock_bh(&stats->lock);
+
+		item->generation = ++item_generation;
+		item->packetID = bes2600_queue_make_packet_id(
+			queue_generation, queue_id, item_generation, item_id,
+			if_id, link_id);
+		list_move(&item->head, &queue->queue);
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+int bes2600_sw_retry_requeue(struct bes2600_common *hw_priv,
+	struct bes2600_queue *queue, u32 packetID, bool check)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct bes2600_queue_item *item;
+	struct bes2600_queue_stats *stats = queue->stats;
+	bes2600_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+	item = &queue->pool[item_id];
+	if (check && item->txpriv.if_id == CW12XX_GENERIC_IF_ID) {
+		bes2600_dbg(BES2600_DBG_TXRX, "Requeued frame dropped for "
+						"generic interface id.\n");
+		bes2600_queue_remove(queue, packetID);
+		return 0;
+	}
+
+	/*if_id = item->txpriv.if_id;*/
+	spin_lock_bh(&queue->lock);
+	BUG_ON(queue_id != queue->queue_id);
+	if (unlikely(queue_generation != queue->generation)) {
+		bes2600_info(BES2600_DBG_TXRX, "%s, Queue Generation is not equal\n", __func__);
+		ret = 0;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		WARN_ON(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		WARN_ON(1);
+		ret = -ENOENT;
+	} else {
+		--queue->num_pending;
+		--queue->num_pending_vif[if_id];
+		++queue->link_map_cache[if_id][item->txpriv.link_id];
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[item->txpriv.if_id];
+		++stats->link_map_cache[if_id][item->txpriv.link_id];
+		spin_unlock_bh(&stats->lock);
+		item->packetID = bes2600_queue_make_packet_id(
+			queue_generation, queue_id, item_generation, item_id,
+			if_id, link_id);
+
+		list_move(&item->head, &queue->queue);
+
+	}
+
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+
+int bes2600_queue_requeue_all(struct bes2600_queue *queue)
+{
+	struct bes2600_queue_stats *stats = queue->stats;
+	spin_lock_bh(&queue->lock);
+	while (!list_empty(&queue->pending)) {
+		struct bes2600_queue_item *item = list_entry(
+			queue->pending.prev, struct bes2600_queue_item, head);
+
+		--queue->num_pending;
+		--queue->num_pending_vif[item->txpriv.if_id];
+		++queue->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+
+		spin_lock_bh(&stats->lock);
+		++stats->num_queued[item->txpriv.if_id];
+		++stats->link_map_cache[item->txpriv.if_id]
+				[item->txpriv.link_id];
+		spin_unlock_bh(&stats->lock);
+
+		++item->generation;
+		item->packetID = bes2600_queue_make_packet_id(
+			queue->generation, queue->queue_id,
+			item->generation, item - queue->pool,
+			item->txpriv.if_id, item->txpriv.raw_link_id);
+		list_move(&item->head, &queue->queue);
+	}
+	spin_unlock_bh(&queue->lock);
+
+	return 0;
+}
+int bes2600_queue_remove(struct bes2600_queue *queue, u32 packetID)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct bes2600_queue_item *item;
+	struct bes2600_queue_stats *stats = queue->stats;
+	struct sk_buff *gc_skb = NULL;
+	struct bes2600_txpriv gc_txpriv;
+
+	bes2600_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+
+	spin_lock_bh(&queue->lock);
+	BUG_ON(queue_id != queue->queue_id);
+	/*TODO:COMBO:Add check for interface ID also */
+	if (unlikely(queue_generation != queue->generation)) {
+		bes2600_info(BES2600_DBG_TXRX, "%s, Queue Generation is not equal\n", __func__);
+		ret = 0;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		WARN_ON(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		WARN_ON(1);
+		ret = -ENOENT;
+	} else {
+		gc_txpriv = item->txpriv;
+		gc_skb = item->skb;
+		item->skb = NULL;
+		--queue->num_pending;
+		--queue->num_pending_vif[if_id];
+		--queue->num_queued;
+		--queue->num_queued_vif[if_id];
+		++queue->num_sent;
+		++item->generation;
+
+		/* Do not use list_move_tail here, but list_move:
+		 * try to utilize cache row.
+		 */
+		list_move(&item->head, &queue->free_pool);
+
+		if (unlikely(queue->overfull) &&
+		    (queue->num_queued <= ((stats->hw_priv->vif0_throttle + stats->hw_priv->vif1_throttle + 2) / 2))) {
+			queue->overfull = false;
+			__bes2600_queue_unlock(queue);
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+
+	if (gc_skb)
+		stats->skb_dtor(stats->hw_priv, gc_skb, &gc_txpriv);
+
+	return ret;
+}
+
+int bes2600_queue_get_skb(struct bes2600_queue *queue, u32 packetID,
+			 struct sk_buff **skb,
+			 const struct bes2600_txpriv **txpriv)
+{
+	int ret = 0;
+	u8 queue_generation, queue_id, item_generation, item_id, if_id, link_id;
+	struct bes2600_queue_item *item;
+
+	bes2600_queue_parse_id(packetID, &queue_generation, &queue_id,
+				&item_generation, &item_id, &if_id, &link_id);
+
+	item = &queue->pool[item_id];
+
+	spin_lock_bh(&queue->lock);
+	BUG_ON(queue_id != queue->queue_id);
+	/* TODO:COMBO: Add check for interface ID here */
+	if (unlikely(queue_generation != queue->generation)) {
+		bes2600_info(BES2600_DBG_TXRX, "%s, Queue Generation is not equal\n", __func__);
+		ret = -EINVAL;
+	} else if (unlikely(item_id >= (unsigned) queue->capacity)) {
+		WARN_ON(1);
+		ret = -EINVAL;
+	} else if (unlikely(item->generation != item_generation)) {
+		bes2600_info(BES2600_DBG_TXRX, "%s, item_generation =%u, item_id =%u link_id=%u queue_generation =%u packetID =%u\n",
+			__func__, item_generation, item_id, link_id, queue_generation, packetID);
+		WARN_ON(1);
+		ret = -ENOENT;
+	} else {
+		*skb = item->skb;
+		*txpriv = &item->txpriv;
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+void bes2600_queue_lock(struct bes2600_queue *queue)
+{
+	spin_lock_bh(&queue->lock);
+	__bes2600_queue_lock(queue);
+	spin_unlock_bh(&queue->lock);
+}
+
+void bes2600_queue_unlock(struct bes2600_queue *queue)
+{
+	spin_lock_bh(&queue->lock);
+	__bes2600_queue_unlock(queue);
+	spin_unlock_bh(&queue->lock);
+}
+
+bool bes2600_queue_get_xmit_timestamp(struct bes2600_queue *queue,
+				     unsigned long *timestamp, int if_id,
+				     u32 pending_frameID)
+{
+	struct bes2600_queue_item *item;
+	bool ret;
+
+	spin_lock_bh(&queue->lock);
+	ret = !list_empty(&queue->pending);
+	if (ret) {
+		list_for_each_entry(item, &queue->pending, head) {
+			if (((if_id == CW12XX_GENERIC_IF_ID) ||
+				(if_id == CW12XX_ALL_IFS) ||
+					(item->txpriv.if_id == if_id)) &&
+					(item->packetID != pending_frameID)) {
+				if (time_before(item->xmit_timestamp,
+							*timestamp))
+					*timestamp = item->xmit_timestamp;
+			}
+		}
+	}
+	spin_unlock_bh(&queue->lock);
+	return ret;
+}
+
+bool bes2600_queue_stats_is_empty(struct bes2600_queue_stats *stats,
+				 u32 link_id_map, int if_id)
+{
+	bool empty = true;
+
+	spin_lock_bh(&stats->lock);
+	if (link_id_map == (u32)-1)
+		empty = stats->num_queued[if_id] == 0;
+	else {
+		int i, if_id;
+		for (if_id = 0; if_id < CW12XX_MAX_VIFS; if_id++) {
+			for (i = 0; i < stats->map_capacity; ++i) {
+				if (link_id_map & BIT(i)) {
+					if (stats->link_map_cache[if_id][i]) {
+						empty = false;
+						break;
+					}
+				}
+			}
+		}
+	}
+	spin_unlock_bh(&stats->lock);
+
+	return empty;
+}
+
+void bes2600_queue_iterate_pending_packet(struct bes2600_queue *queue,
+	void (*iterate_cb)(struct bes2600_common *hw_priv, struct sk_buff *skb))
+{
+	struct bes2600_queue_item *item = NULL;
+
+	if(list_empty(&queue->pending))
+		return;
+
+	list_for_each_entry(item, &queue->pending, head) {
+		iterate_cb(queue->stats->hw_priv, item->skb);
+	}
+}
\ No newline at end of file
diff --git a/drivers/staging/bes2600/queue.h b/drivers/staging/bes2600/queue.h
new file mode 100755
index 000000000000..8494682b7c4b
--- /dev/null
+++ b/drivers/staging/bes2600/queue.h
@@ -0,0 +1,157 @@
+/*
+ * O(1) TX queue with built-in allocator for BES2600 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_QUEUE_H_INCLUDED
+#define BES2600_QUEUE_H_INCLUDED
+
+/* private */ struct bes2600_queue_item;
+
+/* extern */ struct sk_buff;
+/* extern */ struct wsm_tx;
+/* extern */ struct bes2600_common;
+/* extern */ struct bes2600_vif;
+/* extern */ struct ieee80211_tx_queue_stats;
+/* extern */ struct bes2600_txpriv;
+
+/* forward */ struct bes2600_queue_stats;
+
+typedef void (*bes2600_queue_skb_dtor_t)(struct bes2600_common *priv,
+					struct sk_buff *skb,
+					const struct bes2600_txpriv *txpriv);
+
+struct bes2600_queue {
+	struct bes2600_queue_stats *stats;
+	size_t			capacity;
+	size_t			num_queued;
+	size_t			num_queued_vif[CW12XX_MAX_VIFS];
+	size_t			num_pending;
+	size_t			num_pending_vif[CW12XX_MAX_VIFS];
+	size_t			num_sent;
+	struct bes2600_queue_item *pool;
+	struct list_head	queue;
+	struct list_head	free_pool;
+	struct list_head	pending;
+	int			tx_locked_cnt;
+	int			*link_map_cache[CW12XX_MAX_VIFS];
+	bool			overfull;
+	spinlock_t		lock;
+	u8			queue_id;
+	u8			generation;
+	struct timer_list	gc;
+	unsigned long		ttl;
+};
+
+struct bes2600_queue_stats {
+	spinlock_t		lock;
+	int			*link_map_cache[CW12XX_MAX_VIFS];
+	int			num_queued[CW12XX_MAX_VIFS];
+	size_t			map_capacity;
+	wait_queue_head_t	wait_link_id_empty;
+	bes2600_queue_skb_dtor_t	skb_dtor;
+	struct bes2600_common	*hw_priv;
+};
+
+struct bes2600_txpriv {
+	u8 link_id;
+	u8 raw_link_id;
+	u8 tid;
+	u8 rate_id;
+	u8 offset;
+	u8 if_id;
+	u8 raw_if_id;
+	u8 retry_count;
+};
+
+int bes2600_queue_stats_init(struct bes2600_queue_stats *stats,
+			    size_t map_capacity,
+			    bes2600_queue_skb_dtor_t skb_dtor,
+			    struct bes2600_common *priv);
+int bes2600_queue_init(struct bes2600_queue *queue,
+		      struct bes2600_queue_stats *stats,
+		      u8 queue_id,
+		      size_t capacity,
+		      unsigned long ttl);
+int bes2600_queue_clear(struct bes2600_queue *queue, int if_id);
+void bes2600_queue_stats_deinit(struct bes2600_queue_stats *stats);
+void bes2600_queue_deinit(struct bes2600_queue *queue);
+
+size_t bes2600_queue_get_num_queued(struct bes2600_vif *priv,
+				   struct bes2600_queue *queue,
+				   u32 link_id_map);
+int bes2600_queue_put(struct bes2600_queue *queue,
+		     struct sk_buff *skb,
+		     struct bes2600_txpriv *txpriv);
+int bes2600_queue_get(struct bes2600_queue *queue,
+			int if_id,
+		     u32 link_id_map,
+		     struct wsm_tx **tx,
+		     struct ieee80211_tx_info **tx_info,
+		     struct bes2600_txpriv **txpriv);
+int bes2600_queue_requeue(struct bes2600_queue *queue, u32 packetID, bool check);
+int bes2600_queue_requeue_all(struct bes2600_queue *queue);
+int bes2600_queue_remove(struct bes2600_queue *queue,
+			u32 packetID);
+int bes2600_queue_get_skb(struct bes2600_queue *queue, u32 packetID,
+			 struct sk_buff **skb,
+			 const struct bes2600_txpriv **txpriv);
+void bes2600_queue_lock(struct bes2600_queue *queue);
+void bes2600_queue_unlock(struct bes2600_queue *queue);
+bool bes2600_queue_get_xmit_timestamp(struct bes2600_queue *queue,
+				     unsigned long *timestamp, int if_id,
+				     u32 pending_frameID);
+
+
+bool bes2600_queue_stats_is_empty(struct bes2600_queue_stats *stats,
+				 u32 link_id_map, int if_id);
+
+static inline void bes2600_queue_parse_id(u32 packetID, u8 *queue_generation,
+        u8 *queue_id,
+         u8 *item_generation,
+        u8 *item_id,
+        u8 *if_id,
+        u8 *link_id)
+{
+    *item_id        = (packetID >>  0) & 0xFF;
+    *item_generation    = (packetID >>  8) & 0xFF;
+    *queue_id       = (packetID >> 16) & 0xF;
+    *if_id          = (packetID >> 20) & 0xF;
+    *link_id        = (packetID >> 24) & 0xF;
+    *queue_generation   = (packetID >> 28) & 0xF;
+}
+static inline u8 bes2600_queue_get_queue_id(u32 packetID)
+{
+	return (packetID >> 16) & 0xF;
+}
+
+static inline u8 bes2600_queue_get_if_id(u32 packetID)
+{
+	return (packetID >> 20) & 0xF;
+}
+
+static inline u8 bes2600_queue_get_link_id(u32 packetID)
+{
+	return (packetID >> 24) & 0xF;
+}
+
+static inline u8 bes2600_queue_get_generation(u32 packetID)
+{
+	return (packetID >>  8) & 0xFF;
+}
+
+int bes2600_queue_get_skb_and_timestamp(struct bes2600_queue *queue, u32 packetID,
+			struct sk_buff **skb, struct bes2600_txpriv **txpriv,
+			unsigned long *timestamp);
+int bes2600_sw_retry_requeue(struct bes2600_common *hw_priv,
+	struct bes2600_queue *queue, u32 packetID, bool check);
+void bes2600_queue_iterate_pending_packet(struct bes2600_queue *queue,
+	void (*iterate_cb)(struct bes2600_common *hw_priv, struct sk_buff *skb));
+
+#endif /* BES2600_QUEUE_H_INCLUDED */
diff --git a/drivers/staging/bes2600/sbus.h b/drivers/staging/bes2600/sbus.h
new file mode 100755
index 000000000000..7aad92fa44bf
--- /dev/null
+++ b/drivers/staging/bes2600/sbus.h
@@ -0,0 +1,84 @@
+/*
+ * Common sbus abstraction layer interface for bes2600 wireless driver
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_SBUS_H
+#define BES2600_SBUS_H
+
+/*
+ * sbus priv forward definition.
+ * Implemented and instantiated in particular modules.
+ */
+struct sbus_priv;
+struct bes2600_common;
+
+typedef void (*sbus_irq_handler)(void *priv);
+
+enum SUBSYSTEM {
+	SUBSYSTEM_MCU = 0,
+	SUBSYSTEM_WIFI,
+	SUBSYSTEM_BT,
+	SUBSYSTEM_BT_LP,
+};
+
+enum GPIO_WAKE_FLAG
+{
+	GPIO_WAKE_FLAG_MCU = 0,
+	GPIO_WAKE_FLAG_WIFI_ON,
+	GPIO_WAKE_FLAG_WIFI_OFF,
+	GPIO_WAKE_FLAG_BT_ON,
+	GPIO_WAKE_FLAG_BT_OFF,
+	GPIO_WAKE_FLAG_BT_LP_ON,
+	GPIO_WAKE_FLAG_BT_LP_OFF,
+	GPIO_WAKE_FLAG_HOST_SUSPEND,
+	GPIO_WAKE_FLAG_HOST_RESUME,
+	GPIO_WAKE_FLAG_SDIO_RX,
+	GPIO_WAKE_FLAG_SDIO_PROBE,
+};
+
+struct sbus_ops {
+	int (*init)(struct sbus_priv *self, struct bes2600_common *ar);
+	int (*sbus_memcpy_fromio)(struct sbus_priv *self, unsigned int addr,
+					void *dst, int count);
+	int (*sbus_memcpy_toio)(struct sbus_priv *self, unsigned int addr,
+					const void *src, int count);
+	void (*lock)(struct sbus_priv *self);
+	void (*unlock)(struct sbus_priv *self);
+	int (*irq_subscribe)(struct sbus_priv *self, sbus_irq_handler handler,
+				void *priv);
+	int (*irq_unsubscribe)(struct sbus_priv *self);
+	int (*reset)(struct sbus_priv *self);
+	size_t (*align_size)(struct sbus_priv *self, size_t size);
+	int (*set_block_size)(struct sbus_priv *self, size_t size);
+	int (*pipe_send)(struct sbus_priv *self, u8 pipe, u32 len, u8 *buf);
+	void * (*pipe_read)(struct sbus_priv *self);
+	int (*sbus_reg_read)(struct sbus_priv *self, u32 reg,
+					void *buf, int count);
+	int (*sbus_reg_write)(struct sbus_priv *self, u32 reg,
+					const void *buf, int count);
+
+	/* sub_system: 0 for mcu, 1 for wifi, 2 for bt, ... */
+	int (*sbus_active)(struct sbus_priv *self, int sub_system);
+	int (*sbus_deactive)(struct sbus_priv *self, int sub_system);
+	int (*power_switch)(struct sbus_priv *self, int on);
+	/* gpio wake, beacuse bes2600 sdio can't wakeup mcu, so add the two of interfaces */
+	void (*gpio_wake)(struct sbus_priv *self, int falg);
+	void (*gpio_sleep)(struct sbus_priv *self, int falg);
+	/* halt device to get debug information */
+	void (*halt_device)(struct sbus_priv *self);
+	bool (*wakeup_source)(struct sbus_priv *self);
+};
+
+void bes2600_irq_handler(struct bes2600_common *priv);
+
+/* This MUST be wrapped with hwbus_ops->lock/unlock! */
+int __bes2600_irq_enable(int enable);
+
+#endif /* BES2600_SBUS_H */
diff --git a/drivers/staging/bes2600/scan.c b/drivers/staging/bes2600/scan.c
new file mode 100755
index 000000000000..89763f2243f2
--- /dev/null
+++ b/drivers/staging/bes2600/scan.c
@@ -0,0 +1,658 @@
+/*
+ * Scan implementation for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/sched.h>
+#include "bes2600.h"
+#include "scan.h"
+#include "sta.h"
+#include "pm.h"
+#include "epta_request.h"
+#include "bes_pwr.h"
+
+static void bes2600_scan_restart_delayed(struct bes2600_vif *priv);
+
+static void bes2600_remove_wps_p2p_ie(struct wsm_template_frame *frame)
+{
+	u8 *ies;
+	u32 ies_len;
+	u32 ie_len;
+	u32 p2p_ie_len = 0;
+	u32 wps_ie_len = 0;
+
+	ies = &frame->skb->data[sizeof(struct ieee80211_hdr_3addr)];
+	ies_len = frame->skb->len - sizeof(struct ieee80211_hdr_3addr);
+
+	while (ies_len >= 6) {
+		ie_len = ies[1] + 2;
+		if ((ies[0] == WLAN_EID_VENDOR_SPECIFIC)
+			&& (ies[2] == 0x00 && ies[3] == 0x50 && ies[4] == 0xf2 && ies[5] == 0x04)) {
+			wps_ie_len = ie_len;
+			memmove(ies, ies + ie_len, ies_len);
+			ies_len -= ie_len;
+
+		}
+		else if ((ies[0] == WLAN_EID_VENDOR_SPECIFIC) &&
+			(ies[2] == 0x50 && ies[3] == 0x6f && ies[4] == 0x9a && ies[5] == 0x09)) {
+			p2p_ie_len = ie_len;
+			memmove(ies, ies + ie_len, ies_len);
+			ies_len -= ie_len;
+		} else {
+			ies += ie_len;
+			ies_len -= ie_len;
+		}
+	}
+
+	if (p2p_ie_len || wps_ie_len) {
+		skb_trim(frame->skb, frame->skb->len - (p2p_ie_len + wps_ie_len));
+	}
+}
+
+static int bes2600_scan_get_first_active_if(struct bes2600_common *hw_priv)
+{
+	int i = 0;
+	struct bes2600_vif *vif;
+
+	bes2600_for_each_vif(hw_priv, vif, i) {
+		if (vif->join_status > BES2600_JOIN_STATUS_PASSIVE)
+			return i;
+	}
+
+	return -1;
+}
+
+static int bes2600_scan_start(struct bes2600_vif *priv, struct wsm_scan *scan)
+{
+	int ret, i;
+	int tmo = 5000;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+
+	if (hw_priv->scan_switch_if_id == -1 &&
+		hw_priv->ht_info.channel_type > NL80211_CHAN_HT20 &&
+		priv->if_id >= 0) {
+		hw_priv->scan_switch_if_id = bes2600_scan_get_first_active_if(hw_priv);
+		if(hw_priv->scan_switch_if_id >= 0) {
+			struct wsm_switch_channel channel;
+			channel.channelMode = 0 << 4;
+			channel.channelSwitchCount = 0;
+			channel.newChannelNumber = hw_priv->channel->hw_value;
+			wsm_switch_channel(hw_priv, &channel, hw_priv->scan_switch_if_id);
+			bes2600_info(BES2600_DBG_SCAN, "scan start channel type %d num %d\n", hw_priv->ht_info.channel_type, channel.newChannelNumber);
+		}
+	}
+	for (i = 0; i < scan->numOfChannels; ++i)
+		tmo += scan->ch[i].maxChannelTime + 10;
+	atomic_set(&hw_priv->scan.in_progress, 1);
+	atomic_set(&hw_priv->recent_scan, 1);
+	queue_delayed_work(hw_priv->workqueue, &hw_priv->scan.timeout,
+		tmo * HZ / 1000);
+	ret = wsm_scan(hw_priv, scan, 0);
+	if (unlikely(ret)) {
+		atomic_set(&hw_priv->scan.in_progress, 0);
+		cancel_delayed_work_sync(&hw_priv->scan.timeout);
+		bes2600_scan_restart_delayed(priv);
+	}
+	return ret;
+}
+
+int bes2600_hw_scan(struct ieee80211_hw *hw,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_scan_request *hw_req)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct cfg80211_scan_request *req = &hw_req->req;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	int i;
+	/* Scan when P2P_GO corrupt firmware MiniAP mode */
+	if (priv->join_status == BES2600_JOIN_STATUS_AP)
+		return -EOPNOTSUPP;
+	if (req->n_ssids == 1 && !req->ssids[0].ssid_len)
+		req->n_ssids = 0;
+
+	wiphy_dbg(hw->wiphy, "[SCAN] Scan request for %d SSIDs.\n",
+		req->n_ssids);
+
+	if (req->n_ssids > hw->wiphy->max_scan_ssids)
+		return -EINVAL;
+
+	bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_SCAN);
+
+	frame.skb = ieee80211_probereq_get(hw, priv->vif->addr, NULL, 0,
+		req->ie_len);
+	if (!frame.skb)
+		return -ENOMEM;
+
+	if (req->ie_len)
+		skb_put_data(frame.skb, req->ie, req->ie_len);
+
+	/* will be unlocked in bes2600_scan_work() */
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+
+	if (frame.skb) {
+		int ret;
+		//if (priv->if_id == 0)
+		//	bes2600_remove_wps_p2p_ie(&frame);
+		ret = wsm_set_template_frame(hw_priv, &frame, 0);
+		if (ret) {
+			up(&hw_priv->conf_lock);
+			up(&hw_priv->scan.lock);
+			dev_kfree_skb(frame.skb);
+			return ret;
+		}
+	}
+
+	wsm_vif_lock_tx(priv);
+
+	BUG_ON(hw_priv->scan.req);
+	hw_priv->scan.req = req;
+	hw_priv->scan.n_ssids = 0;
+	hw_priv->scan.status = 0;
+	hw_priv->scan.begin = &req->channels[0];
+	hw_priv->scan.curr = hw_priv->scan.begin;
+	hw_priv->scan.end = &req->channels[req->n_channels];
+	hw_priv->scan.output_power = hw_priv->output_power;
+	hw_priv->scan.if_id = priv->if_id;
+	/* TODO:COMBO: Populate BIT4 in scanflags to decide on which MAC
+	 * address the SCAN request will be sent */
+	bes2600_info(BES2600_DBG_SCAN, "%s %d if_id:%d,num_channel:%d.\n", __func__, __LINE__, priv->if_id, req->n_channels);
+
+	for (i = 0; i < req->n_ssids; ++i) {
+		struct wsm_ssid *dst =
+			&hw_priv->scan.ssids[hw_priv->scan.n_ssids];
+		BUG_ON(req->ssids[i].ssid_len > sizeof(dst->ssid));
+		memcpy(&dst->ssid[0], req->ssids[i].ssid,
+			sizeof(dst->ssid));
+		dst->length = req->ssids[i].ssid_len;
+		++hw_priv->scan.n_ssids;
+	}
+
+	up(&hw_priv->conf_lock);
+
+	if (frame.skb)
+		dev_kfree_skb(frame.skb);
+	bwifi_change_current_status(hw_priv, BWIFI_STATUS_SCANNING);
+	queue_work(hw_priv->workqueue, &hw_priv->scan.work);
+
+	return 0;
+}
+
+void bes2600_scan_work(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv = container_of(work,
+						struct bes2600_common,
+						scan.work);
+	struct bes2600_vif *priv, *vif;
+	struct ieee80211_channel **it;
+	struct wsm_scan scan = {
+		.scanType = WSM_SCAN_TYPE_FOREGROUND,
+		.scanFlags = 0, /* TODO:COMBO */
+		//.scanFlags = WSM_SCAN_FLAG_SPLIT_METHOD, /* TODO:COMBO */
+	};
+	bool first_run;
+	int i;
+	const u32 ProbeRequestTime  = 2;
+	const u32 ChannelRemainTime = 15;
+	u32 minChannelTime;
+	u32 maxChannelTime;
+	priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+
+	/*TODO: COMBO: introduce locking so vif is not removed in meanwhile */
+	if (!priv) {
+		wiphy_warn(hw_priv->hw->wiphy, "[SCAN] interface removed, "
+			   "ignoring scan work\n");
+		return;
+	}
+
+	if (priv->if_id)
+		scan.scanFlags |= WSM_FLAG_MAC_INSTANCE_1;
+	else
+		scan.scanFlags &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+	bes2600_for_each_vif(hw_priv, vif, i) {
+		if ((i == (CW12XX_MAX_VIFS - 1)) || !vif)
+			continue;
+		if (vif->bss_loss_status > BES2600_BSS_LOSS_NONE)
+			scan.scanFlags |= WSM_SCAN_FLAG_FORCE_BACKGROUND;
+	}
+	first_run = hw_priv->scan.begin == hw_priv->scan.curr &&
+			hw_priv->scan.begin != hw_priv->scan.end;
+
+	if (first_run) {
+		/* Firmware gets crazy if scan request is sent
+		 * when STA is joined but not yet associated.
+		 * Force unjoin in this case. */
+		if (cancel_delayed_work_sync(&priv->join_timeout) > 0) {
+			bes2600_join_timeout(&priv->join_timeout.work);
+		}
+	}
+	down(&hw_priv->conf_lock);
+	if (first_run) {
+		if (priv->join_status == BES2600_JOIN_STATUS_MONITOR) {
+			/* FW bug: driver has to restart p2p-dev mode
+			 * after scan */
+			bes2600_disable_listening(priv);
+		}
+	}
+
+	if (!hw_priv->scan.req || (hw_priv->scan.curr == hw_priv->scan.end)) {
+		struct cfg80211_scan_info info = {
+			.aborted = hw_priv->scan.status ? 1 : 0,
+		};
+
+		if (hw_priv->scan.output_power != hw_priv->output_power)
+		/* TODO:COMBO: Change when mac80211 implementation
+		 * is available for output power also */
+			WARN_ON(wsm_set_output_power(hw_priv,
+				hw_priv->output_power * 10,
+				priv->if_id ? 0 : 0));
+		if (hw_priv->scan.status < 0)
+			wiphy_info(priv->hw->wiphy,
+					"[SCAN] Scan failed (%d).\n",
+					hw_priv->scan.status);
+		else if (hw_priv->scan.req)
+			wiphy_info(priv->hw->wiphy,
+					"[SCAN] Scan completed.\n");
+		else
+			wiphy_info(priv->hw->wiphy,
+					"[SCAN] Scan canceled.\n");
+
+		if (priv->join_status == BES2600_JOIN_STATUS_STA) {
+			if (hw_priv->channel->band != NL80211_BAND_2GHZ)
+				bwifi_change_current_status(hw_priv, BWIFI_STATUS_GOT_IP_5G);
+			else
+				bwifi_change_current_status(hw_priv, BWIFI_STATUS_GOT_IP);
+		} else {
+			bwifi_change_current_status(hw_priv, BWIFI_STATUS_IDLE);
+		}
+		bes2600_info(BES2600_DBG_SCAN, "%s %d %d.", __func__, __LINE__, hw_priv->ht_info.channel_type);
+		/* switch to previous channel and bw mode after scan done */
+		if (hw_priv->scan_switch_if_id >= 0) {
+			struct wsm_switch_channel channel;
+			channel.channelMode = hw_priv->ht_info.channel_type << 4;
+			channel.channelSwitchCount = 0;
+			channel.newChannelNumber = hw_priv->channel->hw_value;
+			wsm_switch_channel(hw_priv, &channel, hw_priv->scan_switch_if_id);
+			hw_priv->scan_switch_if_id = -1;
+			bes2600_info(BES2600_DBG_SCAN, "scan done channel type %d num %d\n", hw_priv->ht_info.channel_type, channel.newChannelNumber);
+		}
+
+		hw_priv->scan.req = NULL;
+		bes2600_scan_restart_delayed(priv);
+		wsm_unlock_tx(hw_priv);
+		up(&hw_priv->conf_lock);
+		bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_SCAN);
+		ieee80211_scan_completed(hw_priv->hw, &info);
+		up(&hw_priv->scan.lock);
+		return;
+	} else {
+		struct ieee80211_channel *first = *hw_priv->scan.curr;
+		for (it = hw_priv->scan.curr + 1, i = 1;
+		     it != hw_priv->scan.end &&
+				i < WSM_SCAN_MAX_NUM_OF_CHANNELS;
+		     ++it, ++i) {
+			if ((*it)->band != first->band)
+				break;
+			// Doen't split scan req in case of EPTA error after scan req
+			// if (((*it)->flags ^ first->flags) &
+			// 		IEEE80211_CHAN_NO_IR)
+			// 	break;
+			// if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
+			// 	(*it)->max_power != first->max_power)
+			// 	break;
+		}
+		scan.band = first->band;
+
+		if (hw_priv->scan.req->no_cck)
+			scan.maxTransmitRate = WSM_TRANSMIT_RATE_6;
+		else
+			scan.maxTransmitRate = WSM_TRANSMIT_RATE_1;
+		/* TODO: Is it optimal? */
+		scan.numOfProbeRequests =
+			(first->flags & IEEE80211_CHAN_NO_IR) ? 0 : 2;
+		scan.numOfSSIDs = hw_priv->scan.n_ssids;
+		scan.ssids = &hw_priv->scan.ssids[0];
+		scan.numOfChannels = it - hw_priv->scan.curr;
+		/* TODO: Is it optimal? */
+		scan.probeDelay = 100;
+		/* It is not stated in WSM specification, however
+		 * FW team says that driver may not use FG scan
+		 * when joined. */
+		if (priv->join_status == BES2600_JOIN_STATUS_STA) {
+			scan.scanType = WSM_SCAN_TYPE_BACKGROUND;
+			scan.scanFlags = WSM_SCAN_FLAG_FORCE_BACKGROUND;
+		}
+		scan.ch = kzalloc((it - hw_priv->scan.curr) *
+			sizeof(struct wsm_scan_ch), GFP_KERNEL);
+		if (!scan.ch) {
+			hw_priv->scan.status = -ENOMEM;
+			goto fail;
+		}
+		maxChannelTime = (scan.numOfSSIDs * scan.numOfProbeRequests *
+			ProbeRequestTime) + ChannelRemainTime;
+		maxChannelTime = (maxChannelTime < 35) ? 35 : maxChannelTime;
+
+		if (scan.band == NL80211_BAND_2GHZ) {
+			coex_calc_wifi_scan_time(&minChannelTime, &maxChannelTime);
+		} else {
+			minChannelTime = 90;
+			maxChannelTime = 90;
+		}
+
+		for (i = 0; i < scan.numOfChannels; ++i) {
+			scan.ch[i].number = hw_priv->scan.curr[i]->hw_value;
+			scan.ch[i].minChannelTime = minChannelTime;
+			scan.ch[i].maxChannelTime = maxChannelTime;
+		}
+		if (!(first->flags & IEEE80211_CHAN_NO_IR) &&
+			hw_priv->scan.output_power != first->max_power) {
+			hw_priv->scan.output_power = first->max_power;
+			/* TODO:COMBO: Change after mac80211 implementation
+		 	* complete */
+			WARN_ON(wsm_set_output_power(hw_priv,
+					hw_priv->scan.output_power * 10,
+					priv->if_id ? 0 : 0));
+		}
+		hw_priv->scan.status = bes2600_scan_start(priv, &scan);
+		kfree(scan.ch);
+		if (WARN_ON(hw_priv->scan.status))
+			goto fail;
+		hw_priv->scan.curr = it;
+	}
+	up(&hw_priv->conf_lock);
+	return;
+
+fail:
+	hw_priv->scan.curr = hw_priv->scan.end;
+	up(&hw_priv->conf_lock);
+	queue_work(hw_priv->workqueue, &hw_priv->scan.work);
+	return;
+}
+
+static void bes2600_scan_restart_delayed(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	if (priv->delayed_link_loss) {
+		int tmo = priv->cqm_beacon_loss_count;
+
+		if (hw_priv->scan.direct_probe)
+			tmo = 0;
+
+		priv->delayed_link_loss = 0;
+		/* Restart beacon loss timer and requeue
+		   BSS loss work. */
+		wiphy_dbg(priv->hw->wiphy,
+				"[CQM] Requeue BSS loss in %d "
+				"beacons.\n", tmo);
+		spin_lock(&priv->bss_loss_lock);
+		priv->bss_loss_status = BES2600_BSS_LOSS_NONE;
+		spin_unlock(&priv->bss_loss_lock);
+		cancel_delayed_work_sync(&priv->bss_loss_work);
+		queue_delayed_work(hw_priv->workqueue,
+				&priv->bss_loss_work,
+				tmo * HZ / 10);
+	}
+
+	/* FW bug: driver has to restart p2p-dev mode after scan. */
+	if (priv->join_status == BES2600_JOIN_STATUS_MONITOR) {
+		/*bes2600_enable_listening(priv);*/
+		// WARN_ON(1);
+		bes2600_dbg(BES2600_DBG_SCAN, "scan complete join_status is monitor");
+		bes2600_update_filtering(priv);
+	}
+
+	if (priv->delayed_unjoin) {
+		priv->delayed_unjoin = false;
+		if (queue_work(hw_priv->workqueue, &priv->unjoin_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+	}
+}
+
+static void bes2600_scan_complete(struct bes2600_common *hw_priv, int if_id)
+{
+	struct bes2600_vif *priv;
+	atomic_xchg(&hw_priv->recent_scan, 0);
+
+	if (hw_priv->scan.direct_probe) {
+		down(&hw_priv->conf_lock);
+		priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, if_id);
+		if (priv) {
+			wiphy_dbg(priv->hw->wiphy, "[SCAN] Direct probe "
+				  "complete.\n");
+			bes2600_scan_restart_delayed(priv);
+		} else {
+			wiphy_dbg(priv->hw->wiphy, "[SCAN] Direct probe "
+				  "complete without interface!\n");
+		}
+		up(&hw_priv->conf_lock);
+		hw_priv->scan.direct_probe = 0;
+		up(&hw_priv->scan.lock);
+		wsm_unlock_tx(hw_priv);
+	} else {
+		bes2600_scan_work(&hw_priv->scan.work);
+	}
+}
+
+void bes2600_scan_complete_cb(struct bes2600_common *hw_priv,
+				struct wsm_scan_complete *arg)
+{
+	struct bes2600_vif *priv = cw12xx_hwpriv_to_vifpriv(hw_priv,
+					hw_priv->scan.if_id);
+
+	if (unlikely(!priv))
+		return;
+
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+	spin_unlock(&priv->vif_lock);
+
+	// recover EPTA timer after scan wsm msg complete, in case of epta state error
+	// bwifi_change_current_status(hw_priv, BWIFI_STATUS_SCANNING_COMP);
+	wiphy_info(hw_priv->hw->wiphy, "bes2600_scan_complete_cb status: %u", arg->status);
+
+	if(hw_priv->scan.status == -ETIMEDOUT)
+		wiphy_warn(hw_priv->hw->wiphy,
+			"Scan timeout already occured. Don't cancel work");
+	if ((hw_priv->scan.status != -ETIMEDOUT) &&
+		(cancel_delayed_work_sync(&hw_priv->scan.timeout) > 0)) {
+		hw_priv->scan.status = 1;
+		queue_delayed_work(hw_priv->workqueue,
+				&hw_priv->scan.timeout, 0);
+	}
+}
+
+void bes2600_scan_timeout(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, scan.timeout.work);
+
+	if (likely(atomic_xchg(&hw_priv->scan.in_progress, 0))) {
+		if (hw_priv->scan.status > 0)
+			hw_priv->scan.status = 0;
+		else if (!hw_priv->scan.status) {
+			wiphy_warn(hw_priv->hw->wiphy,
+				"Timeout waiting for scan "
+				"complete notification.\n");
+			hw_priv->scan.status = -ETIMEDOUT;
+			hw_priv->scan.curr = hw_priv->scan.end;
+			WARN_ON(wsm_stop_scan(hw_priv,
+						hw_priv->scan.if_id ? 1 : 0));
+		}
+		bes2600_scan_complete(hw_priv, hw_priv->scan.if_id);
+	}
+}
+
+void bes2600_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	if(hw_priv->scan.if_id == priv->if_id) {
+		bes2600_dbg(BES2600_DBG_SCAN, "cancel hw_scan on intf:%d\n", priv->if_id);
+
+		down(&hw_priv->conf_lock);
+		hw_priv->scan.req = NULL;
+		up(&hw_priv->conf_lock);
+
+		/* cancel scan operation */
+		wsm_stop_scan(hw_priv, priv->if_id);
+
+		/* wait scan operation end */
+		down(&hw_priv->scan.lock);
+		up(&hw_priv->scan.lock);
+	}
+}
+
+void bes2600_probe_work(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, scan.probe_work.work);
+	struct bes2600_vif *priv, *vif;
+	u8 queueId = bes2600_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct bes2600_queue *queue = &hw_priv->tx_queue[queueId];
+	const struct bes2600_txpriv *txpriv;
+	struct wsm_tx *wsm;
+	struct wsm_template_frame frame = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	struct wsm_ssid ssids[1] = {{
+		.length = 0,
+	} };
+	struct wsm_scan_ch ch[1] = {{
+		.minChannelTime = 0,
+		.maxChannelTime = 10,
+	} };
+	struct wsm_scan scan = {
+		.scanType = WSM_SCAN_TYPE_FOREGROUND,
+		.numOfProbeRequests = 2,
+		.probeDelay = 0,
+		.numOfChannels = 1,
+		.ssids = ssids,
+		.ch = ch,
+	};
+	u8 *ies;
+	size_t ies_len;
+	int ret = 1;
+	int i;
+	wiphy_info(hw_priv->hw->wiphy, "[SCAN] Direct probe work.\n");
+
+	BUG_ON(queueId >= 4);
+	BUG_ON(!hw_priv->channel);
+
+	down(&hw_priv->conf_lock);
+	if (unlikely(down_trylock(&hw_priv->scan.lock))) {
+		/* Scan is already in progress. Requeue self. */
+		schedule();
+		queue_delayed_work(hw_priv->workqueue,
+					&hw_priv->scan.probe_work, HZ / 10);
+		up(&hw_priv->conf_lock);
+		return;
+	}
+
+	if (bes2600_queue_get_skb(queue,	hw_priv->pending_frame_id,
+			&frame.skb, &txpriv)) {
+		up(&hw_priv->scan.lock);
+		up(&hw_priv->conf_lock);
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+	priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, txpriv->if_id);
+	if (!priv) {
+		up(&hw_priv->scan.lock);
+		up(&hw_priv->conf_lock);
+		return;
+	}
+	wsm = (struct wsm_tx *)frame.skb->data;
+	scan.maxTransmitRate = wsm->maxTxRate;
+	scan.band = (hw_priv->channel->band == NL80211_BAND_5GHZ) ?
+		WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G;
+	if (priv->join_status == BES2600_JOIN_STATUS_STA) {
+		scan.scanType = WSM_SCAN_TYPE_BACKGROUND;
+		scan.scanFlags = WSM_SCAN_FLAG_FORCE_BACKGROUND;
+		if (priv->if_id)
+			scan.scanFlags |= WSM_FLAG_MAC_INSTANCE_1;
+		else
+			scan.scanFlags &= ~WSM_FLAG_MAC_INSTANCE_1;
+	}
+	bes2600_for_each_vif(hw_priv, vif, i) {
+		if (!vif)
+			continue;
+		if (vif->bss_loss_status > BES2600_BSS_LOSS_NONE)
+			scan.scanFlags |= WSM_SCAN_FLAG_FORCE_BACKGROUND;
+	}
+	ch[0].number = hw_priv->channel->hw_value;
+
+	skb_pull(frame.skb, txpriv->offset);
+
+	ies = &frame.skb->data[sizeof(struct ieee80211_hdr_3addr)];
+	ies_len = frame.skb->len - sizeof(struct ieee80211_hdr_3addr);
+
+	if (ies_len) {
+		u8 *ssidie =
+			(u8 *)cfg80211_find_ie(WLAN_EID_SSID, ies, ies_len);
+		if (ssidie && ssidie[1] && ssidie[1] <= sizeof(ssids[0].ssid)) {
+			u8 *nextie = &ssidie[2 + ssidie[1]];
+			/* Remove SSID from the IE list. It has to be provided
+			 * as a separate argument in bes2600_scan_start call */
+
+			/* Store SSID localy */
+			ssids[0].length = ssidie[1];
+			memcpy(ssids[0].ssid, &ssidie[2], ssids[0].length);
+			scan.numOfSSIDs = 1;
+
+			/* Remove SSID from IE list */
+			ssidie[1] = 0;
+			memmove(&ssidie[2], nextie, &ies[ies_len] - nextie);
+			skb_trim(frame.skb, frame.skb->len - ssids[0].length);
+		}
+	}
+
+	if (priv->if_id == 0)
+		bes2600_remove_wps_p2p_ie(&frame);
+
+	/* FW bug: driver has to restart p2p-dev mode after scan */
+	if (priv->join_status == BES2600_JOIN_STATUS_MONITOR) {
+		WARN_ON(1);
+		/*bes2600_disable_listening(priv);*/
+	}
+	ret = WARN_ON(wsm_set_template_frame(hw_priv, &frame,
+				priv->if_id));
+
+	hw_priv->scan.direct_probe = 1;
+	hw_priv->scan.if_id = priv->if_id;
+	if (!ret) {
+		wsm_flush_tx(hw_priv);
+		ret = WARN_ON(bes2600_scan_start(priv, &scan));
+	}
+	up(&hw_priv->conf_lock);
+
+	skb_push(frame.skb, txpriv->offset);
+	if (!ret)
+		IEEE80211_SKB_CB(frame.skb)->flags |= IEEE80211_TX_STAT_ACK;
+
+	// TODO: find out if this is meant to be guarded by the above if statement
+	BUG_ON(bes2600_queue_remove(queue, hw_priv->pending_frame_id));
+
+	if (ret) {
+		hw_priv->scan.direct_probe = 0;
+		up(&hw_priv->scan.lock);
+		wsm_unlock_tx(hw_priv);
+	}
+
+	return;
+}
diff --git a/drivers/staging/bes2600/scan.h b/drivers/staging/bes2600/scan.h
new file mode 100755
index 000000000000..52cc7b61411a
--- /dev/null
+++ b/drivers/staging/bes2600/scan.h
@@ -0,0 +1,56 @@
+/*
+ * Scan interface for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef SCAN_H_INCLUDED
+#define SCAN_H_INCLUDED
+
+#include <linux/semaphore.h>
+#include "wsm.h"
+
+/* external */ struct sk_buff;
+/* external */ struct cfg80211_scan_request;
+/* external */ struct ieee80211_channel;
+/* external */ struct ieee80211_hw;
+/* external */ struct work_struct;
+
+struct bes2600_scan {
+	struct semaphore lock;
+	struct work_struct work;
+	struct delayed_work timeout;
+	struct cfg80211_scan_request *req;
+	struct ieee80211_channel **begin;
+	struct ieee80211_channel **curr;
+	struct ieee80211_channel **end;
+	struct wsm_ssid ssids[WSM_SCAN_MAX_NUM_OF_SSIDS];
+	int output_power;
+	int n_ssids;
+	int status;
+	atomic_t in_progress;
+	/* Direct probe requests workaround */
+	struct delayed_work probe_work;
+	int direct_probe;
+	u8 if_id;
+};
+
+int bes2600_hw_scan(struct ieee80211_hw *hw,
+		   struct ieee80211_vif *vif,
+		   struct ieee80211_scan_request *hw_req);
+void bes2600_scan_work(struct work_struct *work);
+void bes2600_scan_timeout(struct work_struct *work);
+void bes2600_scan_complete_cb(struct bes2600_common *priv,
+				struct wsm_scan_complete *arg);
+void bes2600_cancel_hw_scan(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+
+/* ******************************************************************** */
+/* Raw probe requests TX workaround					*/
+void bes2600_probe_work(struct work_struct *work);
+
+#endif
diff --git a/drivers/staging/bes2600/sta.c b/drivers/staging/bes2600/sta.c
new file mode 100755
index 000000000000..10cc338bf5a8
--- /dev/null
+++ b/drivers/staging/bes2600/sta.c
@@ -0,0 +1,2526 @@
+/*
+ * Mac80211 STA API for BES2600 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/vmalloc.h>
+#include <linux/sched.h>
+#include <linux/firmware.h>
+#include <linux/if_arp.h>
+#include <linux/ipv6.h>
+#include <linux/icmpv6.h>
+#include <net/ndisc.h>
+
+#include "bes2600.h"
+#include "sta.h"
+#include "ap.h"
+#include "fwio.h"
+#include "bh.h"
+#include "debug.h"
+#include "wsm.h"
+#include "net/mac80211.h"
+#include "bes2600_driver_mode.h"
+#include "bes_chardev.h"
+
+#include "epta_request.h"
+#include "epta_coex.h"
+
+#include "txrx_opt.h"
+
+#define WEP_ENCRYPT_HDR_SIZE    4
+#define WEP_ENCRYPT_TAIL_SIZE   4
+#define WPA_ENCRYPT_HDR_SIZE    8
+#define WPA_ENCRYPT_TAIL_SIZE   12
+#define WPA2_ENCRYPT_HDR_SIZE   8
+#define WPA2_ENCRYPT_TAIL_SIZE  8
+#define WAPI_ENCRYPT_HDR_SIZE   18
+#define WAPI_ENCRYPT_TAIL_SIZE  16
+#define MAX_ARP_REPLY_TEMPLATE_SIZE     120
+#define MAX_TCP_ALIVE_TEMPLATE_SIZE     256
+
+static inline void __bes2600_free_event_queue(struct list_head *list)
+{
+	while (!list_empty(list)) {
+		struct bes2600_wsm_event *event =
+			list_first_entry(list, struct bes2600_wsm_event,
+			link);
+		list_del(&event->link);
+		kfree(event);
+	}
+}
+
+static inline void __bes2600_bf_configure(struct bes2600_vif *priv)
+{
+	priv->bf_table.numOfIEs = __cpu_to_le32(3);
+	priv->bf_table.entry[0].ieId = WLAN_EID_VENDOR_SPECIFIC;
+	priv->bf_table.entry[0].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+					WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+					WSM_BEACON_FILTER_IE_HAS_APPEARED;
+	priv->bf_table.entry[0].oui[0] = 0x50;
+	priv->bf_table.entry[0].oui[1] = 0x6F;
+	priv->bf_table.entry[0].oui[2] = 0x9A;
+
+	priv->bf_table.entry[1].ieId = WLAN_EID_ERP_INFO;
+	priv->bf_table.entry[1].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+					WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+					WSM_BEACON_FILTER_IE_HAS_APPEARED;
+
+	priv->bf_table.entry[2].ieId = WLAN_EID_HT_OPERATION;
+	priv->bf_table.entry[2].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+					WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+					WSM_BEACON_FILTER_IE_HAS_APPEARED;
+
+	priv->bf_control.enabled = WSM_BEACON_FILTER_ENABLE;
+}
+
+/* ******************************************************************** */
+/* STA API								*/
+
+int bes2600_start(struct ieee80211_hw *dev)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	int ret = 0;
+
+	bes2600_info(BES2600_DBG_STA, "bes2600_start\n");
+
+	if (!bes2600_chrdev_is_signal_mode()) {
+		return -1;
+	}
+
+	bes2600_pwr_prepare(hw_priv);
+
+	/* Assign Max SSIDs supported based on the firmware revision*/
+	if (hw_priv->hw_revision <= BES2600_HW_REV_CUT22) {
+		dev->wiphy->max_scan_ssids = 2; /* for backward compatibility */
+	}
+	down(&hw_priv->conf_lock);
+
+	ret = bes2600_wifi_start(hw_priv);
+	if (ret)
+		goto out;
+	tx_policy_init(hw_priv);
+
+	memcpy(hw_priv->mac_addr, dev->wiphy->perm_addr, ETH_ALEN);
+	hw_priv->softled_state = 0;
+
+	atomic_inc(&hw_priv->netdevice_start);
+	coex_start(hw_priv);
+
+	bes2600_info(BES2600_DBG_STA, "%s %pM.\n", __func__, hw_priv->mac_addr);
+	ret = bes2600_setup_mac(hw_priv);
+	if (WARN_ON(ret))
+		goto out;
+
+	bwifi_change_current_status(hw_priv, BWIFI_STATUS_IDLE);
+
+out:
+	up(&hw_priv->conf_lock);
+	if(ret != 0)
+		bes2600_pwr_complete(hw_priv);
+	return ret;
+}
+
+void bes2600_stop(struct ieee80211_hw *dev)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv = NULL;
+	LIST_HEAD(list);
+	int i;
+
+	bes2600_info(BES2600_DBG_STA, "bes2600_stop\n");
+
+	atomic_dec(&hw_priv->netdevice_start);
+
+	wsm_lock_tx(hw_priv);
+
+	while (down_trylock(&hw_priv->scan.lock)) {
+		/* Scan is in progress. Force it to stop. */
+		hw_priv->scan.req = NULL;
+		schedule();
+	}
+	up(&hw_priv->scan.lock);
+
+	cancel_delayed_work_sync(&hw_priv->scan.probe_work);
+	cancel_delayed_work_sync(&hw_priv->scan.timeout);
+
+	flush_workqueue(hw_priv->workqueue);
+	del_timer_sync(&hw_priv->ba_timer);
+
+	down(&hw_priv->conf_lock);
+
+	hw_priv->softled_state = 0;
+	/* bes2600_set_leds(hw_priv); */
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+	__bes2600_free_event_queue(&list);
+
+	for (i = 0; i < 4; i++)
+		bes2600_queue_clear(&hw_priv->tx_queue[i], CW12XX_ALL_IFS);
+
+	/* HACK! */
+	if (atomic_xchg(&hw_priv->tx_lock, 1) != 1)
+		bes2600_dbg(BES2600_DBG_STA, "[STA] TX is force-unlocked "
+			"due to stop request.\n");
+
+	bes2600_for_each_vif(hw_priv, priv, i) {
+		if (!priv)
+			continue;
+		priv->mode = NL80211_IFTYPE_UNSPECIFIED;
+		priv->listening = false;
+		priv->delayed_link_loss = 0;
+		priv->join_status = BES2600_JOIN_STATUS_PASSIVE;
+		cancel_delayed_work_sync(&priv->join_timeout);
+		cancel_delayed_work_sync(&priv->bss_loss_work);
+		cancel_delayed_work_sync(&priv->connection_loss_work);
+		cancel_delayed_work_sync(&priv->link_id_gc_work);
+		del_timer_sync(&priv->mcast_timeout);
+	}
+
+	cancel_work_sync(&hw_priv->coex_work);
+	coex_stop(hw_priv);
+
+	bes2600_wifi_stop(hw_priv);
+
+	tx_policy_deinit(hw_priv);
+
+	wsm_unlock_tx(hw_priv);
+
+	up(&hw_priv->conf_lock);
+	bes2600_pwr_complete(hw_priv);
+}
+
+
+int bes2600_add_interface(struct ieee80211_hw *dev,
+			 struct ieee80211_vif *vif)
+{
+	int ret;
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv;
+	struct bes2600_vif **drv_priv = (void *)vif->drv_priv;
+	bes2600_err(BES2600_DBG_STA, " !!! %s: type %d p2p %d addr %pM\n",
+		__func__, vif->type, vif->p2p, vif->addr);
+
+	priv = cw12xx_get_vif_from_ieee80211(vif);
+	atomic_set(&priv->enabled, 0);
+
+	*drv_priv = priv;
+	/* __le32 auto_calibration_mode = __cpu_to_le32(1); */
+
+	down(&hw_priv->conf_lock);
+
+	priv->mode = vif->type;
+
+	spin_lock(&hw_priv->vif_list_lock);
+	if (atomic_read(&hw_priv->num_vifs) < CW12XX_MAX_VIFS) {
+		if (!memcmp(vif->addr, hw_priv->addresses[0].addr, ETH_ALEN)) {
+			priv->if_id = 0;
+		} else if (!memcmp(vif->addr, hw_priv->addresses[1].addr,
+			ETH_ALEN)) {
+			priv->if_id = 2;
+		} else if (!memcmp(vif->addr, hw_priv->addresses[2].addr,
+			ETH_ALEN)) {
+			priv->if_id = 1;
+		}
+		bes2600_info(BES2600_DBG_STA, "%s: if_id %d mac %pM\n",
+				__func__, priv->if_id, vif->addr);
+		priv->hw_priv = hw_priv;
+		priv->hw = dev;
+		priv->vif = vif;
+	} else {
+		spin_unlock(&hw_priv->vif_list_lock);
+		up(&hw_priv->conf_lock);
+		return -EOPNOTSUPP;
+	}
+	spin_unlock(&hw_priv->vif_list_lock);
+	/* TODO:COMBO :Check if MAC address matches the one expected by FW */
+	memcpy(hw_priv->mac_addr, vif->addr, ETH_ALEN);
+
+	/* Enable auto-calibration */
+	/* Exception in subsequent channel switch; disabled.
+	WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_SET_AUTO_CALIBRATION_MODE,
+		&auto_calibration_mode, sizeof(auto_calibration_mode)));
+	*/
+	bes2600_info(BES2600_DBG_STA, "[STA] Interface ID:%d of type:%d added\n",
+		   priv->if_id, priv->mode);
+
+	up(&hw_priv->conf_lock);
+
+	bes2600_vif_setup(priv);
+
+	ret = WARN_ON(bes2600_setup_mac_pvif(priv));
+
+	return ret;
+}
+
+void bes2600_remove_interface(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	int i;
+	bool is_htcapie = false;
+	struct bes2600_vif *tmp_priv;
+
+	bes2600_info(BES2600_DBG_STA, " !!! %s: type %d p2p %d addr %pM\n",
+		__func__, vif->type, vif->p2p, vif->addr);
+	atomic_set(&priv->enabled, 0);
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	bes2600_tx_queues_lock(hw_priv);
+	wsm_lock_tx(hw_priv);
+	switch (priv->join_status) {
+	case BES2600_JOIN_STATUS_STA:
+		wsm_lock_tx(hw_priv);
+		if (queue_work(hw_priv->workqueue, &priv->unjoin_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		break;
+	case BES2600_JOIN_STATUS_AP:
+		for (i = 0; priv->link_id_map; ++i) {
+			if (priv->link_id_map & BIT(i)) {
+				cw12xx_unmap_link(priv, i);
+				priv->link_id_map &= ~BIT(i);
+			}
+		}
+		memset(priv->link_id_db, 0,
+				sizeof(priv->link_id_db));
+		priv->sta_asleep_mask = 0;
+		priv->enable_beacon = false;
+		priv->tx_multicast = false;
+		priv->aid0_bit_set = false;
+		priv->buffered_multicasts = false;
+		priv->pspoll_mask = 0;
+		reset.link_id = 0;
+		wsm_reset(hw_priv, &reset, priv->if_id);
+		bes2600_for_each_vif(hw_priv, tmp_priv, i) {
+			if ((i == (CW12XX_MAX_VIFS - 1)) || !tmp_priv)
+				continue;
+			if ((tmp_priv->join_status == BES2600_JOIN_STATUS_STA) && tmp_priv->htcap)
+				is_htcapie = true;
+		}
+
+		if (is_htcapie) {
+			hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11N_THROTTLE;
+			hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11N_THROTTLE;
+			bes2600_info(BES2600_DBG_STA, "AP REMOVE HTCAP 11N %d\n",hw_priv->vif0_throttle);
+		} else {
+			hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+			hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+			bes2600_info(BES2600_DBG_STA, "AP REMOVE 11BG %d\n",hw_priv->vif0_throttle);
+		}
+		bes2600_pwr_clear_busy_event(hw_priv, BES2600_JOIN_STATUS_AP);
+		break;
+	case BES2600_JOIN_STATUS_MONITOR:
+		bes2600_disable_listening(priv);
+		break;
+	default:
+		break;
+	}
+	/* TODO:COMBO: Change Queue Module */
+	if (!__bes2600_flush(hw_priv, false, priv->if_id))
+		wsm_unlock_tx(hw_priv);
+
+	cancel_delayed_work_sync(&priv->bss_loss_work);
+	cancel_delayed_work_sync(&priv->connection_loss_work);
+	cancel_delayed_work_sync(&priv->link_id_gc_work);
+	cancel_delayed_work_sync(&priv->join_timeout);
+	cancel_delayed_work_sync(&priv->set_cts_work);
+	cancel_delayed_work_sync(&priv->pending_offchanneltx_work);
+
+	del_timer_sync(&priv->mcast_timeout);
+	/* TODO:COMBO: May be reset of these variables "delayed_link_loss and
+	 * join_status to default can be removed as dev_priv will be freed by
+	 * mac80211 */
+	priv->delayed_link_loss = 0;
+	priv->join_status = BES2600_JOIN_STATUS_PASSIVE;
+	wsm_unlock_tx(hw_priv);
+
+	if ((priv->if_id ==1) && (priv->mode == NL80211_IFTYPE_AP
+		|| priv->mode == NL80211_IFTYPE_P2P_GO)) {
+		hw_priv->is_go_thru_go_neg = false;
+	}
+	spin_lock(&hw_priv->vif_list_lock);
+	spin_lock(&priv->vif_lock);
+	hw_priv->vif_list[priv->if_id] = NULL;
+	hw_priv->if_id_slot &= (~BIT(priv->if_id));
+	atomic_dec(&hw_priv->num_vifs);
+	if (atomic_read(&hw_priv->num_vifs) == 0) {
+		bes2600_free_keys(hw_priv);
+		memset(hw_priv->mac_addr, 0, ETH_ALEN);
+	}
+	spin_unlock(&priv->vif_lock);
+	spin_unlock(&hw_priv->vif_list_lock);
+	priv->listening = false;
+
+	bes2600_debug_release_priv(priv);
+
+	bes2600_tx_queues_unlock(hw_priv);
+	up(&hw_priv->conf_lock);
+
+	if (atomic_read(&hw_priv->num_vifs) == 0)
+		flush_workqueue(hw_priv->workqueue);
+	memset(priv, 0, sizeof(struct bes2600_vif));
+	up(&hw_priv->scan.lock);
+}
+
+int bes2600_change_interface(struct ieee80211_hw *dev,
+				struct ieee80211_vif *vif,
+				enum nl80211_iftype new_type,
+				bool p2p)
+{
+	int ret = 0;
+	bes2600_info(BES2600_DBG_STA, " !!! %s: type %d (%d), p2p %d (%d)\n",
+		__func__, new_type, vif->type, p2p, vif->p2p);
+	if (new_type != vif->type || vif->p2p != p2p) {
+		bes2600_remove_interface(dev, vif);
+		vif->type = new_type;
+		vif->p2p = p2p;
+		ret = bes2600_add_interface(dev, vif);
+	}
+
+	return ret;
+}
+
+int bes2600_config(struct ieee80211_hw *dev, u32 changed)
+{
+	int ret = 0;
+	struct bes2600_common *hw_priv = dev->priv;
+	struct ieee80211_conf *conf = &dev->conf;
+	/* TODO:COMBO: adjust to multi vif interface
+	 * IEEE80211_CONF_CHANGE_IDLE is still handled per bes2600_vif*/
+	int if_id = 0;
+	struct bes2600_vif *priv;
+
+	bes2600_info(BES2600_DBG_STA, "CONFIG CHANGED:	%08x\n", changed);
+
+	if (changed &
+		(IEEE80211_CONF_CHANGE_MONITOR|IEEE80211_CONF_CHANGE_IDLE)) {
+		/* TBD: It looks like it's transparent
+		 * there's a monitor interface present -- use this
+		 * to determine for example whether to calculate
+		 * timestamps for packets or not, do not use instead
+		 * of filter flags! */
+		bes2600_info(BES2600_DBG_STA,
+				"ignore IEEE80211_CONF_CHANGE_MONITOR (%d)"
+				"IEEE80211_CONF_CHANGE_IDLE (%d)\n",
+			(changed & IEEE80211_CONF_CHANGE_MONITOR) ? 1 : 0,
+			(changed & IEEE80211_CONF_CHANGE_IDLE) ? 1 : 0);
+		return ret;
+	}
+
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+	priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, hw_priv->scan.if_id);
+	/* TODO: IEEE80211_CONF_CHANGE_QOS */
+	/* TODO:COMBO:Change when support is available mac80211*/
+	if (changed & IEEE80211_CONF_CHANGE_POWER) {
+		/*hw_priv->output_power = conf->power_level;*/
+		bes2600_info(BES2600_DBG_STA, "Output power ++%d\n",conf->power_level);
+		hw_priv->output_power = 20;
+		bes2600_info(BES2600_DBG_STA, "Output power --%d\n",hw_priv->output_power);
+		bes2600_info(BES2600_DBG_STA, "[STA] TX power: %d\n",
+				hw_priv->output_power);
+		WARN_ON(wsm_set_output_power(hw_priv,
+					     hw_priv->output_power * 10,
+					     if_id));
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_CHANNEL) {
+		/* Switch Channel commented for CC Mode */
+		struct ieee80211_channel *ch = conf->chandef.chan;
+
+		bes2600_info(BES2600_DBG_STA, "[STA] Freq %d (wsm ch: %d, type: %d).\n",
+			   ch->center_freq, ch->hw_value,
+			   cfg80211_get_chandef_type(&conf->chandef));
+		/* Earlier there was a call to __bes2600_flush().
+		   Removed as deemed unnecessary */
+
+		hw_priv->channel = ch;
+
+	}
+
+	if (changed & IEEE80211_CONF_CHANGE_RETRY_LIMITS) {
+		bes2600_info(BES2600_DBG_STA, "[STA] Retry limits: %d (long), %d (short).\n",
+			 conf->long_frame_max_tx_count,
+			 conf->short_frame_max_tx_count);
+		spin_lock_bh(&hw_priv->tx_policy_cache.lock);
+		hw_priv->long_frame_max_tx_count = conf->long_frame_max_tx_count;
+		hw_priv->short_frame_max_tx_count =
+			(conf->short_frame_max_tx_count < 0x0F) ?
+			conf->short_frame_max_tx_count : 0x0F;
+		hw_priv->hw->max_rate_tries = hw_priv->short_frame_max_tx_count;
+		spin_unlock_bh(&hw_priv->tx_policy_cache.lock);
+	}
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+
+	return ret;
+}
+
+void bes2600_update_filtering(struct bes2600_vif *priv)
+{
+	int ret;
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	bool bssid_filtering = !priv->rx_filter.bssid;
+	static struct wsm_beacon_filter_control bf_disabled = {
+		.enabled = 0,
+		.bcn_count = 1,
+	};
+	bool ap_mode = 0;
+	static struct wsm_beacon_filter_table bf_table_auto = {
+		.numOfIEs = __cpu_to_le32(2),
+		.entry[0].ieId = WLAN_EID_VENDOR_SPECIFIC,
+		.entry[0].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+					WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+					WSM_BEACON_FILTER_IE_HAS_APPEARED,
+		.entry[0].oui[0] = 0x50,
+		.entry[0].oui[1] = 0x6F,
+		.entry[0].oui[2] = 0x9A,
+
+		.entry[1].ieId = WLAN_EID_HT_OPERATION,
+		.entry[1].actionFlags = WSM_BEACON_FILTER_IE_HAS_CHANGED |
+					WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT |
+					WSM_BEACON_FILTER_IE_HAS_APPEARED,
+	};
+	static struct wsm_beacon_filter_control bf_auto = {
+		.enabled = WSM_BEACON_FILTER_ENABLE |
+			WSM_BEACON_FILTER_AUTO_ERP,
+		.bcn_count = 1,
+	};
+	bf_auto.bcn_count = priv->bf_control.bcn_count;
+
+	if (priv->join_status == BES2600_JOIN_STATUS_PASSIVE)
+		return;
+	else if (priv->join_status == BES2600_JOIN_STATUS_MONITOR)
+		bssid_filtering = false;
+
+	if (priv->vif && (priv->vif->type == NL80211_IFTYPE_AP))
+		ap_mode = true;
+	/*
+	* When acting as p2p client being connected to p2p GO, in order to
+	* receive frames from a different p2p device, turn off bssid filter.
+	*
+	* WARNING: FW dependency!
+	* This can only be used with FW WSM371 and its successors.
+	* In that FW version even with bssid filter turned off,
+	* device will block most of the unwanted frames.
+	*/
+	if (priv->vif && priv->vif->p2p)
+		bssid_filtering = false;
+
+	ret = wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+	if (!ret && !ap_mode) {
+		if (priv->vif) {
+			if (priv->vif->p2p || NL80211_IFTYPE_STATION != priv->vif->type)
+				ret = wsm_set_beacon_filter_table(hw_priv, &priv->bf_table,
+							priv->if_id);
+			else
+				ret = wsm_set_beacon_filter_table(hw_priv, &bf_table_auto,
+							priv->if_id);
+		} else
+			WARN_ON(1);
+	}
+	if (!ret && !ap_mode) {
+		if (priv->disable_beacon_filter)
+			ret = wsm_beacon_filter_control(hw_priv,
+					&bf_disabled, priv->if_id);
+		else {
+			if (priv->vif) {
+				if (priv->vif->p2p || NL80211_IFTYPE_STATION != priv->vif->type)
+					ret = wsm_beacon_filter_control(hw_priv,
+						&priv->bf_control, priv->if_id);
+				else
+					ret = wsm_beacon_filter_control(hw_priv,
+						&bf_auto, priv->if_id);
+			} else
+				WARN_ON(1);
+		}
+	}
+
+	if (!ret)
+		ret = wsm_set_bssid_filtering(hw_priv, bssid_filtering,
+					priv->if_id);
+
+	if (!ret) {
+		ret = wsm_set_multicast_filter(hw_priv, &priv->multicast_filter,
+						priv->if_id);
+	}
+
+	if (ret)
+		wiphy_err(priv->hw->wiphy,
+				"%s: Update filtering failed: %d.\n",
+				__func__, ret);
+	return;
+}
+
+void bes2600_update_filtering_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif,
+		update_filtering_work);
+
+	bes2600_update_filtering(priv);
+}
+
+void bes2600_set_beacon_wakeup_period_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif,
+		set_beacon_wakeup_period_work);
+
+	WARN_ON(wsm_set_beacon_wakeup_period(priv->hw_priv,
+		priv->beacon_int * priv->join_dtim_period >
+		MAX_BEACON_SKIP_TIME_MS ? 1 :
+		priv->join_dtim_period, 0, priv->if_id));
+}
+
+u64 bes2600_prepare_multicast(struct ieee80211_hw *hw,
+			     struct netdev_hw_addr_list *mc_list)
+{
+	static u8 broadcast_ipv6[ETH_ALEN] = {
+		0x33, 0x33, 0x00, 0x00, 0x00, 0x01
+	};
+	static u8 broadcast_ipv4[ETH_ALEN] = {
+		0x01, 0x00, 0x5e, 0x00, 0x00, 0x01
+	};
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	struct netdev_hw_addr *ha;
+	int count = 0;
+
+	if(priv == NULL){
+		bes2600_info(BES2600_DBG_STA, "wlan0 removed before p2p-device\n");
+		return netdev_hw_addr_list_count(mc_list);
+	}
+
+	/* Disable multicast filtering */
+	priv->has_multicast_subscription = false;
+	memset(&priv->multicast_filter, 0x00, sizeof(priv->multicast_filter));
+
+	if (netdev_hw_addr_list_count(mc_list) > WSM_MAX_GRP_ADDRTABLE_ENTRIES)
+		return 0;
+
+	/* Enable if requested */
+	netdev_hw_addr_list_for_each(ha, mc_list) {
+		bes2600_info(BES2600_DBG_STA, "[STA] multicast: %pM\n", ha->addr);
+		memcpy(&priv->multicast_filter.macAddress[count],
+		       ha->addr, ETH_ALEN);
+		if (memcmp(ha->addr, broadcast_ipv4, ETH_ALEN) &&
+				memcmp(ha->addr, broadcast_ipv6, ETH_ALEN))
+			priv->has_multicast_subscription = true;
+		count++;
+	}
+
+	if (count) {
+		priv->multicast_filter.enable = __cpu_to_le32(1);
+		priv->multicast_filter.numOfAddresses = __cpu_to_le32(count);
+	}
+
+	return netdev_hw_addr_list_count(mc_list);
+}
+
+void bes2600_configure_filter(struct ieee80211_hw *hw,
+			     unsigned int changed_flags,
+			     unsigned int *total_flags,
+			     u64 multicast)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	*total_flags &= FIF_OTHER_BSS |
+			FIF_FCSFAIL |
+			FIF_BCN_PRBRESP_PROMISC |
+			FIF_PROBE_REQ;
+
+	if(priv != NULL){
+		down(&hw_priv->scan.lock);
+		down(&hw_priv->conf_lock);
+
+		priv->rx_filter.promiscuous = 0;
+		priv->rx_filter.bssid = (*total_flags & (FIF_OTHER_BSS |
+				FIF_PROBE_REQ)) ? 1 : 0;
+		priv->rx_filter.fcs = (*total_flags & FIF_FCSFAIL) ? 1 : 0;
+		priv->bf_control.bcn_count = (*total_flags &
+				(FIF_BCN_PRBRESP_PROMISC | FIF_PROBE_REQ)) ? 1 : 0;
+		bes2600_update_filtering(priv);
+		up(&hw_priv->conf_lock);
+		up(&hw_priv->scan.lock);
+	}
+}
+
+int bes2600_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+		    unsigned int link_id, u16 queue,
+		    const struct ieee80211_tx_queue_params *params)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	int ret = 0;
+	/* To prevent re-applying PM request OID again and again*/
+	bool old_uapsdFlags;
+
+	if (WARN_ON(!priv))
+		return -EOPNOTSUPP;
+
+	if (priv->if_id == CW12XX_GENERIC_IF_ID)
+		return 0;
+	down(&hw_priv->conf_lock);
+
+	if (queue < dev->queues) {
+		old_uapsdFlags = priv->uapsd_info.uapsdFlags;
+
+		WSM_TX_QUEUE_SET(&priv->tx_queue_params, queue, 0, 0, 0);
+		ret = wsm_set_tx_queue_params(hw_priv,
+				&priv->tx_queue_params.params[queue],
+				queue, priv->if_id);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+                WSM_EDCA_SET(&priv->edca, queue, params->aifs,
+                                params->cw_min, params->cw_max, params->txop, 0xc8,
+                                params->uapsd);
+		ret = wsm_set_edca_params(hw_priv, &priv->edca, priv->if_id);
+		if (ret) {
+			ret = -EINVAL;
+			goto out;
+		}
+
+		if (priv->mode == NL80211_IFTYPE_STATION) {
+			ret = bes2600_set_uapsd_param(priv, &priv->edca);
+		}
+	} else
+		ret = -EINVAL;
+
+out:
+	up(&hw_priv->conf_lock);
+
+	return ret;
+}
+
+int bes2600_get_stats(struct ieee80211_hw *dev,
+		     struct ieee80211_low_level_stats *stats)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+
+	memcpy(stats, &hw_priv->stats, sizeof(*stats));
+	return 0;
+}
+
+/*
+int bes2600_get_tx_stats(struct ieee80211_hw *dev,
+			struct ieee80211_tx_queue_stats *stats)
+{
+	int i;
+	struct bes2600_common *priv = dev->priv;
+
+	for (i = 0; i < dev->queues; ++i)
+		bes2600_queue_get_stats(&priv->tx_queue[i], &stats[i]);
+
+	return 0;
+}
+*/
+
+int bes2600_set_pm(struct bes2600_vif *priv, const struct wsm_set_pm *arg)
+{
+	struct wsm_set_pm pm = *arg;
+
+	if (priv->uapsd_info.uapsdFlags != 0)
+		pm.pmMode &= ~WSM_PSM_FAST_PS_FLAG;
+
+	if (memcmp(&pm, &priv->firmware_ps_mode,
+			sizeof(struct wsm_set_pm))) {
+		priv->firmware_ps_mode = pm;
+		return wsm_set_pm(priv->hw_priv, &pm,
+				priv->if_id);
+	} else {
+		return 0;
+	}
+}
+
+int bes2600_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,
+		   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		   struct ieee80211_key_conf *key)
+{
+	int ret = -EOPNOTSUPP;
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct wsm_protected_mgmt_policy mgmt_policy;
+
+	WARN_ON(priv->if_id == CW12XX_GENERIC_IF_ID);
+	memset(&mgmt_policy, 0, sizeof(mgmt_policy));
+	down(&hw_priv->conf_lock);
+	bes2600_info(BES2600_DBG_STA, "%s, cmd:%d cipher:0x%08x idx:%d\n",
+			__func__, cmd, key->cipher, key->keyidx);
+
+	if (cmd == SET_KEY) {
+		u8 *peer_addr = NULL;
+		int pairwise = (key->flags & IEEE80211_KEY_FLAG_PAIRWISE) ?
+			1 : 0;
+		int idx = bes2600_alloc_key(hw_priv);
+		struct wsm_add_key *wsm_key = &hw_priv->keys[idx];
+
+		if (idx < 0) {
+			ret = -EINVAL;
+			goto finally;
+		}
+
+		BUG_ON(pairwise && !sta);
+		if (sta)
+			peer_addr = sta->addr;
+
+		key->flags |= IEEE80211_KEY_FLAG_PUT_IV_SPACE |
+			      IEEE80211_KEY_FLAG_RESERVE_TAILROOM;
+
+		/* only need to update cipher type of pairwise key */
+		if (pairwise)
+			priv->cipherType = key->cipher;
+
+		switch (key->cipher) {
+		case WLAN_CIPHER_SUITE_WEP40:
+		case WLAN_CIPHER_SUITE_WEP104:
+			if (key->keylen > 16) {
+				bes2600_free_key(hw_priv, idx);
+				ret = -EINVAL;
+				goto finally;
+			}
+
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_WEP_PAIRWISE;
+				memcpy(wsm_key->wepPairwiseKey.peerAddress,
+					 peer_addr, ETH_ALEN);
+				memcpy(wsm_key->wepPairwiseKey.keyData,
+					&key->key[0], key->keylen);
+				wsm_key->wepPairwiseKey.keyLength = key->keylen;
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_WEP_DEFAULT;
+				memcpy(wsm_key->wepGroupKey.keyData,
+					&key->key[0], key->keylen);
+				wsm_key->wepGroupKey.keyLength = key->keylen;
+				wsm_key->wepGroupKey.keyId = key->keyidx;
+			}
+			break;
+		case WLAN_CIPHER_SUITE_TKIP:
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_TKIP_PAIRWISE;
+				memcpy(wsm_key->tkipPairwiseKey.peerAddress,
+					peer_addr, ETH_ALEN);
+				memcpy(wsm_key->tkipPairwiseKey.tkipKeyData,
+					&key->key[0],  16);
+				memcpy(wsm_key->tkipPairwiseKey.txMicKey,
+					&key->key[16],  8);
+				memcpy(wsm_key->tkipPairwiseKey.rxMicKey,
+					&key->key[24],  8);
+			} else {
+				size_t mic_offset =
+					(priv->mode == NL80211_IFTYPE_AP) ?
+					16 : 24;
+				wsm_key->type = WSM_KEY_TYPE_TKIP_GROUP;
+				memcpy(wsm_key->tkipGroupKey.tkipKeyData,
+					&key->key[0],  16);
+				memcpy(wsm_key->tkipGroupKey.rxMicKey,
+					&key->key[mic_offset],  8);
+
+				/* TODO: Where can I find TKIP SEQ? */
+				memset(wsm_key->tkipGroupKey.rxSeqCounter,
+					0,		8);
+				wsm_key->tkipGroupKey.keyId = key->keyidx;
+
+			}
+			break;
+		case WLAN_CIPHER_SUITE_CCMP:
+			if (pairwise) {
+				wsm_key->type = WSM_KEY_TYPE_AES_PAIRWISE;
+				memcpy(wsm_key->aesPairwiseKey.peerAddress,
+					peer_addr, ETH_ALEN);
+				memcpy(wsm_key->aesPairwiseKey.aesKeyData,
+					&key->key[0],  16);
+			} else {
+				wsm_key->type = WSM_KEY_TYPE_AES_GROUP;
+				memcpy(wsm_key->aesGroupKey.aesKeyData,
+					&key->key[0],  16);
+				/* TODO: Where can I find AES SEQ? */
+				memset(wsm_key->aesGroupKey.rxSeqCounter,
+					0,              8);
+				wsm_key->aesGroupKey.keyId = key->keyidx;
+			}
+			break;
+		case WLAN_CIPHER_SUITE_AES_CMAC:
+			wsm_key->type = WSM_KEY_TYPE_IGTK_GROUP;
+			memcpy(wsm_key->igtkGroupKey.IGTKKeyData, &key->key[0], 16);
+			memset(wsm_key->igtkGroupKey.IPN, 0, 8);
+			wsm_key->igtkGroupKey.keyId = key->keyidx;
+			mgmt_policy.protectedMgmtEnable = 1;
+			wsm_set_protected_mgmt_policy(hw_priv, &mgmt_policy, priv->if_id);
+			break;
+		default:
+			WARN_ON(1);
+			bes2600_free_key(hw_priv, idx);
+			ret = -EOPNOTSUPP;
+			goto finally;
+		}
+
+		ret = WARN_ON(wsm_add_key(hw_priv, wsm_key, priv->if_id));
+		if (!ret) {
+			key->hw_key_idx = idx;
+		} else {
+			bes2600_free_key(hw_priv, idx);
+		}
+
+		if (!ret && (pairwise
+			|| wsm_key->type == WSM_KEY_TYPE_WEP_DEFAULT)
+			&& (priv->filter4.enable & 0x2))
+				bes2600_set_arpreply(dev, vif);
+
+	} else if (cmd == DISABLE_KEY) {
+		struct wsm_remove_key wsm_key = {
+			.entryIndex = key->hw_key_idx,
+		};
+
+		if (wsm_key.entryIndex > WSM_KEY_MAX_IDX) {
+			ret = -EINVAL;
+			goto finally;
+		}
+
+		bes2600_free_key(hw_priv, wsm_key.entryIndex);
+		ret = wsm_remove_key(hw_priv, &wsm_key, priv->if_id);
+	} else {
+		BUG_ON("Unsupported command");
+	}
+
+finally:
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+void bes2600_wep_key_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif , wep_key_work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	u8 queueId = bes2600_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct bes2600_queue *queue = &hw_priv->tx_queue[queueId];
+	__le32 wep_default_key_id = __cpu_to_le32(
+		priv->wep_default_key_id);
+
+	BUG_ON(queueId >= 4);
+
+	bes2600_dbg(BES2600_DBG_STA, "[STA] Setting default WEP key: %d\n",
+		priv->wep_default_key_id);
+	wsm_flush_tx(hw_priv);
+	WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID,
+		&wep_default_key_id, sizeof(wep_default_key_id), priv->if_id));
+	bes2600_queue_requeue(queue, hw_priv->pending_frame_id, true);
+	wsm_unlock_tx(hw_priv);
+}
+
+int bes2600_set_rts_threshold(struct ieee80211_hw *hw, u32 value)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+	int ret;
+	__le32 val32;
+	bes2600_dbg(BES2600_DBG_TXRX_OPT,"set RTS threshold = %d\n\r", hw_priv->rtsvalue);
+
+	spin_lock(&hw_priv->rtsvalue_lock);
+	if (hw_priv->rtsvalue != value) {
+		hw_priv->rtsvalue = value;
+		//bes2600_dbg(BES2600_DBG_TXRX_OPT,"set RTS value = %d\n\r", hw_priv->rtsvalue);
+	} else {
+		spin_unlock(&hw_priv->rtsvalue_lock);
+		return 0;
+	}
+	spin_unlock(&hw_priv->rtsvalue_lock);
+
+	if (value != (u32) -1)
+		val32 = __cpu_to_le32(value);
+	else
+		val32 = 0; /* disabled */
+	/* mutex_lock(&priv->conf_mutex); */
+	ret = WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_RTS_THRESHOLD,
+		&val32, sizeof(val32), 0));
+	/* mutex_unlock(&priv->conf_mutex); */
+
+	return ret;
+}
+
+/* TODO: COMBO: Flush only a particular interface specific parts */
+int __bes2600_flush(struct bes2600_common *hw_priv, bool drop, int if_id)
+{
+	int i, ret;
+	struct bes2600_vif *priv =
+		__cw12xx_hwpriv_to_vifpriv(hw_priv, if_id);
+
+	/* clear tx queue directly if there is a bus error */
+	if(hw_priv->bh_error)
+		drop = true;
+
+	for (;;) {
+		/* TODO: correct flush handling is required when dev_stop.
+		 * Temporary workaround: 2s
+		 */
+		if (drop) {
+			for (i = 0; i < 4; ++i)
+				bes2600_queue_clear(&hw_priv->tx_queue[i],
+					if_id);
+		} else {
+			ret = wait_event_timeout(
+				hw_priv->tx_queue_stats.wait_link_id_empty,
+				bes2600_queue_stats_is_empty(
+					&hw_priv->tx_queue_stats, -1, if_id),
+				2 * HZ);
+		}
+
+		if (!drop && unlikely(ret <= 0)) {
+			bes2600_err(BES2600_DBG_STA, "__bes2600_flush: ETIMEDOUT.....\n");
+			ret = -ETIMEDOUT;
+			break;
+		} else {
+			ret = 0;
+		}
+
+		wsm_vif_lock_tx(priv);
+		if (unlikely(!bes2600_queue_stats_is_empty(
+				&hw_priv->tx_queue_stats, -1, if_id))) {
+			/* Highly unlekely: WSM requeued frames. */
+			wsm_unlock_tx(hw_priv);
+			continue;
+		}
+		break;
+	}
+	return ret;
+}
+
+void bes2600_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		  u32 queues, bool drop)
+{
+	struct bes2600_vif *priv = NULL;
+	struct bes2600_common *hw_priv = hw->priv;
+	unsigned int ret = 0;
+	int i;
+
+	/* get queue status */
+	if (vif) {
+		priv = cw12xx_get_vif_from_ieee80211(vif);
+		ret |= !bes2600_queue_stats_is_empty(
+				&hw_priv->tx_queue_stats, -1, priv->if_id);
+	} else {
+		bes2600_for_each_vif(hw_priv, priv, i) {
+			if (!priv)
+				continue;
+			if (!(hw_priv->if_id_slot & BIT(priv->if_id)))
+				return;
+			ret |= !bes2600_queue_stats_is_empty(
+				&hw_priv->tx_queue_stats, -1, priv->if_id);
+		}
+	}
+
+	/* no need to do the next work if queue was already clear */
+	if(ret == 0) {
+		bes2600_info(BES2600_DBG_STA, "no need to flush\n");
+		return;
+	}
+
+	/* do flush operation */
+	bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_FLUSH);
+	if (vif) {
+		priv = cw12xx_get_vif_from_ieee80211(vif);
+		if (!(hw_priv->if_id_slot & BIT(priv->if_id)))
+			return;
+		if (!WARN_ON(__bes2600_flush(hw_priv, drop, priv->if_id)))
+			wsm_unlock_tx(hw_priv);
+	} else {
+		bes2600_for_each_vif(hw_priv, priv, i) {
+			if (!priv)
+				continue;
+			if (!(hw_priv->if_id_slot & BIT(priv->if_id)))
+				return;
+			if (!WARN_ON(__bes2600_flush(hw_priv, drop, priv->if_id)))
+				wsm_unlock_tx(hw_priv);
+		}
+	}
+	bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_FLUSH);
+
+	return;
+}
+
+int bes2600_remain_on_channel(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_channel *chan,
+				 int duration,
+				 enum ieee80211_roc_type type)
+{
+	int ret;
+	struct bes2600_common *hw_priv = hw->priv;
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	int if_id = priv->if_id;
+
+	bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_ROC);
+	down(&hw_priv->scan.lock);
+	down(&hw_priv->conf_lock);
+
+
+	bes2600_info(BES2600_DBG_ROC, "ROC IN %d ch %d\n", priv->if_id, chan->hw_value);
+	hw_priv->roc_if_id = priv->if_id;
+	ret = WARN_ON(__bes2600_flush(hw_priv, false, if_id));
+	wsm_unlock_tx(hw_priv);
+	ret = bes2600_enable_listening(priv, chan);
+
+	if (!ret) {
+		atomic_set(&hw_priv->remain_on_channel, 1);
+		queue_delayed_work(hw_priv->workqueue,
+				   &hw_priv->rem_chan_timeout,
+				   duration * HZ / 1000);
+		priv->join_status = BES2600_JOIN_STATUS_MONITOR;
+		ieee80211_ready_on_channel(hw);
+	} else {
+		hw_priv->roc_if_id = -1;
+		up(&hw_priv->scan.lock);
+		bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_ROC);
+	}
+
+	bes2600_info(BES2600_DBG_ROC, "ROC OUT %d\n", priv->if_id);
+
+	/* set the channel to supplied ieee80211_channel pointer, if it
+        is not set. This is to remove the crash while sending a probe res
+        in listen state. Later channel will updated on
+        IEEE80211_CONF_CHANGE_CHANNEL event*/
+	if(!hw_priv->channel) {
+		hw_priv->channel = chan;
+	}
+	//hw_priv->roc_cookie = cookie;
+	up(&hw_priv->conf_lock);
+	return ret;
+}
+
+int bes2600_cancel_remain_on_channel(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif)
+{
+	struct bes2600_common *hw_priv = hw->priv;
+
+	bes2600_info(BES2600_DBG_STA, "[STA] Cancel remain on channel\n");
+
+	if (atomic_read(&hw_priv->remain_on_channel))
+		cancel_delayed_work_sync(&hw_priv->rem_chan_timeout);
+
+	if (atomic_read(&hw_priv->remain_on_channel))
+		bes2600_rem_chan_timeout(&hw_priv->rem_chan_timeout.work);
+
+	return 0;
+}
+
+/* ******************************************************************** */
+/* WSM callbacks							*/
+
+void bes2600_channel_switch_cb(struct bes2600_common *hw_priv)
+{
+	//wsm_unlock_tx(hw_priv);  /* already unlock in wsm_channel_switch_indication */
+}
+
+void bes2600_free_event_queue(struct bes2600_common *hw_priv)
+{
+	LIST_HEAD(list);
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	__bes2600_free_event_queue(&list);
+}
+
+void bes2600_event_handler(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, event_handler);
+	struct bes2600_vif *priv;
+	struct bes2600_wsm_event *event;
+	LIST_HEAD(list);
+
+	spin_lock(&hw_priv->event_queue_lock);
+	list_splice_init(&hw_priv->event_queue, &list);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	down(&hw_priv->conf_lock);
+	list_for_each_entry(event, &list, link) {
+		priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, event->if_id);
+		if (!priv) {
+			bes2600_dbg(BES2600_DBG_STA, "[CQM] Event for non existing "
+				   "interface, ignoring.\n");
+			continue;
+		}
+		switch (event->evt.eventId) {
+			case WSM_EVENT_ERROR:
+				/* I even don't know what is it about.. */
+				//STUB();
+				break;
+			case WSM_EVENT_BSS_LOST:
+			{
+				spin_lock(&priv->bss_loss_lock);
+				if (priv->bss_loss_status > BES2600_BSS_LOSS_NONE) {
+					spin_unlock(&priv->bss_loss_lock);
+					break;
+				}
+				priv->bss_loss_status = BES2600_BSS_LOSS_CHECKING;
+				spin_unlock(&priv->bss_loss_lock);
+				bes2600_info(BES2600_DBG_STA, "[CQM] BSS lost.\n");
+				bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_BSS_LOST);
+				cancel_delayed_work_sync(&priv->bss_loss_work);
+				cancel_delayed_work_sync(&priv->connection_loss_work);
+				if (!down_trylock(&hw_priv->scan.lock)) {
+					up(&hw_priv->scan.lock);
+					priv->delayed_link_loss = 0;
+					queue_delayed_work(hw_priv->workqueue,
+							&priv->bss_loss_work, 0);
+				} else {
+					/* Scan is in progress. Delay reporting. */
+					/* Scan complete will trigger bss_loss_work */
+					priv->delayed_link_loss = 1;
+					/* Also we're starting watchdog. */
+					queue_delayed_work(hw_priv->workqueue,
+							&priv->bss_loss_work, 10 * HZ);
+				}
+				break;
+			}
+			case WSM_EVENT_BSS_REGAINED:
+			{
+				bes2600_info(BES2600_DBG_STA, "[CQM] BSS regained.\n");
+				priv->delayed_link_loss = 0;
+				spin_lock(&priv->bss_loss_lock);
+				priv->bss_loss_status = BES2600_BSS_LOSS_NONE;
+				spin_unlock(&priv->bss_loss_lock);
+				bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_BSS_LOST);
+				cancel_delayed_work_sync(&priv->bss_loss_work);
+				cancel_delayed_work_sync(&priv->connection_loss_work);
+				break;
+			}
+			case WSM_EVENT_RADAR_DETECTED:
+				//STUB();
+				break;
+			case WSM_EVENT_RCPI_RSSI:
+			{
+				/* RSSI: signed Q8.0, RCPI: unsigned Q7.1
+				 * RSSI = RCPI / 2 - 110
+				 */
+				int rcpi_rssi = (int)(event->evt.eventData & 0xFF);
+				int cqm_evt;
+				if (priv->cqm_use_rssi)
+					rcpi_rssi = (s8)rcpi_rssi;
+				else
+					rcpi_rssi =  rcpi_rssi / 2 - 110;
+
+				cqm_evt = (rcpi_rssi <= priv->cqm_rssi_thold) ?
+					NL80211_CQM_RSSI_THRESHOLD_EVENT_LOW :
+					NL80211_CQM_RSSI_THRESHOLD_EVENT_HIGH;
+				bes2600_info(BES2600_DBG_STA, "[CQM] RSSI event: %d.\n", rcpi_rssi);
+				ieee80211_cqm_rssi_notify(priv->vif, cqm_evt, rcpi_rssi, GFP_KERNEL);
+				break;
+			}
+			case WSM_EVENT_BT_INACTIVE:
+				//STUB();
+				break;
+			case WSM_EVENT_BT_ACTIVE:
+				//STUB();
+				break;
+			case WSM_EVENT_INACTIVITY:
+			{
+				int link_id = ffs((u32)(event->evt.eventData)) - 1;
+				struct sk_buff *skb;
+				struct ieee80211_mgmt *deauth;
+				struct bes2600_link_entry *entry = NULL;
+
+				bes2600_info(BES2600_DBG_STA, "Inactivity Event Recieved for "
+						"link_id %d\n", link_id);
+				cw12xx_unmap_link(priv, link_id);
+
+				skb = dev_alloc_skb(sizeof(struct ieee80211_mgmt) + 64);
+				skb_reserve(skb, 64);
+				deauth = (struct ieee80211_mgmt *)skb_put(skb, sizeof(struct ieee80211_mgmt));
+				WARN_ON(!deauth);
+				entry = &priv->link_id_db[link_id - 1];
+				deauth->duration = 0;
+				memcpy(deauth->da, priv->vif->addr, ETH_ALEN);
+				memcpy(deauth->sa, entry->mac/*priv->link_id_db[i].mac*/, ETH_ALEN);
+				memcpy(deauth->bssid, priv->vif->addr, ETH_ALEN);
+				deauth->frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+						IEEE80211_STYPE_DEAUTH | IEEE80211_FCTL_TODS);
+				deauth->u.deauth.reason_code = WLAN_REASON_DEAUTH_LEAVING;
+				deauth->seq_ctrl = 0;
+				ieee80211_rx_irqsafe(priv->hw, skb);
+				bes2600_info(BES2600_DBG_STA, " Inactivity Deauth Frame sent for MAC SA %pM \t and DA %pM\n", deauth->sa, deauth->da);
+				queue_work(priv->hw_priv->workqueue, &priv->set_tim_work);
+				break;
+			}
+		case WSM_EVENT_PS_MODE_ERROR:
+			{
+				bes2600_err(BES2600_DBG_STA, " PS Mode Error, Reason:%u\n", event->evt.eventData);
+
+				if (event->evt.eventData != WSM_PS_ERROR_AP_NO_DATA_AFTER_TIM &&
+				    !priv->uapsd_info.uapsdFlags &&
+				    (priv->user_pm_mode != WSM_PSM_PS))
+				{
+					bes2600_pwr_mark_ap_lp_bad(hw_priv);
+				 	priv->powersave_mode.pmMode = WSM_PSM_ACTIVE;
+				}
+				break;
+			}
+		case WSM_EVENT_WAKEUP_EVENT:
+			bes2600_info(BES2600_DBG_STA, "wifi wakeup, Reason:%u\n", event->evt.eventData);
+			bes2600_chrdev_wifi_update_wakeup_reason(event->evt.eventData);
+			break;
+		}
+	}
+	up(&hw_priv->conf_lock);
+	__bes2600_free_event_queue(&list);
+}
+
+void bes2600_bss_loss_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, bss_loss_work.work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	int timeout; /* in beacons */
+	struct sk_buff *skb;
+	struct ieee80211_tx_info *info;
+	static int bl_ck_cnt = 0;
+	static int bl_cfm_cnt = 0;
+
+	timeout = priv->cqm_link_loss_count -
+		priv->cqm_beacon_loss_count;
+
+	/* Skip the confimration procedure in P2P case */
+	if (priv->vif->p2p)
+		goto report;
+
+	spin_lock(&priv->bss_loss_lock);
+	if (!priv->vif->cfg.assoc) {
+		priv->bss_loss_status = BES2600_BSS_LOSS_NONE;
+		spin_unlock(&priv->bss_loss_lock);
+		bl_ck_cnt = 0;
+		bl_cfm_cnt = 0;
+		return;
+	}
+	if (priv->bss_loss_status == BES2600_BSS_LOSS_CHECKING) {
+		spin_unlock(&priv->bss_loss_lock);
+		bes2600_info(BES2600_DBG_STA, "bl checking\n");
+		priv->cmq_tx_success_count = 0;
+		bl_ck_cnt = 0;
+		bl_cfm_cnt = 0;
+		skb = ieee80211_nullfunc_get(priv->hw, priv->vif, 0, false);
+		if (!(WARN_ON(!skb))) {
+			info = IEEE80211_SKB_CB(skb);
+			info->control.vif = priv->vif;
+			bes2600_tx(priv->hw, NULL, skb);
+			/* Start watchdog -- if nullfunc TX doesn't fail
+			 * in 1 sec, forward event to upper layers */
+			queue_delayed_work(hw_priv->workqueue,
+					   &priv->bss_loss_work, 1 * HZ);
+		}
+		return;
+	} else if (priv->bss_loss_status == BES2600_BSS_LOSS_CONFIRMING) {
+		/* reset cca to workaround rx stuck issue */
+		// bes2600_cca_soft_reset();
+
+		/* succeeded to send last null frame */
+		bl_cfm_cnt = 0;
+		/* keep checking to wait bss regain*/
+		bes2600_info(BES2600_DBG_STA, "bl ck %d\n", bl_ck_cnt);
+		if (bl_ck_cnt++ < BSS_LOSS_CK_THR) {
+			spin_unlock(&priv->bss_loss_lock);
+			priv->bss_loss_status = BES2600_BSS_LOSS_CHECKING;
+			skb = ieee80211_nullfunc_get(priv->hw, priv->vif, 0, false);
+			if (!(WARN_ON(!skb))) {
+				info = IEEE80211_SKB_CB(skb);
+				info->control.vif = priv->vif;
+				bes2600_tx(priv->hw, NULL, skb);
+				/* detect every 3s until receive bss regain event */
+				queue_delayed_work(hw_priv->workqueue,
+						   &priv->bss_loss_work, BSS_LOSS_CK_INV * HZ / 1000);
+			}
+			return;
+		} else {
+			bl_ck_cnt = 0;
+		}
+	} else if (priv->bss_loss_status == BES2600_BSS_LOSS_CONFIRMED) {
+		/* failed to send last null frame */
+		/* check if continous failures occur */
+		if (priv->cmq_tx_success_count != 0) {
+			bes2600_info(BES2600_DBG_STA, "bl reset ck cfm s_cnt=%d\n", priv->cmq_tx_success_count);
+			bl_ck_cnt = 0;
+			bl_cfm_cnt = 0;
+			priv->cmq_tx_success_count = 0;
+		}
+		bes2600_info(BES2600_DBG_STA, "bl cfm %d\n", bl_cfm_cnt);
+		if (bl_cfm_cnt++ < BSS_LOSS_CFM_THR) {
+			spin_unlock(&priv->bss_loss_lock);
+			priv->bss_loss_status = BES2600_BSS_LOSS_CHECKING;
+			skb = ieee80211_nullfunc_get(priv->hw, priv->vif, 0, false);
+			if (!(WARN_ON(!skb))) {
+				info = IEEE80211_SKB_CB(skb);
+				info->control.vif = priv->vif;
+				bes2600_tx(priv->hw, NULL, skb);
+				queue_delayed_work(hw_priv->workqueue,
+						   &priv->bss_loss_work, BSS_LOSS_CK_INV * HZ / 1000);
+			}
+			return;
+		} else {
+			bl_cfm_cnt = 0;
+		}
+	}
+	spin_unlock(&priv->bss_loss_lock);
+
+report:
+	if (priv->cqm_beacon_loss_count) {
+		bes2600_info(BES2600_DBG_STA, "[CQM] Beacon loss.\n");
+		if (timeout <= 0)
+			timeout = 0;
+	} else {
+		timeout = 0;
+	}
+
+	cancel_delayed_work_sync(&priv->connection_loss_work);
+	queue_delayed_work(hw_priv->workqueue,
+		&priv->connection_loss_work,
+		timeout * HZ / 10);
+
+	spin_lock(&priv->bss_loss_lock);
+	priv->bss_loss_status = BES2600_BSS_LOSS_NONE;
+	spin_unlock(&priv->bss_loss_lock);
+}
+
+void bes2600_connection_loss_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif,
+				connection_loss_work.work);
+	bes2600_info(BES2600_DBG_STA, "[CQM] Reporting connection loss.\n");
+	bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_BSS_LOST);
+	ieee80211_connection_loss(priv->vif);
+	// set disconnected in BSS_CHANGED_ASSOC
+	// bwifi_change_current_status(hw_priv, BWIFI_STATUS_DISCONNECTED);
+}
+
+void bes2600_tx_failure_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, tx_failure_work);
+	bes2600_info(BES2600_DBG_STA, "[CQM] Reporting TX failure.\n");
+	(void)priv;
+}
+
+/* ******************************************************************** */
+/* Internal API								*/
+
+
+
+/*
+* This function is called to Parse the SDD file
+ *to extract listen_interval and PTA related information
+*/
+int bes2600_parse_SDD_file(struct bes2600_common *hw_priv)
+{
+	u8 *sdd_data = (u8 *)hw_priv->sdd->data;
+	struct bes2600_sdd {
+		u8 id ;
+		u8 length ;
+		u8 data[] ;
+	} *pElement;
+	int parsedLength = 0;
+	#define SDD_PTA_CFG_ELT_ID 0xEB
+	#define FIELD_OFFSET(type, field) ((u8 *)&((type *)0)->field - (u8 *)0)
+
+	hw_priv->is_BT_Present = false;
+
+	pElement = (struct bes2600_sdd *)sdd_data;
+
+	pElement = (struct bes2600_sdd *)((u8 *)pElement +
+		FIELD_OFFSET(struct bes2600_sdd, data) + pElement->length);
+
+	parsedLength += (FIELD_OFFSET(struct bes2600_sdd, data) +
+			pElement->length);
+
+	while (parsedLength <= hw_priv->sdd->size) {
+		switch (pElement->id) {
+		case SDD_PTA_CFG_ELT_ID:
+		{
+			hw_priv->conf_listen_interval =
+				(*((u16 *)pElement->data+1) >> 7) & 0x1F;
+			hw_priv->is_BT_Present = true;
+			bes2600_dbg(BES2600_DBG_STA, "PTA element found.\n");
+			bes2600_dbg(BES2600_DBG_STA, "Listen Interval %d\n",
+						hw_priv->conf_listen_interval);
+		}
+		break;
+
+		default:
+		break;
+		}
+
+		pElement = (struct bes2600_sdd *)
+			((u8 *)pElement + FIELD_OFFSET(struct bes2600_sdd, data)
+					+ pElement->length);
+		parsedLength +=
+		(FIELD_OFFSET(struct bes2600_sdd, data) + pElement->length);
+	}
+
+	if (hw_priv->is_BT_Present == false) {
+		bes2600_dbg(BES2600_DBG_STA, "PTA element NOT found.\n");
+		hw_priv->conf_listen_interval = 0;
+	}
+        bes2600_dbg(BES2600_DBG_STA, "%s output power before %d\n",__func__,hw_priv->output_power);
+        /*BUG:TX output power: Hardcoding to 20dbm if CCX is not enabled*/
+        /*TODO: This might change*/
+        if (!hw_priv->output_power)
+                hw_priv->output_power=20;
+        bes2600_dbg(BES2600_DBG_STA, "%s output power after %d\n",__func__,hw_priv->output_power);
+	return 0;
+
+	#undef SDD_PTA_CFG_ELT_ID
+	#undef FIELD_OFFSET
+}
+
+#define USE_FEM 0
+const uint8_t sdd_22[] =
+{
+	0xc0, 0x02, 0x02, 0x03,
+	0xc1, 0x06, 0x00, 0x01, 0x00, 0x00, 0x4c, 0x00,
+	0xc4, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xc5, 0x02, 0x90, 0x65,
+	0xc7, 0x02, 0x05, 0x00,
+	0xe9, 0x02, 0xB8, 0x0B,	// SddWakeupDriftInUsPerSecond=3000
+	0xea, 0x0a, 0x00, 0x00, 0x38, 0x00, 0x80, 0x00, 0x78, 0x00, 0x80, 0x00,
+	0xeb, 0x1e, 0x06, 0x00, 0x81, 0x02, 0x01, 0x34, 0x0d, 0x21, 0x11, 0x1d, 0x7c, 0x85, 0x6b, 0x6e, 0x0d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xfe, 0x02, 0x00, 0x00,
+	0xc1, 0x06, 0x01, 0x01, 0x00, 0x00, 0x30, 0x00,
+	0xf0, 0x22, 0x41, 0x44, 0x42, 0x5f, 0x32, 0x39, 0x30, 0x35, 0x5f, 0x31, 0x32, 0x35, 0x30, 0x5f, 0x52, 0x32, 0x30, 0x5f, 0x4c, 0x6f, 0x77, 0x5f, 0x53, 0x4d, 0x50, 0x53, 0x5f, 0x76, 0x37, 0x2e, 0x30, 0x31, 0x00, 0x00,
+	0xfe, 0x02, 0x00, 0x00,
+	0xc1, 0x06, 0x03, 0x01, 0x00, 0x00, 0xb4, 0x02,
+	0xec, 0x12, 0x05, 0x00, 0x01, 0xc0, 0xc0, 0x02, 0xc0, 0xc0, 0x0b, 0xc0, 0xc0, 0x0c, 0xc0, 0xc0, 0x0d, 0xc0, 0xc0, 0x00,
+	0xed, 0x0e, 0x05, 0x00, 0xb8, 0x78, 0x22, 0x78, 0x34, 0x78, 0x64, 0x78, 0x95, 0x78, 0x00, 0x00,
+	0xe3, 0x1a, 0x1c, 0x01, 0x1c, 0x01, 0x18, 0x01, 0x18, 0x01, 0x18, 0x01, 0x18, 0x01, 0x18, 0x01, 0x10, 0x01, 0x00, 0x01, 0xf0, 0x00, 0xe0, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xe4, 0x1a, 0x24, 0x01, 0x24, 0x01, 0x24, 0x01, 0x24, 0x01, 0x24, 0x01, 0x24, 0x01, 0x14, 0x01, 0x04, 0x01, 0xf4, 0x00, 0xe4, 0x00, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x20, 0x1a, 0x8d, 0x03, 0x73, 0x02, 0x73, 0x03, 0x40, 0x03, 0xb3, 0x02, 0x40, 0x04, 0xcd, 0x04, 0x5f, 0x00, 0x00, 0x05, 0x5f, 0x00, 0x33, 0x05, 0x5f, 0x00, 0x00, 0x00,
+	0x21, 0x1a, 0x73, 0x03, 0x73, 0x02, 0x8d, 0x02, 0x40, 0x03, 0x1a, 0x02, 0x40, 0x04, 0x00, 0x04, 0x38, 0x00, 0xcd, 0x04, 0x66, 0x00, 0x00, 0x05, 0x57, 0x00, 0x00, 0x00,
+	0x22, 0x02, 0x07, 0x00,
+	0x23, 0x02, 0x07, 0x00,
+	0x30, 0x02, 0x08, 0x00,
+	0x31, 0x02, 0x08, 0x00,
+	0xe0, 0x02, 0x3a, 0x00,
+	0xe1, 0x02, 0x32, 0x00,
+	0x40, 0x0a, 0xf4, 0xff, 0x42, 0x00, 0xdd, 0xff, 0x3f, 0x00, 0x00, 0x00,
+	0x41, 0x0a, 0x80, 0xff, 0x63, 0x00, 0xd8, 0xff, 0x20, 0x00, 0x00, 0x00,
+	0x46, 0x22, 0x00, 0x00, 0x04, 0x1a, 0x08, 0x05, 0x01, 0x9f, 0x00, 0x00, 0x9a, 0xfd, 0x92, 0xff, 0x0a, 0x0a, 0x00, 0x00, 0xc0, 0x02, 0x6c, 0x00, 0x7c, 0xf5, 0x00, 0x00, 0x64, 0xfe, 0xca, 0xff, 0x78, 0x06, 0x00, 0x00,
+	0x47, 0x22, 0x00, 0x00, 0xbe, 0xf6, 0xe4, 0x00, 0x10, 0x05, 0x00, 0x00, 0x27, 0x01, 0x5c, 0x01, 0x44, 0x00, 0x00, 0x00, 0x14, 0xfe, 0x93, 0xff, 0xb0, 0x00, 0x00, 0x00, 0x70, 0x01, 0x4a, 0x00, 0x6f, 0xff, 0x00, 0x00,
+	0x44, 0x22, 0x00, 0x00, 0xb0, 0x03, 0x53, 0xfc, 0xf9, 0x05, 0x00, 0x00, 0xf6, 0xfe, 0x84, 0x00, 0x36, 0xff, 0x00, 0x00, 0x3b, 0x01, 0x68, 0xff, 0xe8, 0x00, 0x00, 0x00, 0x78, 0xfe, 0x7d, 0x00, 0x51, 0xff, 0x00, 0x00,
+	0x45, 0x22, 0x00, 0x00, 0xda, 0x03, 0xf0, 0xff, 0x34, 0xff, 0x00, 0x00, 0x9e, 0xff, 0xfd, 0xff, 0x0d, 0x00, 0x00, 0x00, 0xa8, 0x00, 0xe0, 0xff, 0xfe, 0xff, 0x00, 0x00, 0x7e, 0xff, 0x29, 0x00, 0xf0, 0xff, 0x00, 0x00,
+	0x42, 0x22, 0x00, 0x00, 0x08, 0xf8, 0xf0, 0xff, 0x58, 0x00, 0x00, 0x00, 0x0b, 0x00, 0x00, 0x00, 0xf8, 0xff, 0x00, 0x00, 0x89, 0xff, 0x06, 0x00, 0x05, 0x00, 0x00, 0x00, 0xd2, 0xff, 0xff, 0xff, 0xfe, 0xff, 0x00, 0x00,
+	0x43, 0x22, 0x00, 0x00, 0xac, 0x00, 0x0a, 0xff, 0x63, 0x03, 0x00, 0x00, 0x31, 0xff, 0xf2, 0x00, 0xed, 0xfe, 0x00, 0x00, 0x58, 0x00, 0xa2, 0xff, 0x93, 0x00, 0x00, 0x00, 0xb4, 0xff, 0x65, 0x00, 0x74, 0xff, 0x00, 0x00,
+	0x48, 0x16, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01, 0x40, 0x01,
+	0x49, 0x16, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01, 0x60, 0x01,
+	0x50, 0x06, 0xe4, 0x48, 0x87, 0x43, 0xef, 0xe8,
+	0x51, 0x06, 0x9b, 0x0c, 0x67, 0xef, 0x4f, 0x16,
+	0x52, 0x1a, 0x00, 0x00, 0xb4, 0x42, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe9, 0x6a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0xae, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x53, 0x1a, 0x00, 0x00, 0x9a, 0x90, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x2b, 0xcb, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x5d, 0xaa, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x54, 0x1a, 0x00, 0x00, 0x06, 0x34, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x85, 0x7e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x43, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x55, 0x1a, 0x00, 0x00, 0x10, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x98, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xe4, 0x23, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x56, 0x1a, 0x00, 0x00, 0xf3, 0xb5, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x37, 0xf8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7c, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x57, 0x1a, 0x00, 0x00, 0xc0, 0x0b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xd4, 0x4b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf5, 0x64, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0xc6, 0x22, 1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0,  1,  1,  1,  1,  0,  0,  0,  0, 0, 0,
+	0xfe, 0x02, 0x00, 0x00,
+	0xc1, 0x06, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+struct firmware g_sdd;
+
+int bes2600_setup_mac(struct bes2600_common *hw_priv)
+{
+	int ret = 0, if_id;
+	if (!hw_priv->sdd) {
+		const char *sdd_path = NULL;
+		struct wsm_configuration cfg = {
+			.dot11StationId = &hw_priv->mac_addr[0],
+		};
+
+		switch (hw_priv->hw_revision) {
+		case BES2600_HW_REV_CUT10:
+			sdd_path = SDD_FILE_10;
+			break;
+		case BES2600_HW_REV_CUT11:
+			sdd_path = SDD_FILE_11;
+			break;
+		case BES2600_HW_REV_CUT20:
+			sdd_path = SDD_FILE_20;
+			break;
+		case BES2600_HW_REV_CUT22:
+			sdd_path = SDD_FILE_22;
+			break;
+		case CW1250_HW_REV_CUT11:
+			sdd_path = SDD_FILE_1250_11;
+			break;
+		default:
+			BUG_ON(1);
+		}
+
+		g_sdd.data = sdd_22;
+		g_sdd.size = sizeof(sdd_22);
+		hw_priv->sdd = &g_sdd;
+		cfg.dpdData = sdd_22;
+		cfg.dpdData_size = g_sdd.size;
+
+		for (if_id = 0; if_id < 2;
+		     if_id++) {
+			/* Set low-power mode. */
+			ret |= WARN_ON(wsm_configuration(hw_priv, &cfg,
+				       if_id));
+		}
+		/* Parse SDD file for PTA element */
+		//bes2600_parse_SDD_file(hw_priv);
+	}
+
+	if (ret)
+		return ret;
+
+	return 0;
+}
+
+void bes2600_pending_offchanneltx_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+	container_of(work, struct bes2600_vif, pending_offchanneltx_work.work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	down(&hw_priv->conf_lock);
+
+	bes2600_dbg(BES2600_DBG_ROC, "OFFCHAN PEND IN\n");
+	bes2600_disable_listening(priv);
+	hw_priv->roc_if_id = -1;
+	bes2600_dbg(BES2600_DBG_ROC, "OFFCHAN PEND OUT\n");
+
+	up(&hw_priv->scan.lock);
+	up(&hw_priv->conf_lock);
+}
+
+void bes2600_offchannel_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, offchannel_work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	u8 queueId = bes2600_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct bes2600_queue *queue = &hw_priv->tx_queue[queueId];
+
+	BUG_ON(queueId >= 4);
+	BUG_ON(!hw_priv->channel);
+
+	if (unlikely(down_trylock(&hw_priv->scan.lock))) {
+		int ret = 0;
+		bes2600_dbg(BES2600_DBG_STA, "bes2600_offchannel_work***** drop frame\n");
+		ret = bes2600_queue_remove(queue, hw_priv->pending_frame_id);
+		if (ret)
+			bes2600_err(BES2600_DBG_STA, "bes2600_offchannel_work: "
+				       "queue_remove failed %d\n", ret);
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+	down(&hw_priv->conf_lock);
+	bes2600_dbg(BES2600_DBG_ROC, "OFFCHAN WORK IN %d\n", priv->if_id);
+	hw_priv->roc_if_id = priv->if_id;
+	if (likely(!priv->join_status)) {
+		wsm_vif_flush_tx(priv);
+		bes2600_enable_listening(priv, hw_priv->channel);
+		/* bes2600_update_filtering(priv); */
+	}
+	if (unlikely(!priv->join_status))
+		bes2600_queue_remove(queue, hw_priv->pending_frame_id);
+	else
+		bes2600_queue_requeue(queue, hw_priv->pending_frame_id, false);
+
+	queue_delayed_work(hw_priv->workqueue,
+			&priv->pending_offchanneltx_work, 204 * HZ/1000);
+	bes2600_dbg(BES2600_DBG_ROC, "OFFCHAN WORK OUT %d\n", priv->if_id);
+	up(&hw_priv->conf_lock);
+	wsm_unlock_tx(hw_priv);
+}
+
+void bes2600_join_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, join_work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	u8 queueId = bes2600_queue_get_queue_id(hw_priv->pending_frame_id);
+	struct bes2600_queue *queue = &hw_priv->tx_queue[queueId];
+	const struct bes2600_txpriv *txpriv = NULL;
+	struct sk_buff *skb = NULL;
+	const struct wsm_tx *wsm;
+	const struct ieee80211_hdr *frame;
+	const u8 *bssid;
+	struct cfg80211_bss *bss;
+	const u8 *ssidie;
+	const u8 *dtimie;
+	const struct ieee80211_tim_ie *tim = NULL;
+	struct wsm_protected_mgmt_policy mgmt_policy;
+	struct ieee80211_conf *conf = &hw_priv->hw->conf;
+	struct wsm_template_frame probe_tmp = {
+		.frame_type = WSM_FRAME_TYPE_PROBE_REQUEST,
+	};
+	/*struct wsm_reset reset = {
+		.reset_statistics = true,
+	};*/
+
+
+	BUG_ON(queueId >= 4);
+	if (bes2600_queue_get_skb(queue, hw_priv->pending_frame_id,
+			&skb, &txpriv)) {
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+	wsm = (struct wsm_tx *)&skb->data[0];
+	frame = (struct ieee80211_hdr *)&skb->data[txpriv->offset];
+	bssid = &frame->addr1[0]; /* AP SSID in a 802.11 frame */
+
+	BUG_ON(!wsm);
+	BUG_ON(!hw_priv->channel);
+
+	if (unlikely(priv->join_status)) {
+		atomic_set(&priv->connect_in_process, 0);
+		wsm_lock_tx(hw_priv);
+		bes2600_unjoin_work(&priv->unjoin_work);
+	}
+
+	cancel_delayed_work_sync(&priv->join_timeout);
+
+	bss = cfg80211_get_bss(hw_priv->hw->wiphy, hw_priv->channel, bssid, NULL, 0,
+			       IEEE80211_BSS_TYPE_ANY, IEEE80211_PRIVACY_ANY);
+
+	if (!bss) {
+		bes2600_queue_remove(queue, hw_priv->pending_frame_id);
+		wsm_unlock_tx(hw_priv);
+		return;
+	}
+	ssidie = ieee80211_bss_get_ie(bss, WLAN_EID_SSID);
+	dtimie = ieee80211_bss_get_ie(bss, WLAN_EID_TIM);
+	if (dtimie)
+		tim = (struct ieee80211_tim_ie *)&dtimie[2];
+
+	down(&hw_priv->conf_lock);
+	{
+		struct wsm_switch_channel channel;
+		struct wsm_join join = {
+			.mode = (bss->capability & WLAN_CAPABILITY_IBSS) ?
+				WSM_JOIN_MODE_IBSS : WSM_JOIN_MODE_BSS,
+			.preambleType = WSM_JOIN_PREAMBLE_SHORT,
+			.probeForJoin = 1,
+			/* dtimPeriod will be updated after association */
+			.dtimPeriod = 1,
+			.beaconInterval = bss->beacon_interval,
+		};
+
+		if (priv->if_id)
+			join.flags |= WSM_FLAG_MAC_INSTANCE_1;
+		else
+			join.flags &= ~WSM_FLAG_MAC_INSTANCE_1;
+
+		/* BT Coex related changes */
+		if (hw_priv->is_BT_Present) {
+			if (((hw_priv->conf_listen_interval * 100) %
+					bss->beacon_interval) == 0)
+				priv->listen_interval =
+					((hw_priv->conf_listen_interval * 100) /
+					bss->beacon_interval);
+			else
+				priv->listen_interval =
+					((hw_priv->conf_listen_interval * 100) /
+					bss->beacon_interval + 1);
+		}
+
+		if (tim && tim->dtim_period > 1) {
+			join.dtimPeriod = tim->dtim_period;
+			priv->join_dtim_period = tim->dtim_period;
+		}
+		priv->beacon_int = bss->beacon_interval;
+		bes2600_info(BES2600_DBG_STA, "[STA] Join DTIM: %d, interval: %d\n",
+				join.dtimPeriod, priv->beacon_int);
+
+		hw_priv->is_go_thru_go_neg = false;
+		join.channelNumber = hw_priv->channel->hw_value;
+
+		/* basicRateSet will be updated after association.
+		Currently these values are hardcoded */
+		if (hw_priv->channel->band == NL80211_BAND_5GHZ) {
+			join.band = WSM_PHY_BAND_5G;
+			join.basicRateSet = 64; /*6 mbps*/
+		}else{
+			join.band = WSM_PHY_BAND_2_4G;
+			join.basicRateSet = 7; /*1, 2, 5.5 mbps*/
+		}
+		memcpy(&join.bssid[0], bssid, sizeof(join.bssid));
+		memcpy(&priv->join_bssid[0], bssid, sizeof(priv->join_bssid));
+
+		if (ssidie) {
+			join.ssidLength = ssidie[1];
+			if (WARN_ON(join.ssidLength > sizeof(join.ssid)))
+				join.ssidLength = sizeof(join.ssid);
+			memcpy(&join.ssid[0], &ssidie[2], join.ssidLength);
+			if(strstr(&join.ssid[0],"5.1.4"))
+				msleep(200);
+		}
+
+		if (priv->vif->p2p) {
+			join.flags |= WSM_JOIN_FLAGS_P2P_GO;
+			join.flags |= (1 << 6);
+			join.basicRateSet =
+				bes2600_rate_mask_to_wsm(hw_priv, 0xFF0);
+		}
+
+		bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_JOIN);
+		wsm_flush_tx(hw_priv);
+
+		/* Queue unjoin if not associated in 3 sec. */
+		queue_delayed_work(hw_priv->workqueue,
+			&priv->join_timeout, 3 * HZ);
+
+		bes2600_disable_listening(priv);
+
+		//WARN_ON(wsm_reset(hw_priv, &reset, priv->if_id));
+		WARN_ON(wsm_set_block_ack_policy(hw_priv,
+			0, hw_priv->ba_tid_mask, priv->if_id));
+		spin_lock_bh(&hw_priv->ba_lock);
+		hw_priv->ba_ena = false;
+		hw_priv->ba_cnt = 0;
+		hw_priv->ba_acc = 0;
+		hw_priv->ba_hist = 0;
+		hw_priv->ba_cnt_rx = 0;
+		hw_priv->ba_acc_rx = 0;
+		spin_unlock_bh(&hw_priv->ba_lock);
+
+		mgmt_policy.protectedMgmtEnable = 0;
+		mgmt_policy.unprotectedMgmtFramesAllowed = 1;
+		mgmt_policy.encryptionForAuthFrame = 1;
+		wsm_set_protected_mgmt_policy(hw_priv, &mgmt_policy,
+					      priv->if_id);
+
+		/* need to switch channel before join */
+		channel.channelMode = NL80211_CHAN_NO_HT << 4;
+		channel.channelSwitchCount = 0;
+		channel.newChannelNumber = conf->chandef.chan->hw_value;
+		wsm_switch_channel(hw_priv, &channel,  priv->if_id);
+
+		/* avoid lmac assert when wpa_supplicant connect to ap without scan */
+		probe_tmp.skb = ieee80211_probereq_get(hw_priv->hw, priv->vif->addr, NULL, 0, 0);
+		if (probe_tmp.skb) {
+			wsm_set_template_frame(hw_priv, &probe_tmp, 0);
+		}
+
+		if (wsm_join(hw_priv, &join, priv->if_id)) {
+			memset(&priv->join_bssid[0],
+				0, sizeof(priv->join_bssid));
+			bes2600_queue_remove(queue, hw_priv->pending_frame_id);
+			cancel_delayed_work_sync(&priv->join_timeout);
+			bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_JOIN);
+		} else {
+			/* Upload keys */
+			bes2600_queue_requeue(queue, hw_priv->pending_frame_id,
+						true);
+			priv->join_status = BES2600_JOIN_STATUS_STA;
+			atomic_set(&priv->connect_in_process, 1);
+
+			/* Due to beacon filtering it is possible that the
+			 * AP's beacon is not known for the mac80211 stack.
+			 * Disable filtering temporary to make sure the stack
+			 * receives at least one */
+			priv->disable_beacon_filter = true;
+
+		}
+		bes2600_update_filtering(priv);
+	}
+	up(&hw_priv->conf_lock);
+	if (bss)
+		cfg80211_put_bss(hw_priv->hw->wiphy, bss);
+	wsm_unlock_tx(hw_priv);
+}
+
+void bes2600_join_timeout(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, join_timeout.work);
+	bes2600_info(BES2600_DBG_STA, "[WSM] Issue unjoin command (TMO).\n");
+	bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_JOIN);
+	atomic_set(&priv->connect_in_process, 0);
+	wsm_lock_tx(priv->hw_priv);
+	bes2600_unjoin_work(&priv->unjoin_work);
+}
+
+void bes2600_unjoin_work(struct work_struct *work)
+{
+	struct bes2600_vif *priv =
+		container_of(work, struct bes2600_vif, unjoin_work);
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	bool is_htcapie = false;
+	int i;
+	struct bes2600_vif *tmp_priv;
+
+	del_timer_sync(&hw_priv->ba_timer);
+	down(&hw_priv->conf_lock);
+	if (unlikely(atomic_read(&hw_priv->scan.in_progress)
+		|| atomic_read(&priv->connect_in_process))) {
+		if (priv->delayed_unjoin) {
+			wiphy_dbg(priv->hw->wiphy,
+				"%s: Delayed unjoin "
+				"is already scheduled.\n",
+				__func__);
+			wsm_unlock_tx(hw_priv);
+		} else {
+			bes2600_info(BES2600_DBG_AP, "delay unjoin work, scan:%d connect:%d\n",
+				atomic_read(&hw_priv->scan.in_progress), atomic_read(&priv->connect_in_process));
+			priv->delayed_unjoin = true;
+		}
+		up(&hw_priv->conf_lock);
+		return;
+	}
+
+	if (priv->join_status &&
+			priv->join_status > BES2600_JOIN_STATUS_STA) {
+		wiphy_err(priv->hw->wiphy,
+				"%s: Unexpected: join status: %d\n",
+				__func__, priv->join_status);
+		BUG_ON(1);
+	}
+	if (priv->join_status) {
+		cancel_work_sync(&priv->update_filtering_work);
+		cancel_work_sync(&priv->set_beacon_wakeup_period_work);
+		memset(&priv->join_bssid[0], 0, sizeof(priv->join_bssid));
+		txrx_opt_timer_exit(hw_priv);
+		bes2600_pwr_clear_busy_event(priv->hw_priv, BES_PWR_LOCK_ON_PS_ACTIVE);
+		bes2600_pwr_clear_ap_lp_bad_mark(hw_priv);
+		priv->join_status = BES2600_JOIN_STATUS_PASSIVE;
+
+		/* Unjoin is a reset. */
+		wsm_flush_tx(hw_priv);
+		WARN_ON(wsm_keep_alive_period(hw_priv, 0, priv->if_id));
+		WARN_ON(wsm_reset(hw_priv, &reset, priv->if_id));
+		WARN_ON(wsm_set_output_power(hw_priv,
+			hw_priv->output_power * 10, priv->if_id));
+		priv->join_dtim_period = 0;
+		priv->cipherType = 0;
+		WARN_ON(bes2600_setup_mac_pvif(priv));
+		bes2600_free_event_queue(hw_priv);
+		cancel_work_sync(&hw_priv->event_handler);
+		cancel_delayed_work_sync(&priv->connection_loss_work);
+		WARN_ON(wsm_set_block_ack_policy(hw_priv,
+			0, hw_priv->ba_tid_mask, priv->if_id));
+		priv->disable_beacon_filter = false;
+		bes2600_update_filtering(priv);
+		priv->setbssparams_done = false;
+		memset(&priv->association_mode, 0,
+			sizeof(priv->association_mode));
+		memset(&priv->bss_params, 0, sizeof(priv->bss_params));
+		memset(&priv->firmware_ps_mode, 0,
+			sizeof(priv->firmware_ps_mode));
+		priv->htcap = false;
+		bes2600_for_each_vif(hw_priv, tmp_priv, i) {
+			if ((i == (CW12XX_MAX_VIFS - 1)) || !tmp_priv)
+				continue;
+			if ((tmp_priv->join_status == BES2600_JOIN_STATUS_STA) && tmp_priv->htcap)
+				is_htcapie = true;
+		}
+
+		if (is_htcapie) {
+			hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11N_THROTTLE;
+			hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11N_THROTTLE;
+			bes2600_info(BES2600_DBG_STA, "UNJOIN HTCAP 11N %d\n",hw_priv->vif0_throttle);
+		} else {
+			hw_priv->vif0_throttle = CW12XX_HOST_VIF0_11BG_THROTTLE;
+			hw_priv->vif1_throttle = CW12XX_HOST_VIF1_11BG_THROTTLE;
+			bes2600_info(BES2600_DBG_STA, "UNJOIN 11BG %d\n",hw_priv->vif0_throttle);
+		}
+		bes2600_info(BES2600_DBG_STA, "[STA] Unjoin.\n");
+	}
+
+	up(&hw_priv->conf_lock);
+	wsm_unlock_tx(hw_priv);
+}
+
+int bes2600_enable_listening(struct bes2600_vif *priv,
+				struct ieee80211_channel *chan)
+{
+	/* TODO:COMBO: Channel is common to HW currently in mac80211.
+	Change the code below once channel is made per VIF */
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct wsm_start start = {
+		.mode = WSM_START_MODE_P2P_DEV | (priv->if_id ? (5 << 4) : 0),
+		.band = (chan->band == NL80211_BAND_5GHZ) ?
+				WSM_PHY_BAND_5G : WSM_PHY_BAND_2_4G,
+		.channelNumber = chan->hw_value,
+		.beaconInterval = 100,
+		.DTIMPeriod = 1,
+		.probeDelay = 0,
+		.basicRateSet = 0x0F,
+	};
+	if(priv->if_id != 2) {
+		//WARN_ON(priv->join_status > BES2600_JOIN_STATUS_MONITOR);
+		return -EOPNOTSUPP;
+	}
+	if (priv->join_status == BES2600_JOIN_STATUS_MONITOR)
+		return 0;
+	if (priv->join_status == BES2600_JOIN_STATUS_PASSIVE)
+		priv->join_status = BES2600_JOIN_STATUS_MONITOR;
+
+	WARN_ON(priv->join_status > BES2600_JOIN_STATUS_MONITOR);
+	bes2600_info(BES2600_DBG_STA, "bes2600_enable_listening if_id:%d\n", priv->if_id);
+	return wsm_start(hw_priv, &start, CW12XX_GENERIC_IF_ID);
+}
+
+int bes2600_disable_listening(struct bes2600_vif *priv)
+{
+	int ret;
+	struct wsm_reset reset = {
+		.reset_statistics = true,
+	};
+	if(priv->if_id != 2) {
+		WARN_ON(priv->join_status > BES2600_JOIN_STATUS_MONITOR);
+        return 0;
+	}
+	priv->join_status = BES2600_JOIN_STATUS_PASSIVE;
+
+	WARN_ON(priv->join_status > BES2600_JOIN_STATUS_MONITOR);
+
+	if (priv->hw_priv->roc_if_id == -1)
+		return 0;
+	bes2600_info(BES2600_DBG_STA, "bes2600_disable_listening if_id:%d\n", priv->if_id);
+	ret = wsm_reset(priv->hw_priv, &reset, CW12XX_GENERIC_IF_ID);
+	return ret;
+}
+
+/* TODO:COMBO:UAPSD will be supported only on one interface */
+int bes2600_set_uapsd_param(struct bes2600_vif *priv,
+				const struct wsm_edca_params *arg)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	int ret;
+	u16 uapsdFlags = 0;
+
+	/* Here's the mapping AC [queue, bit]
+	VO [0,3], VI [1, 2], BE [2, 1], BK [3, 0]*/
+
+	if (arg->params[0].uapsdEnable)
+		uapsdFlags |= 1 << 3;
+
+	if (arg->params[1].uapsdEnable)
+		uapsdFlags |= 1 << 2;
+
+	if (arg->params[2].uapsdEnable)
+		uapsdFlags |= 1 << 1;
+
+	if (arg->params[3].uapsdEnable)
+		uapsdFlags |= 1;
+
+	/* Currently pseudo U-APSD operation is not supported, so setting
+	* MinAutoTriggerInterval, MaxAutoTriggerInterval and
+	* AutoTriggerStep to 0 */
+
+	priv->uapsd_info.uapsdFlags = cpu_to_le16(uapsdFlags);
+	priv->uapsd_info.minAutoTriggerInterval = 0;
+	priv->uapsd_info.maxAutoTriggerInterval = 0;
+	priv->uapsd_info.autoTriggerStep = 0;
+
+	ret = wsm_set_uapsd_info(hw_priv, &priv->uapsd_info,
+				 priv->if_id);
+	return ret;
+}
+
+void bes2600_ba_work(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, ba_work);
+	u8 tx_ba_tid_mask;
+
+	/* TODO:COMBO: reenable this part of code */
+/*	if (priv->join_status != BES2600_JOIN_STATUS_STA)
+		return;
+	if (!priv->setbssparams_done)
+		return;*/
+
+	bes2600_info(BES2600_DBG_STA, "BA work****\n");
+	spin_lock_bh(&hw_priv->ba_lock);
+//	tx_ba_tid_mask = hw_priv->ba_ena ? hw_priv->ba_tid_mask : 0;
+	tx_ba_tid_mask = hw_priv->ba_tid_mask;
+	spin_unlock_bh(&hw_priv->ba_lock);
+
+	wsm_lock_tx(hw_priv);
+
+	WARN_ON(wsm_set_block_ack_policy(hw_priv,
+		tx_ba_tid_mask, hw_priv->ba_tid_mask, -1)); /*TODO:COMBO*/
+
+	wsm_unlock_tx(hw_priv);
+}
+
+void bes2600_ba_timer(struct timer_list *t)
+{
+	bool ba_ena;
+	struct bes2600_common *hw_priv = from_timer(hw_priv, t, ba_timer);
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	bes2600_debug_ba(hw_priv, hw_priv->ba_cnt, hw_priv->ba_acc,
+			hw_priv->ba_cnt_rx, hw_priv->ba_acc_rx);
+
+	if (atomic_read(&hw_priv->scan.in_progress)) {
+		hw_priv->ba_cnt = 0;
+		hw_priv->ba_acc = 0;
+		hw_priv->ba_cnt_rx = 0;
+		hw_priv->ba_acc_rx = 0;
+		goto skip_statistic_update;
+	}
+
+	if (hw_priv->ba_cnt >= BES2600_BLOCK_ACK_CNT &&
+		(hw_priv->ba_acc / hw_priv->ba_cnt >= BES2600_BLOCK_ACK_THLD ||
+		(hw_priv->ba_cnt_rx >= BES2600_BLOCK_ACK_CNT &&
+		hw_priv->ba_acc_rx / hw_priv->ba_cnt_rx >=
+			BES2600_BLOCK_ACK_THLD)))
+		ba_ena = true;
+	else
+		ba_ena = false;
+
+	hw_priv->ba_cnt = 0;
+	hw_priv->ba_acc = 0;
+	hw_priv->ba_cnt_rx = 0;
+	hw_priv->ba_acc_rx = 0;
+
+	if (ba_ena != hw_priv->ba_ena) {
+		if (ba_ena || ++hw_priv->ba_hist >= BES2600_BLOCK_ACK_HIST) {
+			hw_priv->ba_ena = ba_ena;
+			hw_priv->ba_hist = 0;
+		}
+	} else if (hw_priv->ba_hist)
+		--hw_priv->ba_hist;
+
+skip_statistic_update:
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+int bes2600_vif_setup(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = priv->hw_priv;
+	int ret = 0;
+
+	/* Setup per vif workitems and locks */
+	spin_lock_init(&priv->vif_lock);
+	INIT_WORK(&priv->join_work, bes2600_join_work);
+	INIT_DELAYED_WORK(&priv->join_timeout, bes2600_join_timeout);
+	INIT_WORK(&priv->unjoin_work, bes2600_unjoin_work);
+	INIT_WORK(&priv->wep_key_work, bes2600_wep_key_work);
+	INIT_WORK(&priv->offchannel_work, bes2600_offchannel_work);
+	INIT_DELAYED_WORK(&priv->bss_loss_work, bes2600_bss_loss_work);
+	INIT_DELAYED_WORK(&priv->connection_loss_work,
+			  bes2600_connection_loss_work);
+	spin_lock_init(&priv->bss_loss_lock);
+	INIT_WORK(&priv->tx_failure_work, bes2600_tx_failure_work);
+	spin_lock_init(&priv->ps_state_lock);
+	INIT_DELAYED_WORK(&priv->set_cts_work, bes2600_set_cts_work);
+	INIT_WORK(&priv->set_tim_work, bes2600_set_tim_work);
+	INIT_WORK(&priv->multicast_start_work, bes2600_multicast_start_work);
+	INIT_WORK(&priv->multicast_stop_work, bes2600_multicast_stop_work);
+	INIT_WORK(&priv->link_id_work, bes2600_link_id_work);
+	INIT_DELAYED_WORK(&priv->link_id_gc_work, bes2600_link_id_gc_work);
+	INIT_WORK(&priv->update_filtering_work, bes2600_update_filtering_work);
+	INIT_DELAYED_WORK(&priv->pending_offchanneltx_work,
+			bes2600_pending_offchanneltx_work);
+	INIT_WORK(&priv->set_beacon_wakeup_period_work,
+		bes2600_set_beacon_wakeup_period_work);
+        INIT_WORK(&priv->ht_info_update_work, bes2600_ht_info_update_work);
+	timer_setup(&priv->mcast_timeout, bes2600_mcast_timeout, 0);
+
+	priv->setbssparams_done = false;
+	priv->power_set_true = 0;
+	priv->user_power_set_true = 0;
+	priv->user_pm_mode = 0;
+	ret = bes2600_debug_init_priv(hw_priv, priv);
+	if (WARN_ON(ret))
+		goto out;
+
+	/* Initialising the broadcast filter */
+	memset(priv->broadcast_filter.MacAddr, 0xFF, ETH_ALEN);
+	priv->broadcast_filter.nummacaddr = 1;
+	priv->broadcast_filter.address_mode = WSM_FILTER_ADDR_MODE_A1;
+	priv->broadcast_filter.filter_mode = WSM_FILTER_ACTION_FILTER_OUT;
+	priv->htcap = false;
+
+	bes2600_info(BES2600_DBG_STA, "%s: enabling priv\n", __func__);
+	atomic_set(&priv->enabled, 1);
+
+	spin_lock(&hw_priv->vif_list_lock);
+	hw_priv->if_id_slot |= BIT(priv->if_id);
+	hw_priv->vif_list[priv->if_id] = priv->vif;
+	atomic_inc(&hw_priv->num_vifs);
+	spin_unlock(&hw_priv->vif_list_lock);
+	atomic_set(&priv->connect_in_process, 0);
+
+	if (priv->if_id < 2) {
+		/* default EDCA */
+		WSM_EDCA_SET(&priv->edca, 0, 0x0002, 0x0003, 0x0007,
+				47, 0xc8, false);
+		WSM_EDCA_SET(&priv->edca, 1, 0x0002, 0x0007, 0x000f,
+				94, 0xc8, false);
+			WSM_EDCA_SET(&priv->edca, 2, 0x0003, 0x000f, 0x03ff,
+				0, 0xc8, false);
+		WSM_EDCA_SET(&priv->edca, 3, 0x0007, 0x000f, 0x03ff,
+				0, 0xc8, false);
+		ret = wsm_set_edca_params(hw_priv, &priv->edca, priv->if_id);
+		if (WARN_ON(ret))
+			goto out;
+
+		ret = bes2600_set_uapsd_param(priv, &priv->edca);
+		if (WARN_ON(ret))
+			goto out;
+
+		memset(priv->bssid, ~0, ETH_ALEN);
+		priv->wep_default_key_id = -1;
+		priv->cipherType = 0;
+		priv->cqm_link_loss_count = 100;
+		priv->cqm_beacon_loss_count = 50;
+
+		/* Temporary configuration - beacon filter table */
+		__bes2600_bf_configure(priv);
+	}
+out:
+	return ret;
+}
+
+int bes2600_setup_mac_pvif(struct bes2600_vif *priv)
+{
+	int ret = 0;
+	/* NOTE: There is a bug in FW: it reports signal
+	* as RSSI if RSSI subscription is enabled.
+	* It's not enough to set WSM_RCPI_RSSI_USE_RSSI. */
+	/* NOTE2: RSSI based reports have been switched to RCPI, since
+	* FW has a bug and RSSI reported values are not stable,
+	* what can leads to signal level oscilations in user-end applications */
+	struct wsm_rcpi_rssi_threshold threshold = {
+		.rssiRcpiMode = WSM_RCPI_RSSI_THRESHOLD_ENABLE |
+		WSM_RCPI_RSSI_DONT_USE_UPPER |
+		WSM_RCPI_RSSI_DONT_USE_LOWER,
+		.rollingAverageCount = 16,
+	};
+
+	/* Remember the decission here to make sure, we will handle
+	 * the RCPI/RSSI value correctly on WSM_EVENT_RCPI_RSS */
+	if (threshold.rssiRcpiMode & WSM_RCPI_RSSI_USE_RSSI)
+		priv->cqm_use_rssi = true;
+
+
+	/* Configure RSSI/SCPI reporting as RSSI. */
+	ret = wsm_set_rcpi_rssi_threshold(priv->hw_priv, &threshold,
+					priv->if_id ? 0 : 0);
+	return ret;
+}
+
+void bes2600_rem_chan_timeout(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, rem_chan_timeout.work);
+	int ret, if_id;
+	struct bes2600_vif *priv;
+
+	if (atomic_read(&hw_priv->remain_on_channel) == 0) {
+		return;
+	}
+	ieee80211_remain_on_channel_expired(hw_priv->hw);
+
+	down(&hw_priv->conf_lock);
+	if_id = hw_priv->roc_if_id;
+	bes2600_dbg(BES2600_DBG_ROC, "ROC TO IN %d\n", if_id);
+	priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, if_id);
+	ret = WARN_ON(__bes2600_flush(hw_priv, false, if_id));
+
+	if (!ret) {
+		wsm_unlock_tx(hw_priv);
+		bes2600_disable_listening(priv);
+	}
+	atomic_set(&hw_priv->remain_on_channel, 0);
+	hw_priv->roc_if_id = -1;
+
+	bes2600_dbg(BES2600_DBG_ROC, "ROC TO OUT %d\n", if_id);
+
+	up(&hw_priv->conf_lock);
+	up(&hw_priv->scan.lock);
+	bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_ROC);
+}
+
+void bes2600_dynamic_opt_txrx_work(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, dynamic_opt_txrx_work);
+	struct bes2600_vif *priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	bes2600_dynamic_opt_rxtx(hw_priv,priv, 0);
+	bes2600_dbg(BES2600_DBG_STA, "bes2600_dynamic_opt_txrx_work called\n");
+}
+
+
+const u8 *bes2600_get_ie(u8 *start, size_t len, u8 ie)
+{
+	u8 *end, *pos;
+
+	pos = start;
+	if (pos == NULL)
+		return NULL;
+	end = pos + len;
+
+	while (pos + 1 < end) {
+		if (pos + 2 + pos[1] > end)
+			break;
+		if (pos[0] == ie)
+			return pos;
+		pos += 2 + pos[1];
+	}
+
+	return NULL;
+}
+
+/**
+ * bes2600_set_macaddrfilter -called when tesmode command
+ * is for setting mac address filter
+ *
+ * @hw: the hardware
+ * @data: incoming data
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int bes2600_set_macaddrfilter(struct bes2600_common *hw_priv, struct bes2600_vif *priv, u8 *data)
+{
+	struct wsm_mac_addr_filter *mac_addr_filter =  NULL;
+	struct wsm_mac_addr_info *addr_info = NULL;
+	u8 action_mode = 0, no_of_mac_addr = 0, i = 0;
+	int ret = 0;
+	u16 macaddrfiltersize = 0;
+
+	/* Retrieving Action Mode */
+	action_mode = data[0];
+	/* Retrieving number of address entries */
+	no_of_mac_addr = data[1];
+
+	addr_info = (struct wsm_mac_addr_info *)&data[2];
+
+	/* Computing sizeof Mac addr filter */
+	macaddrfiltersize =  sizeof(*mac_addr_filter) + \
+			(no_of_mac_addr * sizeof(struct wsm_mac_addr_info));
+
+	mac_addr_filter = kzalloc(macaddrfiltersize, GFP_KERNEL);
+	if (!mac_addr_filter) {
+		ret = -ENOMEM;
+		goto exit_p;
+	}
+	mac_addr_filter->action_mode = action_mode;
+	mac_addr_filter->numfilter = no_of_mac_addr;
+
+	for (i = 0; i < no_of_mac_addr; i++) {
+		mac_addr_filter->macaddrfilter[i].address_mode = \
+						addr_info[i].address_mode;
+		memcpy(mac_addr_filter->macaddrfilter[i].MacAddr, \
+				addr_info[i].MacAddr , ETH_ALEN);
+		mac_addr_filter->macaddrfilter[i].filter_mode = \
+						addr_info[i].filter_mode;
+	}
+	ret = WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_MAC_ADDR_FILTER, \
+					 mac_addr_filter, macaddrfiltersize, priv->if_id));
+
+	kfree(mac_addr_filter);
+exit_p:
+	return ret;
+}
+
+/**
+ * bes2600_set_data_filter -configure data filter in device
+*
+ * @hw: the hardware
+ * @vif: vif
+ * @data: incoming data
+ * @len: incoming data length
+ *
+ */
+void bes2600_set_data_filter(struct ieee80211_hw *hw,
+			   struct ieee80211_vif *vif,
+			   void *data, int len)
+{
+	int ret = 0;
+	//struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	int filter_id;
+
+	if (!data) {
+		ret = -EINVAL;
+		goto exit_p;
+	}
+	filter_id=*((enum bes2600_data_filterid*)data);
+
+	switch (filter_id) {
+	default:
+		ret = -EINVAL;
+		break;
+	}
+exit_p:
+
+	 return ;
+}
+
+u32 bes2600_bh_get_encry_hdr_len(u32 cipherType)
+{
+	u32 encrypthdr = 0;
+
+	switch (cipherType) {
+	case WLAN_CIPHER_SUITE_WEP40:
+	case WLAN_CIPHER_SUITE_WEP104:
+		encrypthdr = WEP_ENCRYPT_HDR_SIZE;
+		break;
+	case WLAN_CIPHER_SUITE_TKIP:
+		encrypthdr = WPA_ENCRYPT_HDR_SIZE;
+		break;
+	case WLAN_CIPHER_SUITE_CCMP:
+		encrypthdr = WPA2_ENCRYPT_HDR_SIZE;
+		break;
+	case WLAN_CIPHER_SUITE_SMS4:
+		encrypthdr = WAPI_ENCRYPT_HDR_SIZE;
+		break;
+	default:
+		encrypthdr = 0;
+		break;
+	}
+
+	return encrypthdr;
+}
+
+/**
+ * bes2600_set_arpreply -called for creating and
+ * configuring arp response template frame
+ *
+ * @hw: the hardware
+ *
+ * Returns: 0 on success or non zero value on failure
+ */
+int bes2600_set_arpreply(struct ieee80211_hw *hw, struct ieee80211_vif *vif)
+{
+	struct bes2600_vif *priv = cw12xx_get_vif_from_ieee80211(vif);
+	struct bes2600_common *hw_priv = (struct bes2600_common *)hw->priv;
+        u32 framehdrlen, encrypthdr, encrypttailsize, framebdylen = 0;
+        bool encrypt = false;
+        int ret = 0;
+        u8 *template_frame = NULL;
+        struct ieee80211_hdr_3addr *dot11hdr = NULL;
+        struct ieee80211_snap_hdr *snaphdr = NULL;
+        struct arphdr *arp_hdr = NULL;
+
+        template_frame = kzalloc(MAX_ARP_REPLY_TEMPLATE_SIZE, GFP_ATOMIC);
+        if (!template_frame) {
+                bes2600_err(BES2600_DBG_STA, "[STA] Template frame memory failed\n");
+                ret = -ENOMEM;
+                goto exit_p;
+        }
+        dot11hdr = (struct ieee80211_hdr_3addr *)&template_frame[4];
+
+        framehdrlen = sizeof(*dot11hdr);
+        if ((priv->vif->type == NL80211_IFTYPE_AP) && priv->vif->p2p)
+                priv->cipherType = WLAN_CIPHER_SUITE_CCMP;
+        switch (priv->cipherType) {
+
+        case WLAN_CIPHER_SUITE_WEP40:
+        case WLAN_CIPHER_SUITE_WEP104:
+                bes2600_dbg(BES2600_DBG_STA, "[STA] WEP\n");
+                encrypthdr = WEP_ENCRYPT_HDR_SIZE;
+                encrypttailsize = WEP_ENCRYPT_TAIL_SIZE;
+                encrypt = 1;
+                break;
+
+
+        case WLAN_CIPHER_SUITE_TKIP:
+                bes2600_dbg(BES2600_DBG_STA, "[STA] WPA\n");
+                encrypthdr = WPA_ENCRYPT_HDR_SIZE;
+                encrypttailsize = WPA_ENCRYPT_TAIL_SIZE;
+                encrypt = 1;
+                break;
+
+        case WLAN_CIPHER_SUITE_CCMP:
+                bes2600_dbg(BES2600_DBG_STA, "[STA] WPA2\n");
+                encrypthdr = WPA2_ENCRYPT_HDR_SIZE;
+                encrypttailsize = WPA2_ENCRYPT_TAIL_SIZE;
+                encrypt = 1;
+                break;
+
+        case WLAN_CIPHER_SUITE_SMS4:
+                bes2600_dbg(BES2600_DBG_STA, "[STA] WAPI\n");
+                encrypthdr = WAPI_ENCRYPT_HDR_SIZE;
+                encrypttailsize = WAPI_ENCRYPT_TAIL_SIZE;
+                encrypt = 1;
+                break;
+
+        default:
+                encrypthdr = 0;
+                encrypttailsize = 0;
+                encrypt = 0;
+                break;
+        }
+
+        framehdrlen += encrypthdr;
+
+        /* Filling the 802.11 Hdr */
+        dot11hdr->frame_control = cpu_to_le16(IEEE80211_FTYPE_DATA);
+        if (priv->vif->type == NL80211_IFTYPE_STATION)
+                dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_TODS);
+        else
+                dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_FROMDS);
+
+        if (encrypt)
+                dot11hdr->frame_control |= cpu_to_le16(IEEE80211_FCTL_WEP);
+
+        if (priv->vif->bss_conf.qos) {
+                bes2600_dbg(BES2600_DBG_STA, "[STA] QOS Enabled\n");
+                dot11hdr->frame_control |= cpu_to_le16(IEEE80211_QOS_DATAGRP);
+                 *(u16 *)(dot11hdr + 1) = 0x0;
+                 framehdrlen += 2;
+        } else {
+                dot11hdr->frame_control |= cpu_to_le16(IEEE80211_STYPE_DATA);
+        }
+
+        memcpy(dot11hdr->addr1, priv->vif->bss_conf.bssid, ETH_ALEN);
+        memcpy(dot11hdr->addr2, priv->vif->addr, ETH_ALEN);
+        memcpy(dot11hdr->addr3, priv->vif->bss_conf.bssid, ETH_ALEN);
+
+        /* Filling the LLC/SNAP Hdr */
+        snaphdr = (struct ieee80211_snap_hdr *)((u8 *)dot11hdr + framehdrlen);
+        memcpy(snaphdr, (struct ieee80211_snap_hdr *)rfc1042_header, \
+                sizeof(*snaphdr));
+        *(u16 *)(++snaphdr) = cpu_to_be16(ETH_P_ARP);
+        /* Updating the framebdylen with snaphdr and LLC hdr size */
+        framebdylen = sizeof(*snaphdr) + 2;
+
+        /* Filling the ARP Reply Payload */
+        arp_hdr = (struct arphdr *)((u8 *)dot11hdr + framehdrlen + framebdylen);
+        arp_hdr->ar_hrd = cpu_to_be16(ARPHRD_ETHER);
+        arp_hdr->ar_pro = cpu_to_be16(ETH_P_IP);
+        arp_hdr->ar_hln = ETH_ALEN;
+        arp_hdr->ar_pln = 4;
+        arp_hdr->ar_op = cpu_to_be16(ARPOP_REPLY);
+
+        /* Updating the frmbdylen with Arp Reply Hdr and Arp payload size(20) */
+        framebdylen += sizeof(*arp_hdr) + 20;
+
+        /* Updating the framebdylen with Encryption Tail Size */
+        framebdylen += encrypttailsize;
+
+        /* Filling the Template Frame Hdr */
+        template_frame[0] = WSM_FRAME_TYPE_ARP_REPLY; /* Template frame type */
+        template_frame[1] = 0xFF; /* Rate to be fixed */
+        ((u16 *)&template_frame[2])[0] = framehdrlen + framebdylen;
+
+        ret = WARN_ON(wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, \
+                                template_frame, (framehdrlen+framebdylen+4), priv->if_id));
+        kfree(template_frame);
+exit_p:
+        return ret;
+}
diff --git a/drivers/staging/bes2600/sta.h b/drivers/staging/bes2600/sta.h
new file mode 100755
index 000000000000..d8cf16ecd209
--- /dev/null
+++ b/drivers/staging/bes2600/sta.h
@@ -0,0 +1,125 @@
+/*
+ * Mac80211 STA interface for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/version.h>
+#ifndef STA_H_INCLUDED
+#define STA_H_INCLUDED
+
+/* ******************************************************************** */
+/* mac80211 API								*/
+
+int bes2600_start(struct ieee80211_hw *dev);
+void bes2600_stop(struct ieee80211_hw *dev);
+int bes2600_add_interface(struct ieee80211_hw *dev,
+			 struct ieee80211_vif *vif);
+void bes2600_remove_interface(struct ieee80211_hw *dev,
+			     struct ieee80211_vif *vif);
+int bes2600_change_interface(struct ieee80211_hw *dev,
+				struct ieee80211_vif *vif,
+				enum nl80211_iftype new_type,
+				bool p2p);
+
+int bes2600_config(struct ieee80211_hw *dev, u32 changed);
+int bes2600_change_interface(struct ieee80211_hw *dev,
+                                struct ieee80211_vif *vif,
+                                enum nl80211_iftype new_type,
+                                bool p2p);
+void bes2600_configure_filter(struct ieee80211_hw *dev,
+			     unsigned int changed_flags,
+			     unsigned int *total_flags,
+			     u64 multicast);
+int bes2600_conf_tx(struct ieee80211_hw *dev, struct ieee80211_vif *vif,
+		    unsigned int link_id, u16 queue,
+		    const struct ieee80211_tx_queue_params *params);
+int bes2600_get_stats(struct ieee80211_hw *dev,
+		     struct ieee80211_low_level_stats *stats);
+/* Not more a part of interface?
+int bes2600_get_tx_stats(struct ieee80211_hw *dev,
+			struct ieee80211_tx_queue_stats *stats);
+*/
+int bes2600_set_key(struct ieee80211_hw *dev, enum set_key_cmd cmd,
+		   struct ieee80211_vif *vif, struct ieee80211_sta *sta,
+		   struct ieee80211_key_conf *key);
+
+int bes2600_set_rts_threshold(struct ieee80211_hw *hw, u32 value);
+
+void bes2600_flush(struct ieee80211_hw *hw, struct ieee80211_vif *vif,
+		  u32 queues, bool drop);
+
+int bes2600_remain_on_channel(struct ieee80211_hw *hw,
+				 struct ieee80211_vif *vif,
+				 struct ieee80211_channel *chan,
+				 int duration,
+				 enum ieee80211_roc_type type);
+
+int bes2600_cancel_remain_on_channel(struct ieee80211_hw *hw,
+				     struct ieee80211_vif *vif);
+
+int bes2600_set_arpreply(struct ieee80211_hw *hw, struct ieee80211_vif *vif);
+
+u64 bes2600_prepare_multicast(struct ieee80211_hw *hw,
+			     struct netdev_hw_addr_list *mc_list);
+
+int bes2600_set_pm(struct bes2600_vif *priv, const struct wsm_set_pm *arg);
+
+void bes2600_set_data_filter(struct ieee80211_hw *hw,
+			   struct ieee80211_vif *vif,
+			   void *data,
+			   int len);
+
+u32 bes2600_bh_get_encry_hdr_len(u32 cipherType);
+/* ******************************************************************** */
+/* WSM callbacks							*/
+
+/* void bes2600_set_pm_complete_cb(struct bes2600_common *hw_priv,
+	struct wsm_set_pm_complete *arg); */
+void bes2600_channel_switch_cb(struct bes2600_common *hw_priv);
+
+/* ******************************************************************** */
+/* WSM events								*/
+
+void bes2600_free_event_queue(struct bes2600_common *hw_priv);
+void bes2600_event_handler(struct work_struct *work);
+void bes2600_bss_loss_work(struct work_struct *work);
+void bes2600_connection_loss_work(struct work_struct *work);
+void bes2600_keep_alive_work(struct work_struct *work);
+void bes2600_tx_failure_work(struct work_struct *work);
+void bes2600_dynamic_opt_txrx_work(struct work_struct *work);
+
+/* ******************************************************************** */
+/* Internal API								*/
+
+int bes2600_setup_mac(struct bes2600_common *hw_priv);
+void bes2600_join_work(struct work_struct *work);
+void bes2600_join_timeout(struct work_struct *work);
+void bes2600_unjoin_work(struct work_struct *work);
+void bes2600_offchannel_work(struct work_struct *work);
+void bes2600_wep_key_work(struct work_struct *work);
+void bes2600_update_filtering(struct bes2600_vif *priv);
+void bes2600_update_filtering_work(struct work_struct *work);
+int __bes2600_flush(struct bes2600_common *hw_priv, bool drop, int if_id);
+void bes2600_set_beacon_wakeup_period_work(struct work_struct *work);
+int bes2600_enable_listening(struct bes2600_vif *priv,
+			struct ieee80211_channel *chan);
+int bes2600_disable_listening(struct bes2600_vif *priv);
+int bes2600_set_uapsd_param(struct bes2600_vif *priv,
+				const struct wsm_edca_params *arg);
+void bes2600_ba_work(struct work_struct *work);
+void bes2600_ba_timer(struct timer_list *t);
+const u8 *bes2600_get_ie(u8 *start, size_t len, u8 ie);
+int bes2600_vif_setup(struct bes2600_vif *priv);
+int bes2600_setup_mac_pvif(struct bes2600_vif *priv);
+void bes2600_iterate_vifs(void *data, u8 *mac,
+			 struct ieee80211_vif *vif);
+void bes2600_rem_chan_timeout(struct work_struct *work);
+int bes2600_set_macaddrfilter(struct bes2600_common *hw_priv, struct bes2600_vif *priv, u8 *data);
+int bes2600_wifi_start(struct bes2600_common *hw_priv);
+int bes2600_wifi_stop(struct bes2600_common *hw_priv);
+#endif /* STA_H_INCLUDED */
diff --git a/drivers/staging/bes2600/tx_loop.c b/drivers/staging/bes2600/tx_loop.c
new file mode 100755
index 000000000000..dbd5c37c6b9d
--- /dev/null
+++ b/drivers/staging/bes2600/tx_loop.c
@@ -0,0 +1,530 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include "bes2600.h"
+#include "wsm.h"
+#include "queue.h"
+
+struct tx_loop_table
+{
+        u16 cmd;
+        void (*proc)(struct bes2600_common *hw_priv, u8 *buf, u32 len);
+};
+
+static void bes2600_tx_loop_build_lmac_tx_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len);
+static void bes2600_tx_loop_build_scan_compl_ind(struct bes2600_common *hw_priv);
+static void bes2600_tx_loop_build_pm_ind(struct bes2600_common *hw_priv);
+
+void bes2600_tx_loop_init(struct bes2600_common *hw_priv)
+{
+        hw_priv->tx_loop.enabled = false;
+        hw_priv->tx_loop.start_lmac_seq = 0;
+        hw_priv->tx_loop.start_mcu_seq = 0;
+        spin_lock_init(&hw_priv->tx_loop.tx_loop_lock);
+        skb_queue_head_init(&hw_priv->tx_loop.rx_queue);
+}
+
+struct sk_buff *bes2600_tx_loop_read(struct bes2600_common *hw_priv)
+{
+        struct sk_buff *skb;
+        struct wsm_hdr *wsm;
+
+        if(hw_priv == NULL)
+                return NULL;
+
+	skb = skb_dequeue(&hw_priv->tx_loop.rx_queue);
+        if(skb != NULL) {
+                wsm = (struct wsm_hdr *)skb->data;
+                bes2600_dbg(BES2600_DBG_TXLOOP, "tx loop pipe read msg_id:0x%04x seq:%d\n",
+                                WSM_MSG_ID_GET(wsm->id), WSM_MSG_SEQ_GET(wsm->id));
+        }
+
+	return skb;
+}
+
+static void bes2600_tx_loop_item_pending_item(struct bes2600_common *hw_priv, struct sk_buff *skb)
+{
+        bes2600_info(BES2600_DBG_TXLOOP, "tx loop confirm pending skb.\n");
+        bes2600_tx_loop_build_lmac_tx_cfm(hw_priv, skb->data, skb->data_len);
+}
+
+void bes2600_tx_loop_record_wsm_cmd(struct bes2600_common *hw_priv, u8 *wsm_cmd)
+{
+        hw_priv->tx_loop.wsm_cmd_ptr = wsm_cmd;
+}
+
+void bes2600_tx_loop_clear_wsm_cmd(struct bes2600_common *hw_priv)
+{
+        hw_priv->tx_loop.wsm_cmd_ptr = NULL;
+}
+
+void bes2600_tx_loop_set_enable(struct bes2600_common *hw_priv)
+{
+        int i = 0;
+        u16 cmd_id = -1;
+
+        if(hw_priv == NULL)
+                return;
+
+        if(hw_priv->tx_loop.enabled)
+                return;
+
+        WARN_ON(1);
+        hw_priv->tx_loop.enabled = true;
+        hw_priv->tx_loop.start_lmac_seq = hw_priv->wsm_rx_seq[0];
+        hw_priv->tx_loop.start_mcu_seq = hw_priv->wsm_rx_seq[1];
+
+        if(hw_priv->tx_loop.wsm_cmd_ptr) {
+                struct wsm_hdr *tx_wsm = (struct wsm_hdr *)hw_priv->tx_loop.wsm_cmd_ptr;
+                cmd_id = tx_wsm->id & WSM_MSG_ID_MASK;
+
+                if(cmd_id == 0x0005 || cmd_id == 0x0006){
+                        struct wsm_mib *mib = (struct wsm_mib *)hw_priv->wsm_cmd.arg;
+                        u16 mib_id = mib->mibId;
+                        bes2600_info(BES2600_DBG_TXLOOP, "pending cmd:0x%04x seq:%d mib_id:0x%04x\n",
+                                                        cmd_id, WSM_MSG_SEQ_GET(tx_wsm->id), mib_id);
+                } else {
+                        bes2600_info(BES2600_DBG_TXLOOP, "pending cmd:0x%04x seq:%d\n",
+                                                        cmd_id, WSM_MSG_SEQ_GET(tx_wsm->id));
+                }
+
+                bes2600_tx_loop_pipe_send(hw_priv, hw_priv->tx_loop.wsm_cmd_ptr, 8);
+        }
+
+        if (atomic_read(&hw_priv->scan.in_progress) && cmd_id != 0x0007) {
+                bes2600_tx_loop_build_scan_compl_ind(hw_priv);
+        } else if (atomic_read(&hw_priv->bes_power.pm_set_in_process) && cmd_id != 0x0010) {
+                bes2600_tx_loop_build_pm_ind(hw_priv);
+        }
+
+        for (i = 0; i < 4; i++) {
+                bes2600_queue_iterate_pending_packet(&hw_priv->tx_queue[i],
+				                bes2600_tx_loop_item_pending_item);
+        }
+
+        if (atomic_read(&hw_priv->bh_rx) > 0)
+		wake_up(&hw_priv->bh_wq);
+
+}
+
+static void bes2600_tx_loop_build_lmac_generic_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm, *tx_wsm;
+        u32 msg_len = sizeof(struct wsm_hdr) + 4;
+        u16 msg_id = 0;
+
+        tx_wsm = (struct wsm_hdr *)buf;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= 0x400;        // set confirm flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+        *((u32 *)&rx_wsm[1]) = __cpu_to_le32(WSM_STATUS_SUCCESS);
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_lmac_tx_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_tx *tx_wsm;
+        struct wsm_tx_confirm *cfm;
+        u32 msg_len = sizeof(struct wsm_hdr) + sizeof(struct wsm_tx_confirm);
+        u16 msg_id = 0;
+
+        tx_wsm = (struct wsm_tx *)buf;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                __func__, (tx_wsm->hdr.id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id = (tx_wsm->hdr.id & WSM_MSG_ID_MASK);
+        msg_id |= 0x400;        // set confirm flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+
+        cfm = (struct wsm_tx_confirm *)&rx_wsm[1];
+        cfm->packetID = tx_wsm->packetID;
+        cfm->status = WSM_STATUS_SUCCESS;
+        cfm->txedRate = tx_wsm->maxTxRate;
+        cfm->ackFailures = 0;
+        cfm->flags = WSM_TX_STATUS_NORMAL_ACK;
+        cfm->txQueueDelay = 5;
+        cfm->mediaDelay = 3;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_config_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u32 msg_len = sizeof(struct wsm_hdr) + sizeof(struct wsm_configuration) + 4;
+        u16 msg_id = 0;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= 0x400;        // set confirm flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+        *(u32 *)&rx_wsm[1] = WSM_STATUS_SUCCESS;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_read_mib_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        struct wsm_mib *mib = (struct wsm_mib *)hw_priv->wsm_cmd.arg;
+        u32 *status;
+        u16 *mib_id, *size;
+        u32 msg_len = sizeof(struct wsm_hdr) + 4 /* status */ + 2 /* mib_id */ + mib->buf_size;
+        u16 msg_id = 0;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= 0x400;        // set confirm flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+
+        status = (u32 *)&rx_wsm[1];
+        *status = WSM_STATUS_SUCCESS;
+
+        mib_id = (u16 *)&status[1];
+        *mib_id = mib->mibId;
+
+        size = (u16 *)&mib_id[1];
+        *size = mib->buf_size;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_join_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_hdr) + 4 /* status */ + 8 /* power_level */;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= 0x400;        // set confirm flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+        *(u32 *)&rx_wsm[1] = WSM_STATUS_SUCCESS;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_rfcmd_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_mcu_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_mcu_hdr);
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                        __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_mcu_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_mcu_seq);
+        rx_wsm->hdr.id = __cpu_to_le16(msg_id);
+        rx_wsm->hdr.len = __cpu_to_le16(msg_len);
+        rx_wsm->handle_label = WSM_TO_MCU_CMD_CONFIRM_LABEL;
+        rx_wsm->cmd_type = (tx_wsm->id & WSM_MSG_ID_MASK);
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_mcu_seq = (hw_priv->tx_loop.start_mcu_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_driver_cmd_cfm(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_mcu_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_mcu_hdr) + 4;
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s cmd 0x%04x len:%d\n",
+                                        __func__, (tx_wsm->id & WSM_MSG_ID_MASK), msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_mcu_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_mcu_seq);
+        rx_wsm->hdr.id = __cpu_to_le16(msg_id);
+        rx_wsm->hdr.len = __cpu_to_le16(msg_len);
+        rx_wsm->handle_label = WSM_TO_MCU_CMD_CONFIRM_LABEL;
+        rx_wsm->cmd_type = (tx_wsm->id & WSM_MSG_ID_MASK);
+        *(uint32_t *)(rx_wsm + 1) = 0;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_mcu_seq = (hw_priv->tx_loop.start_mcu_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static struct tx_loop_table tx_loop_tbl[] = {
+        {.cmd = 0x0004, .proc = bes2600_tx_loop_build_lmac_tx_cfm},
+        {.cmd = 0x0009, .proc = bes2600_tx_loop_build_config_cfm},
+        {.cmd = 0x0005, .proc = bes2600_tx_loop_build_read_mib_cfm},
+        {.cmd = 0x0006, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x000B, .proc = bes2600_tx_loop_build_join_cfm},
+        {.cmd = 0x0007, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0008, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x000A, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x000C, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x000D, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0010, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0011, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0012, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0013, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0016, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0017, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0018, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0019, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x001A, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x001B, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x001C, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0029, .proc = bes2600_tx_loop_build_lmac_generic_cfm},
+        {.cmd = 0x0C25, .proc = bes2600_tx_loop_build_rfcmd_cfm},
+        {.cmd = 0x0C27, .proc = bes2600_tx_loop_build_driver_cmd_cfm},
+};
+
+static void bes2600_tx_loop_build_scan_compl_ind(struct bes2600_common *hw_priv)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_scan_complete *scan_compl;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_hdr) + sizeof(struct wsm_scan_complete);
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_info(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s len:%d\n", __func__, msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id |= 0x806;        // set indication flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+
+        scan_compl = (struct wsm_scan_complete *)&rx_wsm[1];
+        scan_compl->status = WSM_STATUS_SUCCESS;
+        scan_compl->psm = WSM_PSM_PS;
+        scan_compl->numChannels = 2;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_pm_ind(struct bes2600_common *hw_priv)
+{
+        struct sk_buff *out_skb;
+        struct wsm_hdr *rx_wsm;
+        struct wsm_set_pm_complete *pm_compl;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_hdr) + sizeof(struct wsm_set_pm_complete);
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_info(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s len:%d\n", __func__, msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_hdr *)out_skb->data;
+        msg_id |= 0x809;        // set indication flag
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_lmac_seq);
+        rx_wsm->id = __cpu_to_le16(msg_id);
+        rx_wsm->len = __cpu_to_le16(msg_len);
+
+        pm_compl = (struct wsm_set_pm_complete *)&rx_wsm[1];
+        pm_compl->status = WSM_STATUS_SUCCESS;
+        pm_compl->psm = WSM_PSM_PS;
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_lmac_seq = (hw_priv->tx_loop.start_lmac_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+static void bes2600_tx_loop_build_rfcmd_ind(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        struct sk_buff *out_skb;
+        struct wsm_mcu_hdr *rx_wsm;
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u16 msg_id = 0;
+        u32 msg_len = sizeof(struct wsm_mcu_hdr);
+
+        out_skb = dev_alloc_skb(msg_len);
+        if(IS_ERR_OR_NULL(out_skb)) {
+                bes2600_err(BES2600_DBG_TXLOOP, "%s, alloc mem fail.\n", __func__);
+                return;
+        }
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "%s len:%d\n",__func__, msg_len);
+        skb_put(out_skb, msg_len);
+        rx_wsm = (struct wsm_mcu_hdr *)out_skb->data;
+        msg_id = (tx_wsm->id & WSM_MSG_ID_MASK);
+        msg_id |= WSM_TX_SEQ(hw_priv->tx_loop.start_mcu_seq);
+        rx_wsm->hdr.id = __cpu_to_le16(msg_id);
+        rx_wsm->hdr.len = __cpu_to_le16(msg_len);
+        rx_wsm->handle_label = WSM_TO_MCU_CMD_INDICATION_LABEL;
+        rx_wsm->cmd_type = (tx_wsm->id & WSM_MSG_ID_MASK);
+
+        spin_lock(&hw_priv->tx_loop.tx_loop_lock);
+        hw_priv->tx_loop.start_mcu_seq = (hw_priv->tx_loop.start_mcu_seq + 1) & 7;
+        skb_queue_tail(&hw_priv->tx_loop.rx_queue, out_skb);
+        spin_unlock(&hw_priv->tx_loop.tx_loop_lock);
+
+        atomic_add_return(1, &hw_priv->bh_rx);
+}
+
+void bes2600_tx_loop_pipe_send(struct bes2600_common *hw_priv, u8 *buf, u32 len)
+{
+        int i = 0;
+        int tbl_size = ARRAY_SIZE(tx_loop_tbl);
+        struct wsm_hdr *tx_wsm = (struct wsm_hdr *)buf;
+        u16 cmd_id = tx_wsm->id & WSM_MSG_ID_MASK;
+
+        /* don't need to tx loop if wifi is unregistered */
+        if(hw_priv == NULL)
+                return;
+
+        bes2600_dbg(BES2600_DBG_TXLOOP, "tx loop pipe send cmd:0x%04x seq:%d\n",
+                                                cmd_id, WSM_MSG_SEQ_GET(tx_wsm->id));
+
+        /* select build confirm function based on command id */
+        for(i = 0; i < tbl_size; i++) {
+                if(cmd_id == tx_loop_tbl[i].cmd) {
+                        tx_loop_tbl[i].proc(hw_priv, buf, len);
+                        break;
+                }
+        }
+
+        /* build indication for special command */
+        if(cmd_id == 0x0007) {
+                bes2600_tx_loop_build_scan_compl_ind(hw_priv);
+        } else if(cmd_id == 0x0010) {
+                bes2600_tx_loop_build_pm_ind(hw_priv);
+        } else if(cmd_id == 0x0C25) {
+                bes2600_tx_loop_build_rfcmd_ind(hw_priv, buf, len);
+        }
+}
\ No newline at end of file
diff --git a/drivers/staging/bes2600/tx_loop.h b/drivers/staging/bes2600/tx_loop.h
new file mode 100755
index 000000000000..7294025d8eca
--- /dev/null
+++ b/drivers/staging/bes2600/tx_loop.h
@@ -0,0 +1,33 @@
+/*
+ * Mac80211 driver for BES2600 device
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __TX_LOOP_H__
+#define __TX_LOOP_H__
+
+#include "bes2600.h"
+
+struct bes2600_tx_loop
+{
+        bool enabled;
+        spinlock_t tx_loop_lock;
+        u8 start_lmac_seq;
+        u8 start_mcu_seq;
+        struct sk_buff_head rx_queue;
+        u8 *wsm_cmd_ptr;
+};
+
+void bes2600_tx_loop_init(struct bes2600_common *hw_priv);
+void bes2600_tx_loop_record_wsm_cmd(struct bes2600_common *hw_priv, u8 *wsm_cmd);
+void bes2600_tx_loop_clear_wsm_cmd(struct bes2600_common *hw_priv);
+struct sk_buff *bes2600_tx_loop_read(struct bes2600_common *hw_priv);
+void bes2600_tx_loop_set_enable(struct bes2600_common *hw_priv);
+void bes2600_tx_loop_pipe_send(struct bes2600_common *hw_priv, u8 *buf, u32 len);
+
+#endif
\ No newline at end of file
diff --git a/drivers/staging/bes2600/txrx.c b/drivers/staging/bes2600/txrx.c
new file mode 100755
index 000000000000..5017548895a2
--- /dev/null
+++ b/drivers/staging/bes2600/txrx.c
@@ -0,0 +1,1483 @@
+/*
+ * Datapath implementation for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <net/mac80211.h>
+#include <net/sock.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+
+#include "bes2600.h"
+#include "wsm.h"
+#include "bh.h"
+#include "ap.h"
+#include "debug.h"
+#include "sta.h"
+#include "sbus.h"
+#include "txrx_opt.h"
+
+#define BES2600_INVALID_RATE_ID (0xFF)
+
+static const struct ieee80211_rate *
+bes2600_get_tx_rate(const struct bes2600_common *hw_priv,
+		   const struct ieee80211_tx_rate *rate);
+
+/* ******************************************************************** */
+/* TX policy cache implementation					*/
+
+static void tx_policy_dump(struct tx_policy *policy)
+{
+	bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX policy] "
+		"%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X"
+		"%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X"
+		"%.1X%.1X%.1X%.1X%.1X%.1X%.1X%.1X: %d\n",
+		policy->raw[0] & 0x0F,  policy->raw[0] >> 4,
+		policy->raw[1] & 0x0F,  policy->raw[1] >> 4,
+		policy->raw[2] & 0x0F,  policy->raw[2] >> 4,
+		policy->raw[3] & 0x0F,  policy->raw[3] >> 4,
+		policy->raw[4] & 0x0F,  policy->raw[4] >> 4,
+		policy->raw[5] & 0x0F,  policy->raw[5] >> 4,
+		policy->raw[6] & 0x0F,  policy->raw[6] >> 4,
+		policy->raw[7] & 0x0F,  policy->raw[7] >> 4,
+		policy->raw[8] & 0x0F,  policy->raw[8] >> 4,
+		policy->raw[9] & 0x0F,  policy->raw[9] >> 4,
+		policy->raw[10] & 0x0F,  policy->raw[10] >> 4,
+		policy->raw[11] & 0x0F,  policy->raw[11] >> 4,
+		policy->defined);
+}
+
+static void bes2600_check_go_neg_conf_success(struct bes2600_common *hw_priv,
+						u8 *action)
+{
+	if (action[2] == 0x50 && action[3] == 0x6F && action[4] == 0x9A &&
+		action[5] == 0x09 && action[6] == 0x02) {
+		if(action[17] == 0) {
+			hw_priv->is_go_thru_go_neg = true;
+		}
+		else {
+			hw_priv->is_go_thru_go_neg = false;
+		}
+	}
+}
+
+static void bes2600_check_prov_desc_req(struct bes2600_common *hw_priv,
+                                                u8 *action)
+{
+	if (action[2] == 0x50 && action[3] == 0x6F && action[4] == 0x9A &&
+                action[5] == 0x09 && action[6] == 0x07) {
+                        hw_priv->is_go_thru_go_neg = false;
+        }
+}
+
+static void tx_policy_build(const struct bes2600_common *hw_priv,
+	/* [out] */ struct tx_policy *policy,
+	struct ieee80211_tx_rate *rates, size_t count)
+{
+	int i, j;
+	unsigned limit = hw_priv->short_frame_max_tx_count;
+	unsigned total = 0;
+	static int tx_rate_idx;
+
+	BUG_ON(rates[0].idx < 0);
+	memset(policy, 0, sizeof(*policy));
+
+	/* minstrel is buggy a little bit, so distille
+	 * incoming rates first. */
+	/* Sort rates in descending order. */
+	for (i = 0; i < count; i++) {
+		if (rates[i].idx < 0) {
+			count = i;
+			break;
+		}
+		for (j= 0; j < count; j++) {
+			if (rates[j].idx < 0) {
+				continue;
+			}
+
+			if (rates[j].idx < rates[j + 1].idx) {
+				struct ieee80211_tx_rate tmp = rates[j];
+				rates[j] = rates[j + 1];
+				rates[j + 1] = tmp;
+			}
+		}
+	}
+	/* enhance throughput, more tx retry rate */
+	if (rates[0].flags & IEEE80211_TX_RC_MCS) {
+		static int min_rate_index = 1; //min rate index  is mcs1
+		static u8 last_rate_tx_cnt = 7;
+
+		count = IEEE80211_TX_MAX_RATES;
+		/* if idx < min rate index, set min rate index */
+		rates[0].count = 6;
+		if (rates[0].idx <= min_rate_index) {
+			rates[0].idx = min_rate_index;
+		}
+
+		for (i = 1; i < count; ++i) {
+			/* only one rate try 2 times*/
+			if (rates[i].count > 6)
+				rates[i].count = 6;
+			if (rates[i - 1].idx > min_rate_index) {
+				rates[i].idx = (rates[i - 1].idx - 1);
+				rates[i].count = 6;
+				rates[i].flags = rates[i - 1].flags;
+			} else if (rates[i - 1].idx <= min_rate_index) {
+				rates[i].idx = -1;
+				rates[i].count = 0;
+				rates[i].flags = 0;
+				break;
+			}
+		}
+		/* update the last  rate index  tx cnt */
+		rates[i - 1].count = last_rate_tx_cnt;
+		count = i;
+	}
+	/* Eliminate duplicates. */
+	total = rates[0].count;
+	for (i = 0, j = 1; j < count; ++j) {
+		if (rates[j].idx == rates[i].idx) {
+			rates[i].count += rates[j].count;
+		} else if (rates[j].idx > rates[i].idx) {
+			break;
+		} else {
+			++i;
+			if (i != j)
+				rates[i] = rates[j];
+		}
+		total += rates[j].count;
+	}
+	count = i + 1;
+
+	/* Re-fill policy trying to keep every requested rate and with
+	 * respect to the global max tx retransmission count. */
+	if (limit < count)
+		limit = count;
+	if (total > limit) {
+		for (i = 0; i < count; ++i) {
+			int left = count - i - 1;
+			if (rates[i].count > limit - left)
+				rates[i].count = limit - left;
+			limit -= rates[i].count;
+		}
+	}
+
+	/* HACK!!! Device has problems (at least) switching from
+	 * 54Mbps CTS to 1Mbps. This switch takes enormous amount
+	 * of time (100-200 ms), leading to valuable throughput drop.
+	 * As a workaround, additional g-rates are injected to the
+	 * policy.
+	 */
+	if (count == 2 && !(rates[0].flags & IEEE80211_TX_RC_MCS) &&
+			rates[0].idx > 4 && rates[0].count > 2 &&
+			rates[1].idx < 2) {
+		/* ">> 1" is an equivalent of "/ 2", but faster */
+		int mid_rate = (rates[0].idx + 4) >> 1;
+
+		/* Decrease number of retries for the initial rate */
+		rates[0].count -= 2;
+
+		if (mid_rate != 4) {
+			/* Keep fallback rate at 1Mbps. */
+			rates[3] = rates[1];
+
+			/* Inject 1 transmission on lowest g-rate */
+			rates[2].idx = 4;
+			rates[2].count = 1;
+			rates[2].flags = rates[1].flags;
+
+			/* Inject 1 transmission on mid-rate */
+			rates[1].idx = mid_rate;
+			rates[1].count = 1;
+
+			/* Fallback to 1 Mbps is a really bad thing,
+			 * so let's try to increase probability of
+			 * successful transmission on the lowest g rate
+			 * even more */
+			if (rates[0].count >= 3) {
+				--rates[0].count;
+				++rates[2].count;
+			}
+
+			/* Adjust amount of rates defined */
+			count += 2;
+		} else {
+			/* Keep fallback rate at 1Mbps. */
+			rates[2] = rates[1];
+
+			/* Inject 2 transmissions on lowest g-rate */
+			rates[1].idx = 4;
+			rates[1].count = 2;
+
+			/* Adjust amount of rates defined */
+			count += 1;
+		}
+	}
+
+	policy->defined = bes2600_get_tx_rate(hw_priv, &rates[0])->hw_value + 1;
+	if (rates[0].flags & IEEE80211_TX_RC_MCS) {
+		int low_rate_idx = 0;  /* set default 11b 1M */
+		int low_rate_count = 1;
+		register unsigned rateid, off, shift, retries;
+		/* if the mcs < mcs3, more retry 2 times with low rate. */
+		if (rates[0].idx < 3) {
+			low_rate_count += 2;
+		}
+		/* if the tx rate is mcs0, more retry 2 times with low rate.
+		 * sample tx rate count is 1 in the minstrel_ht_set_rate.*/
+		if (rates[0].idx == 0 || (rates[1].idx == 0 && rates[0].count == 1)) {
+			low_rate_count += 2;
+			/* smaple and mcs0 tx rate count set 2. */
+			for (i = 0; i < count; i++) {
+				rates[0].count = (i + 1);
+			}
+		}
+		if (hw_priv->channel != NULL && hw_priv->channel->hw_value > 14)
+			low_rate_idx = 6;  /* set default 11a 6M */
+
+		rateid = low_rate_idx;
+		off = rateid >> 3;      /* eq. rateid / 8 */
+		shift = (rateid & 0x07) << 2;   /* eq. (rateid % 8) * 4 */
+		retries = low_rate_count;
+		policy->tbl[off] |= __cpu_to_le32(retries << shift);
+		policy->retry_count += retries;
+	}
+
+	for (i = 0; i < count; ++i) {
+		register unsigned rateid, off, shift, retries;
+
+		rateid = bes2600_get_tx_rate(hw_priv, &rates[i])->hw_value;
+		off = rateid >> 3;		/* eq. rateid / 8 */
+		shift = (rateid & 0x07) << 2;	/* eq. (rateid % 8) * 4 */
+
+		retries = rates[i].count;
+		if (unlikely(retries > 0x0F))
+			rates[i].count = retries = 0x0F;
+		policy->tbl[off] |= __cpu_to_le32(retries << shift);
+		policy->retry_count += retries;
+	}
+
+
+	if (rates[0].idx !=  tx_rate_idx) {
+		tx_rate_idx = rates[0].idx;
+		bes2600_dbg(BES2600_DBG_TXRX_OPT, "[TX policy] Policy (%lu): " \
+			    "%d:%d, %d:%d, %d:%d, %d:%d, %d:%d\n",
+			    (long unsigned)count,
+			    rates[0].idx, rates[0].count,
+			    rates[1].idx, rates[1].count,
+			    rates[2].idx, rates[2].count,
+			    rates[3].idx, rates[3].count,
+			    rates[4].idx, rates[4].count);
+	}
+}
+
+static inline bool tx_policy_is_equal(const struct tx_policy *wanted,
+					const struct tx_policy *cached)
+{
+	size_t count = wanted->defined >> 1;
+	if (wanted->defined > cached->defined)
+		return false;
+	if (count) {
+		if (memcmp(wanted->raw, cached->raw, count))
+			return false;
+	}
+	if (wanted->defined & 1) {
+		if ((wanted->raw[count] & 0x0F) != (cached->raw[count] & 0x0F))
+			return false;
+	}
+	return true;
+}
+
+static int tx_policy_find(struct tx_policy_cache *cache,
+				const struct tx_policy *wanted)
+{
+	/* O(n) complexity. Not so good, but there's only 8 entries in
+	 * the cache.
+	 * Also lru helps to reduce search time. */
+	struct tx_policy_cache_entry *it;
+	/* Search for policy in "used" list */
+	list_for_each_entry(it, &cache->used, link) {
+		if (tx_policy_is_equal(wanted, &it->policy))
+			return it - cache->cache;
+	}
+	/* Then - in "free list" */
+	list_for_each_entry(it, &cache->free, link) {
+		if (tx_policy_is_equal(wanted, &it->policy))
+			return it - cache->cache;
+	}
+	return -1;
+}
+
+static inline void tx_policy_use(struct tx_policy_cache *cache,
+				 struct tx_policy_cache_entry *entry)
+{
+	++entry->policy.usage_count;
+	list_move(&entry->link, &cache->used);
+}
+
+static inline int tx_policy_release(struct tx_policy_cache *cache,
+				    struct tx_policy_cache_entry *entry)
+{
+	int ret = --entry->policy.usage_count;
+	if (!ret)
+		list_move(&entry->link, &cache->free);
+	return ret;
+}
+
+/* ******************************************************************** */
+/* External TX policy cache API						*/
+
+void tx_policy_init(struct bes2600_common *hw_priv)
+{
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	int i;
+
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "tx_policy_init\n\r");
+
+	memset(cache, 0, sizeof(*cache));
+
+	spin_lock_init(&cache->lock);
+	INIT_LIST_HEAD(&cache->used);
+	INIT_LIST_HEAD(&cache->free);
+
+	for (i = 0; i < TX_POLICY_CACHE_SIZE; ++i)
+		list_add(&cache->cache[i].link, &cache->free);
+}
+
+void tx_policy_deinit(struct bes2600_common *hw_priv)
+{
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "tx_policy_deinit\n\r");
+}
+
+static int tx_policy_get(struct bes2600_common *hw_priv,
+		  struct ieee80211_tx_rate *rates,
+		  size_t count, bool *renew)
+{
+	int idx;
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	struct tx_policy wanted;
+
+	tx_policy_build(hw_priv, &wanted, rates, count);
+
+	spin_lock_bh(&cache->lock);
+	if (WARN_ON_ONCE(list_empty(&cache->free))) {
+		spin_unlock_bh(&cache->lock);
+		return BES2600_INVALID_RATE_ID;
+	}
+	idx = tx_policy_find(cache, &wanted);
+	if (idx >= 0) {
+		bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX policy] Used TX policy: %d\n",
+					idx);
+		*renew = false;
+	} else {
+		struct tx_policy_cache_entry *entry;
+		*renew = true;
+		/* If policy is not found create a new one
+		 * using the oldest entry in "free" list */
+		entry = list_entry(cache->free.prev,
+			struct tx_policy_cache_entry, link);
+		entry->policy = wanted;
+		idx = entry - cache->cache;
+		bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX policy] New TX policy: %d\n",
+					idx);
+		tx_policy_dump(&entry->policy);
+	}
+	tx_policy_use(cache, &cache->cache[idx]);
+	if (unlikely(list_empty(&cache->free))) {
+		/* Lock TX queues. */
+		bes2600_tx_queues_lock(hw_priv);
+	}
+	spin_unlock_bh(&cache->lock);
+	return idx;
+}
+
+static void tx_policy_put(struct bes2600_common *hw_priv, int idx)
+{
+	int usage, locked;
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+
+	spin_lock_bh(&cache->lock);
+	locked = list_empty(&cache->free);
+	usage = tx_policy_release(cache, &cache->cache[idx]);
+	if (unlikely(locked) && !usage) {
+		/* Unlock TX queues. */
+		bes2600_tx_queues_unlock(hw_priv);
+	}
+	spin_unlock_bh(&cache->lock);
+}
+
+/*
+bool tx_policy_cache_full(struct bes2600_common *hw_priv)
+{
+	bool ret;
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	spin_lock_bh(&cache->lock);
+	ret = list_empty(&cache->free);
+	spin_unlock_bh(&cache->lock);
+	return ret;
+}
+*/
+
+static int tx_policy_upload(struct bes2600_common *hw_priv)
+{
+	struct tx_policy_cache *cache = &hw_priv->tx_policy_cache;
+	int i;
+	struct wsm_set_tx_rate_retry_policy arg = {
+		.hdr = {
+			.numTxRatePolicies = 0,
+		}
+	};
+	int if_id = 0;
+	spin_lock_bh(&cache->lock);
+
+	/* Upload only modified entries. */
+	for (i = 0; i < TX_POLICY_CACHE_SIZE; ++i) {
+		struct tx_policy *src = &cache->cache[i].policy;
+		if (src->retry_count && !src->uploaded) {
+			struct wsm_set_tx_rate_retry_policy_policy *dst =
+				&arg.tbl[arg.hdr.numTxRatePolicies];
+			dst->policyIndex = i;
+			dst->shortRetryCount =
+				hw_priv->short_frame_max_tx_count;
+			dst->longRetryCount = hw_priv->long_frame_max_tx_count;
+
+			/* BIT(2) - Terminate retries when Tx rate retry policy
+			 *          finishes.
+			 * BIT(3) - Count initial frame transmission as part of
+			 *          rate retry counting but not as a retry
+			 *          attempt */
+			dst->policyFlags = BIT(2) | BIT(3);
+
+			memcpy(dst->rateCountIndices, src->tbl,
+					sizeof(dst->rateCountIndices));
+			src->uploaded = 1;
+			++arg.hdr.numTxRatePolicies;
+		}
+	}
+	spin_unlock_bh(&cache->lock);
+	//bes2600_debug_tx_cache_miss(hw_priv);
+	bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX policy] Upload %d policies\n",
+				arg.hdr.numTxRatePolicies);
+	/*TODO: COMBO*/
+	return wsm_set_tx_rate_retry_policy(hw_priv, &arg, if_id);
+}
+
+void tx_policy_upload_work(struct work_struct *work)
+{
+	struct bes2600_common *hw_priv =
+		container_of(work, struct bes2600_common, tx_policy_upload_work);
+
+	bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX] TX policy upload.\n");
+	WARN_ON(tx_policy_upload(hw_priv));
+
+	wsm_unlock_tx(hw_priv);
+	bes2600_tx_queues_unlock(hw_priv);
+}
+
+/* ******************************************************************** */
+/* bes2600 TX implementation						*/
+
+struct bes2600_txinfo {
+	struct sk_buff *skb;
+	unsigned queue;
+	struct ieee80211_tx_info *tx_info;
+	const struct ieee80211_rate *rate;
+	struct ieee80211_hdr *hdr;
+	size_t hdrlen;
+	const u8 *da;
+	struct bes2600_sta_priv *sta_priv;
+	struct ieee80211_sta *sta;
+	struct bes2600_txpriv txpriv;
+};
+
+u32 bes2600_rate_mask_to_wsm(struct bes2600_common *hw_priv, u32 rates)
+{
+	u32 ret = 0;
+	int i;
+	struct ieee80211_rate * bitrates =
+		hw_priv->hw->wiphy->bands[hw_priv->channel->band]->bitrates;
+	for (i = 0; i < 32; ++i) {
+		if (rates & BIT(i))
+			ret |= BIT(bitrates[i].hw_value);
+	}
+	return ret;
+}
+
+static const struct ieee80211_rate *
+bes2600_get_tx_rate(const struct bes2600_common *hw_priv,
+		   const struct ieee80211_tx_rate *rate)
+{
+	if (rate->idx < 0)
+		return NULL;
+	if (rate->flags & IEEE80211_TX_RC_MCS)
+		return &hw_priv->mcs_rates[rate->idx];
+	return &hw_priv->hw->wiphy->bands[hw_priv->channel->band]->
+		bitrates[rate->idx];
+}
+
+static int
+bes2600_tx_h_calc_link_ids(struct bes2600_vif *priv,
+			  struct bes2600_txinfo *t)
+{
+	if (likely(t->sta && t->sta_priv->link_id))
+		t->txpriv.raw_link_id =
+				t->txpriv.link_id =
+				t->sta_priv->link_id;
+	else if (priv->mode != NL80211_IFTYPE_AP)
+		t->txpriv.raw_link_id =
+				t->txpriv.link_id = 0;
+	else if (is_multicast_ether_addr(t->da)) {
+		if (priv->enable_beacon) {
+			t->txpriv.raw_link_id = 0;
+			t->txpriv.link_id = priv->link_id_after_dtim;
+		} else {
+			t->txpriv.raw_link_id = 0;
+			t->txpriv.link_id = 0;
+		}
+	} else {
+		t->txpriv.link_id =
+			bes2600_find_link_id(priv, t->da);
+		/* Do not assign valid link id for deauth/disassoc frame being
+		transmitted to an unassociated STA */
+		if (!(t->txpriv.link_id) &&
+			(ieee80211_is_deauth(t->hdr->frame_control) ||
+			ieee80211_is_disassoc(t->hdr->frame_control))) {
+					t->txpriv.link_id = 0;
+		} else {
+			if (!t->txpriv.link_id)
+				t->txpriv.link_id = bes2600_alloc_link_id(priv, t->da);
+			if (!t->txpriv.link_id) {
+				wiphy_err(priv->hw->wiphy,
+					"%s: No more link IDs available.\n",
+					__func__);
+				return -ENOENT;
+			}
+		}
+		t->txpriv.raw_link_id = t->txpriv.link_id;
+	}
+	if (t->txpriv.raw_link_id)
+		priv->link_id_db[t->txpriv.raw_link_id - 1].timestamp =
+				jiffies;
+
+	return 0;
+}
+
+static void
+bes2600_tx_h_pm(struct bes2600_vif *priv,
+	       struct bes2600_txinfo *t)
+{
+	if (unlikely(ieee80211_is_auth(t->hdr->frame_control))) {
+		u32 mask = ~BIT(t->txpriv.raw_link_id);
+		spin_lock_bh(&priv->ps_state_lock);
+		priv->sta_asleep_mask &= mask;
+		priv->pspoll_mask &= mask;
+		spin_unlock_bh(&priv->ps_state_lock);
+	}
+}
+
+static void
+bes2600_tx_h_calc_tid(struct bes2600_vif *priv,
+		     struct bes2600_txinfo *t)
+{
+	if (ieee80211_is_data_qos(t->hdr->frame_control)) {
+		u8 *qos = ieee80211_get_qos_ctl(t->hdr);
+		t->txpriv.tid = qos[0] & IEEE80211_QOS_CTL_TID_MASK;
+	} else if (ieee80211_is_data(t->hdr->frame_control)) {
+		t->txpriv.tid = 0;
+	}
+}
+
+static int
+bes2600_tx_h_crypt(struct bes2600_vif *priv,
+		  struct bes2600_txinfo *t)
+{
+	if (!t->tx_info->control.hw_key ||
+		!ieee80211_has_protected(t->hdr->frame_control) ||
+		(ieee80211_is_mgmt(t->hdr->frame_control) &&
+		t->tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_SMS4))
+		return 0;
+
+	t->hdrlen += t->tx_info->control.hw_key->iv_len;
+	skb_put(t->skb, t->tx_info->control.hw_key->icv_len);
+
+	if (t->tx_info->control.hw_key->cipher == WLAN_CIPHER_SUITE_TKIP)
+		skb_put(t->skb, 8); /* MIC space */
+
+	return 0;
+}
+
+static int
+bes2600_tx_h_align(struct bes2600_vif *priv,
+		  struct bes2600_txinfo *t,
+		  u8 *flags)
+{
+	size_t offset = (size_t)t->skb->data & 3;
+
+	if (!offset)
+		return 0;
+
+	if (offset & 1) {
+		wiphy_err(priv->hw->wiphy,
+			"Bug: attempt to transmit a frame "
+			"with wrong alignment: %ld\n",
+			(long)offset);
+		return -EINVAL;
+	}
+
+	if (skb_headroom(t->skb) < offset) {
+		wiphy_err(priv->hw->wiphy,
+			"Bug: no space allocated "
+			"for DMA alignment.\n"
+			"headroom: %d\n",
+			skb_headroom(t->skb));
+		return -ENOMEM;
+	}
+	skb_push(t->skb, offset);
+	t->hdrlen += offset;
+	t->txpriv.offset += offset;
+	*flags |= WSM_TX_2BYTES_SHIFT;
+	bes2600_debug_tx_align(priv);
+	return 0;
+}
+
+static int
+bes2600_tx_h_action(struct bes2600_vif *priv,
+		   struct bes2600_txinfo *t)
+{
+	struct ieee80211_mgmt *mgmt =
+		(struct ieee80211_mgmt *)t->hdr;
+
+	if (ieee80211_is_action(t->hdr->frame_control) &&
+			mgmt->u.action.category == WLAN_CATEGORY_BACK)
+		return 1;
+	else
+		return 0;
+}
+
+/* Add WSM header */
+static struct wsm_tx *
+bes2600_tx_h_wsm(struct bes2600_vif *priv,
+		struct bes2600_txinfo *t)
+{
+	struct wsm_tx *wsm;
+
+	if (skb_headroom(t->skb) < sizeof(struct wsm_tx)) {
+		wiphy_err(priv->hw->wiphy,
+			"Bug: no space allocated "
+			"for WSM header.\n"
+			"headroom: %d\n",
+			skb_headroom(t->skb));
+		return NULL;
+	}
+
+	wsm = (struct wsm_tx *)skb_push(t->skb, sizeof(struct wsm_tx));
+	t->txpriv.offset += sizeof(struct wsm_tx);
+	memset(wsm, 0, sizeof(*wsm));
+	wsm->hdr.len = __cpu_to_le16(t->skb->len);
+	wsm->hdr.id = __cpu_to_le16(0x0004);
+	wsm->queueId =
+		(t->txpriv.raw_link_id << 2) | wsm_queue_id_to_wsm(t->queue);
+	return wsm;
+}
+
+/* BT Coex specific handling */
+static void
+bes2600_tx_h_bt(struct bes2600_vif *priv,
+	       struct bes2600_txinfo *t,
+	       struct wsm_tx *wsm)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	u8 priority = 0;
+
+	if (!hw_priv->is_BT_Present)
+		return;
+
+	if (unlikely(ieee80211_is_nullfunc(t->hdr->frame_control)))
+		priority = WSM_EPTA_PRIORITY_MGT;
+	else if (ieee80211_is_data(t->hdr->frame_control)) {
+		/* Skip LLC SNAP header (+6) */
+		u8 *payload = &t->skb->data[t->hdrlen];
+		u16 *ethertype = (u16 *) &payload[6];
+		if (unlikely(*ethertype == __be16_to_cpu(ETH_P_PAE)))
+			priority = WSM_EPTA_PRIORITY_EAPOL;
+	} else if (unlikely(ieee80211_is_assoc_req(t->hdr->frame_control) ||
+		ieee80211_is_reassoc_req(t->hdr->frame_control))) {
+		struct ieee80211_mgmt *mgt_frame =
+				(struct ieee80211_mgmt *)t->hdr;
+
+		if (mgt_frame->u.assoc_req.listen_interval <
+						priv->listen_interval) {
+			bes2600_dbg(BES2600_DBG_TX_POLICY,
+				"Modified Listen Interval to %d from %d\n",
+				priv->listen_interval,
+				mgt_frame->u.assoc_req.listen_interval);
+			/* Replace listen interval derieved from
+			 * the one read from SDD */
+			mgt_frame->u.assoc_req.listen_interval =
+				priv->listen_interval;
+		}
+	}
+
+	if (likely(!priority)) {
+		if (ieee80211_is_action(t->hdr->frame_control))
+			priority = WSM_EPTA_PRIORITY_ACTION;
+		else if (ieee80211_is_mgmt(t->hdr->frame_control))
+			priority = WSM_EPTA_PRIORITY_MGT;
+		else if (wsm->queueId == WSM_QUEUE_VOICE)
+			priority = WSM_EPTA_PRIORITY_VOICE;
+		else if (wsm->queueId == WSM_QUEUE_VIDEO)
+			priority = WSM_EPTA_PRIORITY_VIDEO;
+		else
+			priority = WSM_EPTA_PRIORITY_DATA;
+	}
+
+	bes2600_dbg(BES2600_DBG_TXRX, "[TX] EPTA priority %d.\n",
+		priority);
+
+	wsm->flags |= priority << 1;
+}
+
+static int
+bes2600_tx_h_rate_policy(struct bes2600_common *hw_priv,
+			struct bes2600_txinfo *t,
+			struct wsm_tx *wsm)
+{
+	bool tx_policy_renew = false;
+	struct bes2600_vif *priv =
+				cw12xx_get_vif_from_ieee80211(t->tx_info->control.vif);
+
+	t->txpriv.rate_id = tx_policy_get(hw_priv,
+		t->tx_info->control.rates, IEEE80211_TX_MAX_RATES,
+		&tx_policy_renew);
+	if (t->txpriv.rate_id == BES2600_INVALID_RATE_ID)
+		return -EFAULT;
+
+	wsm->flags |= t->txpriv.rate_id << 4;
+
+	t->rate = bes2600_get_tx_rate(hw_priv,
+		&t->tx_info->control.rates[0]),
+	wsm->maxTxRate = t->rate->hw_value;
+	priv->hw_value = wsm->maxTxRate;
+	if (t->rate->flags & IEEE80211_TX_RC_MCS) {
+		if (priv->association_mode.greenfieldMode)
+			wsm->htTxParameters |=
+				__cpu_to_le32(WSM_HT_TX_GREENFIELD);
+		else
+			wsm->htTxParameters |=
+				__cpu_to_le32(WSM_HT_TX_MIXED);
+	}
+
+	if (tx_policy_renew) {
+		bes2600_dbg(BES2600_DBG_TX_POLICY, "[TX] TX policy renew.\n");
+		/* It's not so optimal to stop TX queues every now and then.
+		 * Maybe it's better to reimplement task scheduling with
+		 * a counter. */
+		/* bes2600_tx_queues_lock(priv); */
+		/* Definetly better. TODO. */
+		wsm_lock_tx_async(hw_priv);
+		bes2600_tx_queues_lock(hw_priv);
+		if (queue_work(hw_priv->workqueue,
+				&hw_priv->tx_policy_upload_work) <= 0) {
+			bes2600_tx_queues_unlock(hw_priv);
+			wsm_unlock_tx(hw_priv);
+		}
+	}
+	return 0;
+}
+
+static bool
+bes2600_tx_h_pm_state(struct bes2600_vif *priv,
+		     struct bes2600_txinfo *t)
+{
+	int was_buffered = 1;
+
+	if (t->txpriv.link_id == priv->link_id_after_dtim &&
+			!priv->buffered_multicasts) {
+		priv->buffered_multicasts = true;
+		if (priv->sta_asleep_mask)
+			queue_work(priv->hw_priv->workqueue,
+				&priv->multicast_start_work);
+	}
+
+	if (t->txpriv.raw_link_id && t->txpriv.tid < BES2600_MAX_TID)
+		was_buffered = priv->link_id_db[t->txpriv.raw_link_id - 1]
+				.buffered[t->txpriv.tid]++;
+
+	return !was_buffered;
+}
+
+static void
+bes2600_tx_h_ba_stat(struct bes2600_vif *priv,
+		    struct bes2600_txinfo *t)
+{
+	struct bes2600_common *hw_priv = priv->hw_priv;
+
+	if (priv->join_status != BES2600_JOIN_STATUS_STA)
+		return;
+	if (!bes2600_is_ht(&hw_priv->ht_info))
+		return;
+	if (!priv->setbssparams_done)
+		return;
+	if (!ieee80211_is_data(t->hdr->frame_control))
+		return;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	hw_priv->ba_acc += t->skb->len - t->hdrlen;
+	if (!(hw_priv->ba_cnt_rx || hw_priv->ba_cnt)) {
+		mod_timer(&hw_priv->ba_timer,
+			jiffies + BES2600_BLOCK_ACK_INTERVAL);
+	}
+	hw_priv->ba_cnt++;
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+static int
+bes2600_tx_h_skb_pad(struct bes2600_common *priv,
+		    struct wsm_tx *wsm,
+		    struct sk_buff *skb)
+{
+	size_t len = __le16_to_cpu(wsm->hdr.len);
+	size_t padded_len = priv->sbus_ops->align_size(priv->sbus_priv, len);
+
+	if (WARN_ON(skb_padto(skb, padded_len) != 0)) {
+		return -EINVAL;
+	}
+	return 0;
+}
+
+/* ******************************************************************** */
+
+void bes2600_tx(struct ieee80211_hw *dev,
+			struct ieee80211_tx_control *control,
+			struct sk_buff *skb)
+{
+	struct bes2600_common *hw_priv = dev->priv;
+	struct bes2600_txinfo t = {
+		.skb = skb,
+		.queue = skb_get_queue_mapping(skb),
+		.tx_info = IEEE80211_SKB_CB(skb),
+		.hdr = (struct ieee80211_hdr *)skb->data,
+		.txpriv.tid = BES2600_MAX_TID,
+		.txpriv.rate_id = BES2600_INVALID_RATE_ID,
+		.txpriv.raw_if_id = 0,
+	};
+	struct ieee80211_sta *sta;
+	struct wsm_tx *wsm;
+	bool tid_update = 0;
+	u8 flags = 0;
+	int ret;
+	struct bes2600_vif *priv;
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;
+        struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+
+	if (!skb->data)
+		BUG_ON(1);
+
+	if (!(t.tx_info->control.vif)) {
+	        goto drop;
+	}
+	priv = cw12xx_get_vif_from_ieee80211(t.tx_info->control.vif);
+	if (!priv)
+		goto drop;
+
+	if (atomic_read(&priv->enabled) == 0)
+		goto drop;
+
+	/* wake up device if device is in low power mode */
+	bes2600_pwr_set_busy_event_with_timeout_async(
+		hw_priv, BES_PWR_LOCK_ON_TX, BES_PWR_EVENT_TX_TIMEOUT);
+
+	if ((ieee80211_is_action(frame->frame_control))
+			&& (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {
+		u8 *action = (u8*)&mgmt->u.action.category;
+		bes2600_check_go_neg_conf_success(hw_priv, action);
+		bes2600_check_prov_desc_req(hw_priv, action);
+	}
+
+	t.txpriv.if_id = priv->if_id;
+	t.hdrlen = ieee80211_hdrlen(t.hdr->frame_control);
+	t.da = ieee80211_get_DA(t.hdr);
+	if (control) {
+		t.sta = control->sta;
+		t.sta_priv = (struct bes2600_sta_priv *)&t.sta->drv_priv;
+	}
+
+	if (WARN_ON(t.queue >= 4))
+		goto drop;
+
+	ret = bes2600_tx_h_calc_link_ids(priv, &t);
+	if (ret)
+		goto drop;
+
+	bes2600_dbg(BES2600_DBG_TXRX, "[TX] TX %d bytes (if_id: %d,"
+			" queue: %d, link_id: %d (%d)).\n",
+			skb->len, priv->if_id, t.queue, t.txpriv.link_id,
+			t.txpriv.raw_link_id);
+
+	bes2600_tx_h_pm(priv, &t);
+	bes2600_tx_h_calc_tid(priv, &t);
+	ret = bes2600_tx_h_crypt(priv, &t);
+	if (ret)
+		goto drop;
+	ret = bes2600_tx_h_align(priv, &t, &flags);
+	if (ret)
+		goto drop;
+	ret = bes2600_tx_h_action(priv, &t);
+	if (ret)
+		goto drop;
+	wsm = bes2600_tx_h_wsm(priv, &t);
+	if (!wsm) {
+		ret = -ENOMEM;
+		goto drop;
+	}
+	wsm->flags |= flags;
+	bes2600_tx_h_bt(priv, &t, wsm);
+	ret = bes2600_tx_h_rate_policy(hw_priv, &t, wsm);
+	if (ret)
+		goto drop;
+
+	ret = bes2600_tx_h_skb_pad(hw_priv, wsm, skb);
+	if (ret)
+		goto drop;
+	rcu_read_lock();
+	sta = rcu_dereference(t.sta);
+
+	bes2600_tx_h_ba_stat(priv, &t);
+
+	spin_lock_bh(&priv->ps_state_lock);
+	{
+		tid_update = bes2600_tx_h_pm_state(priv, &t);
+		BUG_ON(bes2600_queue_put(&hw_priv->tx_queue[t.queue],
+				t.skb, &t.txpriv));
+
+		if (skb->sk)
+			sk_pacing_shift_update(skb->sk, 7);
+
+		bes2600_dbg(BES2600_DBG_ROC, "QPUT %x, %pM, if_id - %d\n",
+			t.hdr->frame_control, t.da, priv->if_id);
+	}
+	spin_unlock_bh(&priv->ps_state_lock);
+
+	rcu_read_unlock();
+
+	bes2600_bh_wakeup(hw_priv);
+
+	return;
+
+drop:
+	bes2600_skb_dtor(hw_priv, skb, &t.txpriv);
+	return;
+}
+
+/* ******************************************************************** */
+
+static int bes2600_handle_pspoll(struct bes2600_vif *priv,
+				struct sk_buff *skb)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct ieee80211_sta *sta;
+	struct ieee80211_pspoll *pspoll =
+		(struct ieee80211_pspoll *) skb->data;
+	int link_id = 0;
+	u32 pspoll_mask = 0;
+	int drop = 1;
+	int i;
+
+	if (priv->join_status != BES2600_JOIN_STATUS_AP)
+		goto done;
+	if (memcmp(priv->vif->addr, pspoll->bssid, ETH_ALEN))
+		goto done;
+
+	rcu_read_lock();
+	sta = ieee80211_find_sta(priv->vif, pspoll->ta);
+	if (sta) {
+		struct bes2600_sta_priv *sta_priv;
+		sta_priv = (struct bes2600_sta_priv *)&sta->drv_priv;
+		link_id = sta_priv->link_id;
+		pspoll_mask = BIT(sta_priv->link_id);
+	}
+	rcu_read_unlock();
+	if (!link_id)
+		goto done;
+
+	priv->pspoll_mask |= pspoll_mask;
+	drop = 0;
+
+	/* Do not report pspols if data for given link id is
+	 * queued already. */
+	for (i = 0; i < 4; ++i) {
+		if (bes2600_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[i],
+				pspoll_mask)) {
+			bes2600_bh_wakeup(hw_priv);
+			drop = 1;
+			break;
+		}
+	}
+	bes2600_info(BES2600_DBG_TXRX, "[RX] PSPOLL: %s\n", drop ? "local" : "fwd");
+done:
+	return drop;
+}
+
+/* ******************************************************************** */
+
+void bes2600_tx_confirm_cb(struct bes2600_common *hw_priv,
+			  struct wsm_tx_confirm *arg)
+{
+	u8 queue_id = bes2600_queue_get_queue_id(arg->packetID);
+	struct bes2600_queue *queue = &hw_priv->tx_queue[queue_id];
+	struct sk_buff *skb;
+	const struct bes2600_txpriv *txpriv;
+	struct bes2600_vif *priv;
+
+	bes2600_dbg(BES2600_DBG_TXRX, "[TX] TX confirm: %d, %d.\n",
+		arg->status, arg->ackFailures);
+
+	if (unlikely(bes2600_itp_tx_running(hw_priv)))
+		return;
+
+	priv = cw12xx_hwpriv_to_vifpriv(hw_priv, arg->if_id);
+	if (unlikely(!priv))
+		return;
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+
+	if (WARN_ON(queue_id >= 4)) {
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+
+	if (arg->status)
+		bes2600_dbg(BES2600_DBG_TXRX, "TX failed: %d.\n",
+				arg->status);
+
+	if ((arg->status == WSM_REQUEUE) &&
+	    (arg->flags & WSM_TX_STATUS_REQUEUE)) {
+		/* "Requeue" means "implicit suspend" */
+		struct wsm_suspend_resume suspend = {
+			.link_id = arg->link_id,
+			.stop = 1,
+			.multicast = !arg->link_id,
+			.if_id = arg->if_id,
+		};
+		bes2600_suspend_resume(priv, &suspend);
+		wiphy_warn(priv->hw->wiphy, "Requeue for link_id %d (try %d)."
+			" STAs asleep: 0x%.8X\n",
+			arg->link_id,
+			bes2600_queue_get_generation(arg->packetID) + 1,
+			priv->sta_asleep_mask);
+		WARN_ON(bes2600_queue_requeue(queue,
+				arg->packetID, true));
+		spin_lock_bh(&priv->ps_state_lock);
+		if (!arg->link_id) {
+			priv->buffered_multicasts = true;
+			if (priv->sta_asleep_mask) {
+				queue_work(hw_priv->workqueue,
+					&priv->multicast_start_work);
+			}
+		}
+		spin_unlock_bh(&priv->ps_state_lock);
+		spin_unlock(&priv->vif_lock);
+	} else if (!(bes2600_queue_get_skb(
+			queue, arg->packetID, &skb, &txpriv))) {
+		struct ieee80211_tx_info *tx = IEEE80211_SKB_CB(skb);
+		int tx_count = arg->ackFailures;
+		u8 ht_flags = 0;
+		int i;
+
+		if (priv->association_mode.greenfieldMode)
+			ht_flags |= IEEE80211_TX_RC_GREEN_FIELD;
+
+		if (likely(!arg->status)) {
+			tx->flags |= IEEE80211_TX_STAT_ACK;
+			priv->cqm_tx_failure_count = 0;
+			++tx_count;
+			bes2600_debug_txed(priv);
+			if (arg->flags & WSM_TX_STATUS_AGGREGATION) {
+				/* Do not report aggregation to mac80211:
+				 * it confuses minstrel a lot. */
+				/* tx->flags |= IEEE80211_TX_STAT_AMPDU; */
+				bes2600_debug_txed_agg(priv);
+			}
+		} else {
+			spin_lock(&priv->bss_loss_lock);
+			if (priv->bss_loss_status == BES2600_BSS_LOSS_CONFIRMING &&
+					priv->bss_loss_confirm_id == arg->packetID) {
+				priv->bss_loss_status = BES2600_BSS_LOSS_CONFIRMED;
+				spin_unlock(&priv->bss_loss_lock);
+				cancel_delayed_work(&priv->bss_loss_work);
+				queue_delayed_work(hw_priv->workqueue,
+						&priv->bss_loss_work, BSS_LOSS_CFM_INV * HZ / 1000);
+			} else {
+				spin_unlock(&priv->bss_loss_lock);
+			}
+
+			/* TODO: Update TX failure counters */
+			if (unlikely(priv->cqm_tx_failure_thold &&
+			     (++priv->cqm_tx_failure_count >
+			      priv->cqm_tx_failure_thold))) {
+				priv->cqm_tx_failure_thold = 0;
+				queue_work(hw_priv->workqueue,
+						&priv->tx_failure_work);
+			}
+			if (tx_count)
+				++tx_count;
+		}
+		spin_unlock(&priv->vif_lock);
+
+		for (i = 0; i < IEEE80211_TX_MAX_RATES; ++i) {
+			if (tx->status.rates[i].count >= tx_count) {
+				tx->status.rates[i].count = tx_count;
+				break;
+			}
+			tx_count -= tx->status.rates[i].count;
+			if (tx->status.rates[i].flags & IEEE80211_TX_RC_MCS)
+				tx->status.rates[i].flags |= ht_flags;
+		}
+
+		for (++i; i < IEEE80211_TX_MAX_RATES; ++i) {
+			tx->status.rates[i].count = 0;
+			tx->status.rates[i].idx = -1;
+		}
+
+		bes2600_queue_remove(queue, arg->packetID);
+	}else {
+		spin_unlock(&priv->vif_lock);
+		return;
+	}
+}
+
+static void bes2600_notify_buffered_tx(struct bes2600_vif *priv,
+			       struct sk_buff *skb, int link_id, int tid)
+{}
+
+void bes2600_skb_dtor(struct bes2600_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct bes2600_txpriv *txpriv)
+{
+	struct bes2600_vif *priv =
+		__cw12xx_hwpriv_to_vifpriv(hw_priv, txpriv->if_id);
+
+	skb_pull(skb, txpriv->offset);
+	if (priv && txpriv->rate_id != BES2600_INVALID_RATE_ID) {
+		bes2600_notify_buffered_tx(priv, skb,
+				txpriv->raw_link_id, txpriv->tid);
+		tx_policy_put(hw_priv, txpriv->rate_id);
+	}
+	if (likely(!bes2600_is_itp(hw_priv))) {
+		ieee80211_tx_status(hw_priv->hw, skb);
+		bes2600_tx_status(priv, skb);
+	}
+
+}
+
+static void
+bes2600_rx_h_ba_stat(struct bes2600_vif *priv,
+		    size_t hdrlen, size_t skb_len )
+{
+	struct bes2600_common *hw_priv = priv->hw_priv;
+	if (priv->join_status != BES2600_JOIN_STATUS_STA)
+		return;
+	if (!bes2600_is_ht(&hw_priv->ht_info))
+		return;
+	if (!priv->setbssparams_done)
+		return;
+
+	spin_lock_bh(&hw_priv->ba_lock);
+	hw_priv->ba_acc_rx += skb_len - hdrlen;
+	if (!(hw_priv->ba_cnt_rx || hw_priv->ba_cnt)) {
+		mod_timer(&hw_priv->ba_timer,
+			jiffies + BES2600_BLOCK_ACK_INTERVAL);
+	}
+	hw_priv->ba_cnt_rx++;
+	spin_unlock_bh(&hw_priv->ba_lock);
+}
+
+void bes2600_rx_cb(struct bes2600_vif *priv,
+		  struct wsm_rx *arg,
+		  struct sk_buff **skb_p)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct sk_buff *skb = *skb_p;
+	struct ieee80211_rx_status *hdr = IEEE80211_SKB_RXCB(skb);
+	struct ieee80211_hdr *frame = (struct ieee80211_hdr *)skb->data;
+	struct ieee80211_mgmt *mgmt = (struct ieee80211_mgmt *)skb->data;
+	struct bes2600_link_entry *entry = NULL;
+	bool early_data = false;
+	size_t hdrlen = 0;
+
+	hdr->flag = 0;
+	hdr->boottime_ns = ktime_get_boottime_ns();
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		goto drop;
+	}
+
+	/* wakeup device based on frame type */
+	if (!is_multicast_ether_addr(ieee80211_get_DA(frame))) {
+		/* for unicast, wakeup device directly */
+		bes2600_pwr_set_busy_event_with_timeout_async(
+	 			hw_priv, BES_PWR_LOCK_ON_RX, BES_PWR_EVENT_RX_TIMEOUT);
+	}
+
+	if ((ieee80211_is_action(frame->frame_control))
+                        && (mgmt->u.action.category == WLAN_CATEGORY_PUBLIC)) {
+		u8 *action = (u8*)&mgmt->u.action.category;
+		bes2600_check_go_neg_conf_success(hw_priv, action);
+	}
+
+	if (arg->link_id && (arg->link_id != BES2600_LINK_ID_UNMAPPED)
+			&& (arg->link_id <= BES2600_MAX_STA_IN_AP_MODE)) {
+		entry =	&priv->link_id_db[arg->link_id - 1];
+		if (entry->status == BES2600_LINK_SOFT &&
+				ieee80211_is_data(frame->frame_control))
+			early_data = true;
+		entry->timestamp = jiffies;
+	}
+	if (unlikely(arg->status)) {
+		if (arg->status == WSM_STATUS_MICFAILURE) {
+			bes2600_warn(BES2600_DBG_TXRX, "[RX] MIC failure.\n");
+			hdr->flag |= RX_FLAG_MMIC_ERROR;
+		} else if (arg->status == WSM_STATUS_NO_KEY_FOUND) {
+			bes2600_dbg(BES2600_DBG_TXRX, "[RX] No key found.\n");
+			goto drop;
+		} else {
+			bes2600_warn(BES2600_DBG_TXRX, "[RX] Receive failure: %d.\n",
+				arg->status);
+			goto drop;
+		}
+	}
+
+	if (skb->len < sizeof(struct ieee80211_pspoll)) {
+		wiphy_warn(priv->hw->wiphy, "Mailformed SDU rx'ed. "
+				"Size is lesser than IEEE header.\n");
+		goto drop;
+	}
+
+	if (unlikely(ieee80211_is_pspoll(frame->frame_control)))
+		if (bes2600_handle_pspoll(priv, skb))
+			goto drop;
+
+	hdr->mactime = 0; /* Not supported by WSM */
+	hdr->band = (arg->channelNumber > 14) ?
+			NL80211_BAND_5GHZ : NL80211_BAND_2GHZ;
+	hdr->freq = ieee80211_channel_to_frequency(
+			arg->channelNumber,
+			hdr->band);
+
+	if (arg->rxedRate >= 14) {
+		hdr->encoding |= RX_ENC_HT;
+		hdr->rate_idx = arg->rxedRate - 14;
+	} else if (arg->rxedRate >= 4) {
+		if (hdr->band == NL80211_BAND_5GHZ)
+			hdr->rate_idx = arg->rxedRate - 6;
+		else
+			hdr->rate_idx = arg->rxedRate - 2;
+	} else {
+		hdr->rate_idx = arg->rxedRate;
+	}
+
+	hdr->signal = (s8)arg->rcpiRssi;
+	hdr->antenna = 0;
+
+	hdrlen = ieee80211_hdrlen(frame->frame_control);
+	if (WSM_RX_STATUS_ENCRYPTION(arg->flags) == WSM_RX_STATUS_DECRYPTED) {
+		/* decrypted frame with iv/icv stripped */
+		hdr->flag |= RX_FLAG_DECRYPTED;
+		hdr->flag |= RX_FLAG_IV_STRIPPED;
+	}
+	else if (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {
+		size_t iv_len = 0, icv_len = 0;
+
+		hdr->flag |= RX_FLAG_DECRYPTED;
+
+		/* Oops... There is no fast way to ask mac80211 about
+		 * IV/ICV lengths. Even defineas are not exposed.*/
+		switch (WSM_RX_STATUS_ENCRYPTION(arg->flags)) {
+		case WSM_RX_STATUS_WEP:
+			iv_len = 4 /* WEP_IV_LEN */;
+			icv_len = 4 /* WEP_ICV_LEN */;
+			break;
+		case WSM_RX_STATUS_TKIP:
+			iv_len = 8 /* TKIP_IV_LEN */;
+			icv_len = 4 /* TKIP_ICV_LEN */
+				+ 8 /*MICHAEL_MIC_LEN*/;
+			hdr->flag |= RX_FLAG_MMIC_STRIPPED;
+			break;
+		case WSM_RX_STATUS_AES:
+			iv_len = 8 /* CCMP_HDR_LEN */;
+			icv_len = 8 /* CCMP_MIC_LEN */;
+			break;
+		case WSM_RX_STATUS_WAPI:
+			iv_len = 18 /* WAPI_HDR_LEN */;
+			icv_len = 16 /* WAPI_MIC_LEN */;
+			hdr->flag |= RX_FLAG_IV_STRIPPED;
+			break;
+		default:
+			WARN_ON("Unknown encryption type");
+			goto drop;
+		}
+
+		/* Firmware strips ICV in case of MIC failure. */
+		if (arg->status == WSM_STATUS_MICFAILURE) {
+			icv_len = 0;
+			hdr->flag |= RX_FLAG_IV_STRIPPED;
+		}
+
+		if (skb->len < hdrlen + iv_len + icv_len) {
+			wiphy_warn(priv->hw->wiphy, "Mailformed SDU rx'ed. "
+				"Size is lesser than crypto headers.\n");
+			goto drop;
+		}
+
+		/* Protocols not defined in mac80211 should be
+		stripped/crypted in driver/firmware */
+		if (WSM_RX_STATUS_ENCRYPTION(arg->flags) ==
+						WSM_RX_STATUS_WAPI) {
+			/* Remove IV, ICV and MIC */
+			skb_trim(skb, skb->len - icv_len);
+			memmove(skb->data + iv_len, skb->data, hdrlen);
+			skb_pull(skb, iv_len);
+		}
+
+	}
+
+	bes2600_debug_rxed(priv);
+	if (arg->flags & WSM_RX_STATUS_AGGREGATE)
+		bes2600_debug_rxed_agg(priv);
+
+	if (ieee80211_is_beacon(frame->frame_control) &&
+			!arg->status &&
+			!memcmp(ieee80211_get_SA(frame), priv->join_bssid,
+				ETH_ALEN)) {
+		const u8 *tim_ie;
+		u8 *ies;
+		size_t ies_len;
+		priv->disable_beacon_filter = false;
+		queue_work(hw_priv->workqueue, &priv->update_filtering_work);
+		ies = ((struct ieee80211_mgmt *)
+			  (skb->data))->u.beacon.variable;
+		ies_len = skb->len - (ies - (u8 *)(skb->data));
+
+		tim_ie = bes2600_get_ie(ies, ies_len, WLAN_EID_TIM);
+		if (tim_ie) {
+			struct ieee80211_tim_ie *tim =
+				(struct ieee80211_tim_ie *)&tim_ie[2];
+
+			if (priv->join_dtim_period != tim->dtim_period) {
+				priv->join_dtim_period = tim->dtim_period;
+				queue_work(hw_priv->workqueue,
+					&priv->set_beacon_wakeup_period_work);
+			}
+		}
+		if (unlikely(priv->disable_beacon_filter)) {
+			priv->disable_beacon_filter = false;
+			queue_work(hw_priv->workqueue,
+				&priv->update_filtering_work);
+		}
+	}
+
+        if (priv->mode == NL80211_IFTYPE_AP &&
+                        ieee80211_is_beacon(frame->frame_control) &&
+                        !arg->status){
+
+                u8 *ies;
+                size_t ies_len;
+                const u8 *ht_cap;
+                ies = ((struct ieee80211_mgmt *)
+                          (skb->data))->u.beacon.variable;
+                ies_len = skb->len - (ies - (u8 *)(skb->data));
+                ht_cap = bes2600_get_ie(ies, ies_len, WLAN_EID_HT_CAPABILITY);
+                if(!ht_cap){
+                        priv->ht_info |= 0x0011;
+                }
+                queue_work(hw_priv->workqueue,
+                                &priv->ht_info_update_work);
+
+        }
+
+	if (ieee80211_is_deauth(frame->frame_control) ||
+	    ieee80211_is_disassoc(frame->frame_control))
+	    bes2600_pwr_set_busy_event_with_timeout_async(hw_priv,
+	    		BES_PWR_LOCK_ON_DISCON, 1500);
+
+
+	if (ieee80211_is_data(frame->frame_control)) {
+		bes2600_rx_h_ba_stat(priv, hdrlen, skb->len);
+		bes2600_rx_status(priv, skb);
+	}
+
+	if (unlikely(bes2600_itp_rxed(hw_priv, skb)))
+		consume_skb(skb);
+	else if (unlikely(early_data)) {
+		spin_lock_bh(&priv->ps_state_lock);
+		/* Double-check status with lock held */
+		if (entry->status == BES2600_LINK_SOFT)
+			skb_queue_tail(&entry->rx_queue, skb);
+		else
+			ieee80211_rx_irqsafe(priv->hw, skb);
+		spin_unlock_bh(&priv->ps_state_lock);
+	} else {
+		ieee80211_rx_irqsafe(priv->hw, skb);
+	}
+	*skb_p = NULL;
+
+	return;
+
+drop:
+	/* TODO: update failure counters */
+	return;
+}
+
+/* ******************************************************************** */
+/* Security								*/
+
+int bes2600_alloc_key(struct bes2600_common *hw_priv)
+{
+	int idx;
+
+	idx = ffs(~hw_priv->key_map) - 1;
+	if (idx < 0 || idx > WSM_KEY_MAX_INDEX)
+		return -1;
+
+	hw_priv->key_map |= BIT(idx);
+	hw_priv->keys[idx].entryIndex = idx;
+	return idx;
+}
+
+void bes2600_free_key(struct bes2600_common *hw_priv, int idx)
+{
+	BUG_ON(!(hw_priv->key_map & BIT(idx)));
+	memset(&hw_priv->keys[idx], 0, sizeof(hw_priv->keys[idx]));
+	hw_priv->key_map &= ~BIT(idx);
+}
+
+void bes2600_free_keys(struct bes2600_common *hw_priv)
+{
+	memset(&hw_priv->keys, 0, sizeof(hw_priv->keys));
+	hw_priv->key_map = 0;
+}
+
+int bes2600_upload_keys(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	int idx, ret = 0;
+
+	for (idx = 0; idx <= WSM_KEY_MAX_IDX; ++idx)
+		if (hw_priv->key_map & BIT(idx)) {
+			ret = wsm_add_key(hw_priv, &hw_priv->keys[idx], priv->if_id);
+			if (ret < 0)
+				break;
+		}
+	return ret;
+}
diff --git a/drivers/staging/bes2600/txrx.h b/drivers/staging/bes2600/txrx.h
new file mode 100755
index 000000000000..b3f08f1cee90
--- /dev/null
+++ b/drivers/staging/bes2600/txrx.h
@@ -0,0 +1,93 @@
+/*
+ * Datapath interface for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2010, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_TXRX_H
+#define BES2600_TXRX_H
+
+#include <linux/list.h>
+
+/* extern */ struct ieee80211_hw;
+/* extern */ struct sk_buff;
+/* extern */ struct wsm_tx;
+/* extern */ struct wsm_rx;
+/* extern */ struct wsm_tx_confirm;
+/* extern */ struct bes2600_txpriv;
+/* extern */ struct bes2600_vif;
+
+struct tx_policy {
+	union {
+		__le32 tbl[3];
+		u8 raw[12];
+	};
+	u8  defined;		/* TODO: u32 or u8, profile and select best */
+	u8  usage_count;	/* --// -- */
+	u8  retry_count;	/* --// -- */
+	u8  uploaded;
+};
+
+struct tx_policy_cache_entry {
+	struct tx_policy policy;
+	struct list_head link;
+};
+
+#define TX_POLICY_CACHE_SIZE	(8)
+struct tx_policy_cache {
+	struct tx_policy_cache_entry cache[TX_POLICY_CACHE_SIZE];
+	struct list_head used;
+	struct list_head free;
+	spinlock_t lock;
+};
+
+/* ******************************************************************** */
+/* TX policy cache							*/
+/* Intention of TX policy cache is an overcomplicated WSM API.
+ * Device does not accept per-PDU tx retry sequence.
+ * It uses "tx retry policy id" instead, so driver code has to sync
+ * linux tx retry sequences with a retry policy table in the device.
+ */
+void tx_policy_init(struct bes2600_common *hw_priv);
+void tx_policy_deinit(struct bes2600_common *hw_priv);
+void tx_policy_upload_work(struct work_struct *work);
+
+/* ******************************************************************** */
+/* TX implementation							*/
+
+u32 bes2600_rate_mask_to_wsm(struct bes2600_common *hw_priv,
+			       u32 rates);
+void bes2600_tx(struct ieee80211_hw *dev,
+			struct ieee80211_tx_control *control,
+			struct sk_buff *skb);
+void bes2600_skb_dtor(struct bes2600_common *hw_priv,
+		     struct sk_buff *skb,
+		     const struct bes2600_txpriv *txpriv);
+
+/* ******************************************************************** */
+/* WSM callbacks							*/
+
+void bes2600_tx_confirm_cb(struct bes2600_common *hw_priv,
+			  struct wsm_tx_confirm *arg);
+void bes2600_rx_cb(struct bes2600_vif *priv,
+		  struct wsm_rx *arg,
+		  struct sk_buff **skb_p);
+
+/* ******************************************************************** */
+/* Timeout								*/
+
+void bes2600_tx_timeout(struct work_struct *work);
+
+/* ******************************************************************** */
+/* Security								*/
+int bes2600_alloc_key(struct bes2600_common *hw_priv);
+void bes2600_free_key(struct bes2600_common *hw_priv, int idx);
+void bes2600_free_keys(struct bes2600_common *hw_priv);
+int bes2600_upload_keys(struct bes2600_vif *priv);
+
+#endif /* BES2600_TXRX_H */
diff --git a/drivers/staging/bes2600/txrx_opt.c b/drivers/staging/bes2600/txrx_opt.c
new file mode 100755
index 000000000000..70fa58439af0
--- /dev/null
+++ b/drivers/staging/bes2600/txrx_opt.c
@@ -0,0 +1,443 @@
+/***************************************************************************
+ *
+ * Copyright 2015-2022 BES.
+ * All rights reserved. All unpublished rights reserved.
+ *
+ * No part of this work may be used or reproduced in any form or by any
+ * means, or stored in a database or retrieval system, without prior written
+ * permission of BES.
+ *
+ * Use of this work is governed by a license granted by BES.
+ * This work contains confidential and proprietary information of
+ * BES. which is protected by copyright, trade secret,
+ * trademark and other intellectual property rights.
+ *
+ ****************************************************************************/
+#include <net/mac80211.h>
+#include <linux/etherdevice.h>
+#include <linux/skbuff.h>
+#include <linux/timer.h>
+
+#include "bes2600.h"
+#include "wsm.h"
+#include "bh.h"
+#include "ap.h"
+#include "debug.h"
+#include "sta.h"
+#include "sbus.h"
+#include "bes2600_log.h"
+#include "bes_pwr.h"
+
+#define TXRX_OPT_EDCA_MAX_LEVEL 4
+#define TX_AVG_TIME_COUNT       10
+#define TXRX_OPT_PEROID         500
+#define TXRX_OPT_DEBUG          1
+
+#define TXRX_HIGH_TP_THRESHOLD_2G4    30000   //unit is kbps
+#define TXRX_HIGH_TP_THRESHOLD_5G    40000    //unit is kbps
+#define TXRX_HIGH_TP_DELTA_TIME_2G4   8       //unit ms
+#define TXRX_HIGH_TP_DELTA_TIME_5G   6       //unit ms
+
+static uint32_t tx_delta_time_arr[4][TX_AVG_TIME_COUNT];
+static uint32_t tx_queue_arr[4] = {0};
+static uint32_t tx_delta_time_total = 0;
+static uint32_t tx_delta_time_total_cnt = 0;
+
+void bes2600_add_tx_delta_time(uint32_t tx_delta_time)
+{
+	tx_delta_time_total += tx_delta_time;
+	tx_delta_time_total_cnt++;
+}
+
+uint32_t bes2600_get_tx_delta_time(void)
+{
+	if (tx_delta_time_total_cnt != 0)
+		return tx_delta_time_total / tx_delta_time_total_cnt;
+	else
+		return 0;
+}
+
+void bes2600_clear_tx_delta_time(void)
+{
+	tx_delta_time_total_cnt = 0;
+	tx_delta_time_total = 0;
+	return ;
+}
+
+uint32_t bes2600_get_tx_ac_delta_time(int ac)
+{
+	uint32_t avg_time = 0;
+	int i = 0;
+	for (i = 0; i < TX_AVG_TIME_COUNT; i++) {
+		avg_time += tx_delta_time_arr[ac][i];
+	}
+	return avg_time / TX_AVG_TIME_COUNT;
+}
+
+void bes2600_clear_tx_ac_delta_time(int ac)
+{
+	int i = 0;
+	for (i = 0; i < TX_AVG_TIME_COUNT; i++) {
+		tx_delta_time_arr[ac][i] = 0;
+	}
+	return ;
+}
+
+void bes2600_add_tx_ac_delta_time(int ac, uint32_t del_time)
+{
+	tx_delta_time_arr[ac][tx_queue_arr[ac]] = del_time;
+	tx_queue_arr[ac] = (tx_queue_arr[ac] >= (TX_AVG_TIME_COUNT - 1)) ? 0 : (tx_queue_arr[ac] + 1);
+}
+
+
+int bes2600_set_txrx_opt_param(struct bes2600_common *hw_priv,
+			       struct bes2600_vif *priv,
+			       MIB_TXRX_OPT_PARAM  *para)
+{
+
+	int ret = 0;
+	ret = WARN_ON(wsm_write_mib(hw_priv,
+				    WSM_MIB_ID_EXT_TXRX_OPT_PARAM,
+				    (u8 *)para,
+				    sizeof(MIB_TXRX_OPT_PARAM),
+				    priv->if_id));
+	return ret;
+}
+
+int bes2600_enable_tx_shortgi(struct bes2600_common *hw_priv,
+			      struct bes2600_vif *priv,
+			      u8 onoff)
+{
+	int ret = 0;
+	static u8 en = 0xff;
+
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "%s onoff=%d\n\r", __func__, onoff);
+
+	if (en != onoff) {
+		en = onoff;
+		ret = WARN_ON(wsm_write_mib(hw_priv,
+					    WSM_MIB_ID_EXT_TX_SHORT_GI_ENABLED,
+					    (u8 *)&onoff,
+					    sizeof(onoff),
+					    priv->if_id));
+	}
+	return ret;
+}
+
+void bes2600_rx_status(struct bes2600_vif *priv, struct sk_buff *skb)
+{
+	priv->dot11ReceivedFragmentCount++;
+	priv->dot11ReceivedDataBytes += skb->len;
+}
+
+void bes2600_tx_status(struct bes2600_vif *priv, struct sk_buff *skb)
+{
+	struct ieee80211_hdr *hdr = (struct ieee80211_hdr *) skb->data;
+	struct ieee80211_tx_info *info = IEEE80211_SKB_CB(skb);
+	__le16 fc;
+	int i;
+	int retry_count = -1;
+	fc = hdr->frame_control;
+
+	if (ieee80211_is_data(fc)) {
+		for (i = 0; i < IEEE80211_TX_MAX_RATES; i++) {
+			if (info->status.rates[i].idx < 0) {
+				break;
+			}
+			retry_count += info->status.rates[i].count;
+		}
+		if (retry_count < 0)
+			retry_count = 0;
+
+		if (info->flags & IEEE80211_TX_STAT_ACK) {
+			priv->dot11TransmittedFrameCount++;
+			priv->dot11TransmittedDataBytes += (skb->len + 4);
+			if (retry_count > 0)
+				priv->dot11RetryCount += retry_count;
+
+		} else {
+			/* tx fail.*/
+			priv->dot11FailedCount++;
+		}
+	}
+
+}
+void bes2600_set_default_params(struct bes2600_common *hw_priv, struct bes2600_vif *priv);
+
+int bes2600_set_high_edca_params(struct bes2600_common *hw_priv, struct bes2600_vif *priv, int level)
+{
+	struct wsm_edca_params arg;
+	int i = 0;
+	static int lev = 0;
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "set edca level=%d\n\r", level);
+
+	if (lev == level)
+		return 0;
+
+	memcpy(&arg, &(priv->edca), sizeof(struct wsm_edca_params));
+
+
+	if (level == 0) {
+		bes2600_set_default_params(hw_priv, priv);
+		return 0;
+	} else if (level == 1) {
+		for ( i = 0; i < 4; i++) {
+			arg.params[i].aifns = 2;
+			arg.params[i].cwMax = 7;
+			arg.params[i].cwMin = 3;
+			/*
+			 * tx op must set 0
+			 * set other, some AP may not response BA when rx data.
+			*/
+			arg.params[i].txOpLimit = 0;
+			arg.params[i].maxReceiveLifetime = 0xc8;
+		}
+	} else if (level == 2) {
+		for ( i = 0; i < 4; i++) {
+			arg.params[i].aifns = 2;
+			arg.params[i].cwMax = 5;
+			arg.params[i].cwMin = 1;
+			arg.params[i].txOpLimit = 0;
+			arg.params[i].maxReceiveLifetime = 0xc8;
+		}
+	} else if (level == 3) {
+		for ( i = 0; i < 4; i++) {
+			arg.params[i].aifns = 2;
+			arg.params[i].cwMax = 3;
+			arg.params[i].cwMin = 1;
+			arg.params[i].txOpLimit = 0;
+			arg.params[i].maxReceiveLifetime = 0xc8;
+		}
+	} else if (level == 4) {
+		for ( i = 0; i < 4; i++) {
+			arg.params[i].aifns = 1;
+			arg.params[i].cwMax = 3;
+			arg.params[i].cwMin = 1;
+			arg.params[i].txOpLimit = 0;
+			arg.params[i].maxReceiveLifetime = 0xc8;
+		}
+	}
+	wsm_set_edca_params(hw_priv, &arg, priv->if_id);
+	return 0;
+}
+void bes2600_set_default_params(struct bes2600_common *hw_priv, struct bes2600_vif *priv)
+{
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "set edca default\n\r");
+	wsm_set_edca_params(hw_priv, &priv->edca, priv->if_id);
+}
+void bes2600_set_cca_method(struct bes2600_common *hw_priv, struct bes2600_vif *priv, int value)
+{
+// todo set cca alg
+}
+
+void bes2600_set_dynamic_agc(struct bes2600_common *hw_priv, struct bes2600_vif *priv, int value)
+{
+// todo set agc alg 
+}
+int bes2600_get_tx_av_max_delta_time(void)
+{
+	int max_avg = 0;
+	int i = 0;
+
+	for (i = 0; i < 4; i++) {
+		if (max_avg < bes2600_get_tx_ac_delta_time(i)) {
+			max_avg = bes2600_get_tx_ac_delta_time(i);
+		}
+		//bes2600_clear_tx_ac_delta_time(i);
+	}
+	return max_avg;
+}
+
+bool bes2600_station_is_ap_ht40(struct bes2600_common *hw_priv)
+{
+
+	if (hw_priv->hw) {
+		struct ieee80211_conf *conf = &hw_priv->hw->conf;
+		if (conf !=  NULL)
+			if (conf->chandef.width == NL80211_CHAN_WIDTH_40)
+				return true;
+	}
+	return false;
+}
+
+void bes2600_dynamic_opt_rxtx(struct bes2600_common *hw_priv, struct bes2600_vif *priv, int rssi)
+{
+	u32 succPro = 0, tx_cnt, tx_retry, rx_cnt, tx_fail;
+	static u32 l_tx_cnt = 0, l_tx_fail = 0, l_tx_retry = 0, l_rx_cnt = 0;
+	static u32 tx_bps = 0, rx_bps = 0;
+	u32 total_kbps = 0;
+	static int level;
+	int rts_value = 2347;
+	int short_gi = 0;
+
+	/* calculate real time throughput */
+	if (hw_priv == NULL || priv == NULL) {
+		return;
+	}
+	tx_bps = abs (priv->dot11TransmittedDataBytes - tx_bps);
+	rx_bps = abs (priv->dot11ReceivedDataBytes  - rx_bps);
+	total_kbps = (tx_bps / 128 + rx_bps / 128);
+
+	total_kbps *= 1000;
+	total_kbps /= TXRX_OPT_PEROID;
+
+	/*  if tx/rx < 100k/s, close*/
+	if (total_kbps < 100) {
+		level = 0;
+		goto txrx_opt_clear;
+	}
+
+	/* calculate tx_cnt, tx_retry, rx_cnt */
+	tx_cnt = (priv->dot11TransmittedFrameCount - l_tx_cnt);
+	tx_fail = (priv->dot11FailedCount - l_tx_fail);
+	tx_retry = (priv->dot11RetryCount - l_tx_retry);
+	rx_cnt = (priv->dot11ReceivedFragmentCount - l_rx_cnt);
+	( (tx_cnt + tx_retry) > 0 ) ? (succPro = tx_cnt * 100 / (tx_cnt + tx_retry)) : (succPro = 0);
+
+	if (succPro != 0) {
+		/* hw value 21 is mcs7, dynamic set short GI */
+		if (priv->hw_value == 21 && succPro > 90)
+			short_gi = 1;
+		else
+			short_gi = 0;
+
+		/* dynamic set RTS/CTS */
+		if (succPro  < 80)
+			rts_value = 512;
+	}
+
+	/* dynamic set edca param */
+	if (succPro != 0) {
+		if (bes2600_station_is_ap_ht40(hw_priv)) {
+			if (bes2600_get_tx_delta_time() > 8 || bes2600_get_tx_av_max_delta_time() > 8) {
+				if (level < 4)
+					level++;
+			} else {
+				if (level > 0)
+					level--;
+			}
+			/* high throughput force level = 0 */
+			if (total_kbps > TXRX_HIGH_TP_THRESHOLD_5G && level > 0 && priv->hw_value > 19) {
+				level = 0;
+			}
+
+		} else {//shiled room 13, office 8
+			if (bes2600_get_tx_delta_time() > (TXRX_HIGH_TP_DELTA_TIME_5G + total_kbps / 8000)
+			    || bes2600_get_tx_av_max_delta_time() > (TXRX_HIGH_TP_DELTA_TIME_5G + total_kbps / 8000)) {
+				if (level < 4)
+					level++;
+			} else {
+				if (level > 0)
+					level--;
+			}
+			/* high throughput force level = 0 */
+			if (total_kbps > TXRX_HIGH_TP_THRESHOLD_2G4 && level > 0) {
+				level = 0;
+			}
+
+		}
+	}
+	if (level > TXRX_OPT_EDCA_MAX_LEVEL)
+		level = TXRX_OPT_EDCA_MAX_LEVEL;
+
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "txrx_opt: tx(cnt=%d retry=%d psr=%d tx_fail=%d (wsm rts=%d shortgi=%d level=%d) tx=%dk/s)\n\r",
+	       tx_cnt, tx_retry, succPro, tx_fail, rts_value, short_gi, level, tx_bps / 128);
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "txrx_opt: rx(cnt=%d  rx=%dk/s) total=%dk/s\n\r", rx_cnt, rx_bps / 128, total_kbps);
+	bes2600_dbg(BES2600_DBG_TXRX_OPT, "txrx_opt: tx_delta_time=%d [%d %d %d %d] hw_value=%d ht=%d maxtxcnt=%d\n\r",
+	       bes2600_get_tx_delta_time(), bes2600_get_tx_ac_delta_time(0), bes2600_get_tx_ac_delta_time(1),
+	       bes2600_get_tx_ac_delta_time(2), bes2600_get_tx_ac_delta_time(3), priv->hw_value,
+	       bes2600_station_is_ap_ht40(hw_priv), hw_priv->long_frame_max_tx_count);
+
+
+	/* dynamic set cca */
+	bes2600_set_cca_method(hw_priv, priv, 0);
+	/* dynamic set agc */
+	bes2600_set_dynamic_agc(hw_priv, priv, 0);
+txrx_opt_clear:
+	bes2600_set_rts_threshold(priv->hw, rts_value);
+	bes2600_enable_tx_shortgi(hw_priv, priv, short_gi);
+	bes2600_set_high_edca_params(hw_priv, priv, level);
+	bes2600_clear_tx_delta_time();
+	bes2600_clear_tx_ac_delta_time(0);
+	bes2600_clear_tx_ac_delta_time(1);
+	bes2600_clear_tx_ac_delta_time(2);
+	bes2600_clear_tx_ac_delta_time(3);
+	tx_bps = priv->dot11TransmittedDataBytes;
+	rx_bps = priv->dot11ReceivedDataBytes;
+	l_tx_cnt = priv->dot11TransmittedFrameCount;
+	l_tx_fail = priv->dot11FailedCount;
+	l_tx_retry = priv->dot11RetryCount;
+	l_rx_cnt = priv->dot11ReceivedFragmentCount;
+	return ;
+}
+
+static struct bes2600_common *txrx_hw_priv = NULL;
+
+static void txrx_opt_timer_callback(struct timer_list* data)
+{
+	bes2600_dbg(BES2600_DBG_TXRX, "####Timer callback function Called time = %lu\n", jiffies);
+	queue_work(txrx_hw_priv->workqueue, &txrx_hw_priv->dynamic_opt_txrx_work);
+	mod_timer(&txrx_hw_priv->txrx_opt_timer, jiffies + msecs_to_jiffies(TXRX_OPT_PEROID));
+}
+
+static void txrx_opt_timer_start(struct bes2600_common *hw_priv)
+{
+	mod_timer(&hw_priv->txrx_opt_timer, jiffies + msecs_to_jiffies(TXRX_OPT_PEROID));
+}
+
+static void txrx_opt_timer_stop(struct bes2600_common *hw_priv)
+{
+	del_timer_sync(&hw_priv->txrx_opt_timer);
+}
+
+int bes2600_set_txrx_opt_default_param(struct bes2600_common * hw_priv)
+{
+	MIB_TXRX_OPT_PARAM g_txrx_param = {2, (PROCTECT_MODE_RTS_CTS | PROCTECT_MODE_RTS_CTS_RETRY), 2002};
+	struct bes2600_vif *priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	if (priv == NULL)
+		return 0;
+	memcpy(&hw_priv->txrx_opt_param, &g_txrx_param, sizeof(MIB_TXRX_OPT_PARAM));
+	bes2600_set_txrx_opt_param(hw_priv, priv, &hw_priv->txrx_opt_param);
+	return 0;
+}
+
+int bes2600_set_txrx_opt_unjoin_param(struct bes2600_common * hw_priv)
+{
+	MIB_TXRX_OPT_PARAM g_txrx_param = {1, 0, 2002};
+	struct bes2600_vif *priv = __cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	if (priv == NULL)
+		return 0;
+	memcpy(&hw_priv->txrx_opt_param, &g_txrx_param, sizeof(MIB_TXRX_OPT_PARAM));
+	bes2600_set_txrx_opt_param(hw_priv, priv, &hw_priv->txrx_opt_param);
+	return 0;
+}
+
+int txrx_opt_timer_init(struct bes2600_common *hw_priv)
+{
+	bes2600_info(BES2600_DBG_TXRX_OPT, "txrx_opt_timer_init:%p", txrx_hw_priv);
+	if (!txrx_hw_priv) {
+		txrx_hw_priv = hw_priv;
+		bes2600_info(BES2600_DBG_TXRX, "####Timer init hw_priv = %p\n", txrx_hw_priv);
+		timer_setup(&hw_priv->txrx_opt_timer, txrx_opt_timer_callback, 0);
+		bes2600_set_txrx_opt_default_param(hw_priv);
+	}
+
+	mod_timer(&hw_priv->txrx_opt_timer, jiffies + msecs_to_jiffies(TXRX_OPT_PEROID));
+	bes2600_pwr_register_en_lp_cb(hw_priv, txrx_opt_timer_stop);
+	bes2600_pwr_register_exit_lp_cb(hw_priv, txrx_opt_timer_start);
+	return 0;
+}
+
+void txrx_opt_timer_exit(struct bes2600_common *hw_priv)
+{
+	bes2600_info(BES2600_DBG_TXRX_OPT, "txrx_opt_timer_exit");
+
+	del_timer_sync(&hw_priv->txrx_opt_timer);
+	cancel_work_sync(&hw_priv->dynamic_opt_txrx_work);
+	bes2600_pwr_unregister_en_lp_cb(hw_priv, txrx_opt_timer_stop);
+	bes2600_pwr_unregister_exit_lp_cb(hw_priv, txrx_opt_timer_start);
+	txrx_hw_priv = NULL;
+	bes2600_set_txrx_opt_unjoin_param(hw_priv);
+}
+
+
diff --git a/drivers/staging/bes2600/txrx_opt.h b/drivers/staging/bes2600/txrx_opt.h
new file mode 100755
index 000000000000..7aeaea53d7c8
--- /dev/null
+++ b/drivers/staging/bes2600/txrx_opt.h
@@ -0,0 +1,29 @@
+
+/***************************************************************************
+ *
+ * Copyright 2015-2022 BES.
+ * All rights reserved. All unpublished rights reserved.
+ *
+ * No part of this work may be used or reproduced in any form or by any
+ * means, or stored in a database or retrieval system, without prior written
+ * permission of BES.
+ *
+ * Use of this work is governed by a license granted by BES.
+ * This work contains confidential and proprietary information of
+ * BES. which is protected by copyright, trade secret,
+ * trademark and other intellectual property rights.
+ *
+ ****************************************************************************/
+#ifndef bes2600_TXRX_OPT_H
+#define bes2600_TXRX_OPT_H
+#include <linux/list.h>
+void bes2600_add_tx_ac_delta_time(int ac, uint32_t del_time);
+void bes2600_add_tx_delta_time(uint32_t tx_time);
+void bes2600_rx_status(struct bes2600_vif *priv, struct sk_buff *skb);
+void bes2600_tx_status(struct bes2600_vif *priv, struct sk_buff *skb);
+void bes2600_dynamic_opt_rxtx(struct bes2600_common *hw_priv,struct bes2600_vif *priv, int rssi);
+int txrx_opt_timer_init(struct bes2600_common *hw_priv);
+int txrx_opt_timer_exit(struct bes2600_common *hw_priv);
+
+#endif
+
diff --git a/drivers/staging/bes2600/wsm.c b/drivers/staging/bes2600/wsm.c
new file mode 100755
index 000000000000..d32870eb3eda
--- /dev/null
+++ b/drivers/staging/bes2600/wsm.c
@@ -0,0 +1,2516 @@
+/*
+ * WSM host interface (HI) implementation for
+ * BES2600 mac80211 drivers.
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/skbuff.h>
+#include <linux/wait.h>
+#include <linux/skbuff.h>
+#include <linux/delay.h>
+#include <linux/sched.h>
+#include <linux/random.h>
+#include <linux/etherdevice.h>
+
+#include "bes2600.h"
+#include "wsm.h"
+#include "bh.h"
+#include "debug.h"
+#include "itp.h"
+#include "bes2600_driver_mode.h"
+#include "bes_chardev.h"
+#include "bes2600_factory.h"
+#include "epta_coex.h"
+#include "epta_request.h"
+
+#define WSM_CMD_TIMEOUT		(6 * HZ) /* With respect to interrupt loss */
+#define WSM_CMD_JOIN_TIMEOUT	(7 * HZ) /* Join timeout is 5 sec. in FW   */
+#define WSM_CMD_START_TIMEOUT	(7 * HZ)
+#define WSM_CMD_RESET_TIMEOUT	(7 * HZ) /* 2 sec. timeout was observed.   */
+#define WSM_CMD_DEFAULT_TIMEOUT	(7 * HZ)
+#define WSM_SKIP(buf, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			goto underflow;					\
+		(buf)->data += size;					\
+	} while (0)
+
+#define WSM_GET(buf, ptr, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			goto underflow;					\
+		memcpy(ptr, (buf)->data, size);				\
+		(buf)->data += size;					\
+	} while (0)
+
+#define __WSM_GET(buf, type, cvt)					\
+	({								\
+		type val;						\
+		if (unlikely((buf)->data + sizeof(type) > (buf)->end))	\
+			goto underflow;					\
+		val = cvt(*(type *)(buf)->data);			\
+		(buf)->data += sizeof(type);				\
+		val;							\
+	})
+
+#define WSM_GET8(buf)  __WSM_GET(buf, u8, (u8))
+#define WSM_GET16(buf) __WSM_GET(buf, u16, __le16_to_cpu)
+#define WSM_GET32(buf) __WSM_GET(buf, u32, __le32_to_cpu)
+
+#define WSM_PUT(buf, ptr, size)						\
+	do {								\
+		if (unlikely((buf)->data + size > (buf)->end))		\
+			if (unlikely(wsm_buf_reserve((buf), size)))	\
+				goto nomem;				\
+		memcpy((buf)->data, ptr, size);				\
+		(buf)->data += size;					\
+	} while (0)
+
+#define __WSM_PUT(buf, val, type, cvt)					\
+	do {								\
+		if (unlikely((buf)->data + sizeof(type) > (buf)->end))	\
+			if (unlikely(wsm_buf_reserve((buf), sizeof(type)))) \
+				goto nomem;				\
+		*(type *)(buf)->data = cvt(val);			\
+		(buf)->data += sizeof(type);				\
+	} while (0)
+
+#define WSM_PUT8(buf, val)  __WSM_PUT(buf, val, u8, (u8))
+#define WSM_PUT16(buf, val) __WSM_PUT(buf, val, u16, __cpu_to_le16)
+#define WSM_PUT32(buf, val) __WSM_PUT(buf, val, u32, __cpu_to_le32)
+
+static void wsm_buf_reset(struct wsm_buf *buf);
+static int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size);
+static int get_interface_id_scanning(struct bes2600_common *hw_priv);
+
+static int wsm_cmd_send(struct bes2600_common *hw_priv,
+			struct wsm_buf *buf,
+			void *arg, u16 cmd, long tmo, int if_id);
+
+static struct bes2600_vif
+	*wsm_get_interface_for_tx(struct bes2600_common *hw_priv);
+
+static inline void wsm_cmd_lock(struct bes2600_common *hw_priv)
+{
+	bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_WSM_TX);
+	down(&hw_priv->wsm_cmd_sema);
+}
+
+static inline void wsm_cmd_unlock(struct bes2600_common *hw_priv)
+{
+	up(&hw_priv->wsm_cmd_sema);
+	bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_WSM_TX);
+}
+
+static inline void wsm_oper_lock(struct bes2600_common *hw_priv)
+{
+	bes2600_pwr_set_busy_event(hw_priv, BES_PWR_LOCK_ON_WSM_OPER);
+	down(&hw_priv->wsm_oper_lock);
+}
+
+static inline void wsm_oper_unlock(struct bes2600_common *hw_priv)
+{
+	up(&hw_priv->wsm_oper_lock);
+	bes2600_pwr_clear_busy_event(hw_priv, BES_PWR_LOCK_ON_WSM_OPER);
+}
+
+/* ******************************************************************** */
+/* WSM API implementation						*/
+
+static int wsm_generic_confirm(struct bes2600_common *hw_priv,
+				 void *arg,
+				 struct wsm_buf *buf)
+{
+	u32 status = WSM_GET32(buf);
+	if (WARN(status != WSM_STATUS_SUCCESS, "wsm_generic_confirm ret %u", status))
+		return -EINVAL;
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+int wsm_configuration(struct bes2600_common *hw_priv,
+			  struct wsm_configuration *arg,
+			  int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT32(buf, arg->dot11MaxTransmitMsduLifeTime);
+	WSM_PUT32(buf, arg->dot11MaxReceiveLifeTime);
+	WSM_PUT32(buf, arg->dot11RtsThreshold);
+
+	/* DPD block. */
+	WSM_PUT16(buf, arg->dpdData_size + 12);
+	WSM_PUT16(buf, 1); /* DPD version */
+	WSM_PUT(buf, arg->dot11StationId, ETH_ALEN);
+	WSM_PUT16(buf, 5); /* DPD flags */
+	WSM_PUT(buf, arg->dpdData, arg->dpdData_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x0009, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_configuration_confirm(struct bes2600_common *hw_priv,
+					 struct wsm_configuration *arg,
+					 struct wsm_buf *buf)
+{
+	int i;
+	int status;
+
+	status = WSM_GET32(buf);
+	if (WARN_ON(status != WSM_STATUS_SUCCESS))
+		return -EINVAL;
+
+	if (bes2600_chrdev_is_signal_mode()) {
+		WSM_GET(buf, arg->dot11StationId, ETH_ALEN);
+		arg->dot11FrequencyBandsSupported = WSM_GET8(buf);
+		WSM_SKIP(buf, 1);
+		arg->supportedRateMask = WSM_GET32(buf);
+		for (i = 0; i < 2; ++i) {
+			arg->txPowerRange[i].min_power_level = WSM_GET32(buf);
+			arg->txPowerRange[i].max_power_level = WSM_GET32(buf);
+			arg->txPowerRange[i].stepping = WSM_GET32(buf);
+		}
+	}
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+
+// wifi cpu sleep control
+struct wsm_sleep_ctrl {
+	u16 msgid;
+	u16 msglen;
+	u32 disable;
+};
+
+int wsm_sleep_ctrl(struct bes2600_common *hw_priv, u32 disable, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	if (if_id != 0) {
+		WARN_ON(1);
+		return -EBUSY;
+	}
+
+	wsm_cmd_lock(hw_priv);
+	WSM_PUT32(buf, disable);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0024, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_reset(struct bes2600_common *hw_priv, const struct wsm_reset *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u16 cmd = 0x000A | WSM_TX_LINK_ID(arg->link_id);
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT32(buf, arg->reset_statistics ? 0 : 1);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, cmd, WSM_CMD_RESET_TIMEOUT,
+				if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_read_mib(struct bes2600_common *hw_priv, u16 mibId, void *_buf,
+			size_t buf_size)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	struct wsm_mib mib_buf = {
+		.mibId = mibId,
+		.buf = _buf,
+		.buf_size = buf_size,
+	};
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, mibId);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, &mib_buf, 0x0005, WSM_CMD_TIMEOUT, -1);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_read_mib_confirm(struct bes2600_common *hw_priv,
+				struct wsm_mib *arg,
+				struct wsm_buf *buf)
+{
+	u16 size;
+	if (WARN_ON(WSM_GET32(buf) != WSM_STATUS_SUCCESS))
+		return -EINVAL;
+
+	if (WARN_ON(WSM_GET16(buf) != arg->mibId))
+		return -EINVAL;
+
+	size = WSM_GET16(buf);
+	if (size > arg->buf_size)
+		size = arg->buf_size;
+
+	WSM_GET(buf, arg->buf, size);
+	arg->buf_size = size;
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+
+int wsm_write_mib(struct bes2600_common *hw_priv, u16 mibId, void *_buf,
+			size_t buf_size, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	struct wsm_mib mib_buf = {
+		.mibId = mibId,
+		.buf = _buf,
+		.buf_size = buf_size,
+	};
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, mibId);
+	WSM_PUT16(buf, buf_size);
+	WSM_PUT(buf, _buf, buf_size);
+
+	ret = wsm_cmd_send(hw_priv, buf, &mib_buf, 0x0006, WSM_CMD_TIMEOUT,
+			if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+static int wsm_write_mib_confirm(struct bes2600_common *hw_priv,
+				struct wsm_mib *arg,
+				struct wsm_buf *buf,
+				int interface_link_id)
+{
+	int ret;
+	struct bes2600_vif *priv;
+
+	if (!is_hardware_cw1250(hw_priv) || is_hardware_cw1260(hw_priv))
+		interface_link_id = 0;
+
+	ret = wsm_generic_confirm(hw_priv, arg, buf);
+	if (ret)
+		return ret;
+
+	if (arg->mibId == 0x1006) {
+		const char *p = arg->buf;
+
+		/* Power save is enabled before add_interface is called */
+		if (!hw_priv->vif_list[interface_link_id])
+			return 0;
+		/* OperationalMode: update PM status. */
+		priv = cw12xx_hwpriv_to_vifpriv(hw_priv,
+					interface_link_id);
+		if (!priv)
+			return 0;
+		bes2600_enable_powersave(priv,
+				(p[0] & 0x0F) ? true : false);
+		spin_unlock(&priv->vif_lock);
+	}
+	return 0;
+}
+
+/* ******************************************************************** */
+
+int wsm_scan(struct bes2600_common *hw_priv, const struct wsm_scan *arg,
+		int if_id)
+{
+	int i;
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	if (unlikely(arg->numOfChannels > 48))
+		return -EINVAL;
+
+	if (unlikely(arg->numOfSSIDs > WSM_SCAN_MAX_NUM_OF_SSIDS))
+		return -EINVAL;
+
+	if (unlikely(arg->band > 1))
+		return -EINVAL;
+
+	wsm_oper_lock(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT8(buf, arg->scanType);
+	WSM_PUT8(buf, arg->scanFlags);
+	WSM_PUT8(buf, arg->maxTransmitRate);
+	WSM_PUT32(buf, arg->autoScanInterval);
+	WSM_PUT8(buf, arg->numOfProbeRequests);
+	WSM_PUT8(buf, arg->numOfChannels);
+	WSM_PUT8(buf, arg->numOfSSIDs);
+	WSM_PUT8(buf, arg->probeDelay);
+
+	for (i = 0; i < arg->numOfChannels; ++i) {
+		WSM_PUT16(buf, arg->ch[i].number);
+		WSM_PUT16(buf, 0);
+		WSM_PUT32(buf, arg->ch[i].minChannelTime);
+		WSM_PUT32(buf, arg->ch[i].maxChannelTime);
+		WSM_PUT32(buf, 0);
+	}
+
+	for (i = 0; i < arg->numOfSSIDs; ++i) {
+		WSM_PUT32(buf, arg->ssids[i].length);
+		WSM_PUT(buf, &arg->ssids[i].ssid[0],
+				sizeof(arg->ssids[i].ssid));
+	}
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0007, WSM_CMD_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	if (ret)
+		wsm_oper_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_stop_scan(struct bes2600_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0008, WSM_CMD_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+
+static int wsm_tx_confirm(struct bes2600_common *hw_priv,
+			  struct wsm_buf *buf,
+			  int interface_link_id)
+{
+	struct wsm_tx_confirm tx_confirm;
+
+	tx_confirm.packetID = WSM_GET32(buf);
+	tx_confirm.status = WSM_GET32(buf);
+	tx_confirm.txedRate = WSM_GET8(buf);
+	tx_confirm.ackFailures = WSM_GET8(buf);
+	tx_confirm.flags = WSM_GET16(buf);
+	tx_confirm.mediaDelay = WSM_GET32(buf);
+	tx_confirm.txQueueDelay = WSM_GET32(buf);
+
+	if (is_hardware_cw1250(hw_priv) || is_hardware_cw1260(hw_priv)) {
+		/* TODO:COMBO:linkID will be stored in packetID*/
+		/* TODO:COMBO: Extract traffic resumption map */
+		tx_confirm.if_id = bes2600_queue_get_if_id(tx_confirm.packetID);
+		tx_confirm.link_id = bes2600_queue_get_link_id(
+				tx_confirm.packetID);
+	} else {
+		tx_confirm.link_id = interface_link_id;
+		tx_confirm.if_id = 0;
+	}
+
+	wsm_release_vif_tx_buffer(hw_priv, tx_confirm.if_id, 1);
+
+	if (hw_priv->wsm_cbc.tx_confirm)
+		hw_priv->wsm_cbc.tx_confirm(hw_priv, &tx_confirm);
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+static int wsm_multi_tx_confirm(struct bes2600_common *hw_priv,
+				struct wsm_buf *buf, int interface_link_id)
+{
+	struct bes2600_vif *priv;
+	int ret;
+	int count;
+	int i;
+
+	count = WSM_GET32(buf);
+	if (WARN_ON(count <= 0))
+		return -EINVAL;
+	else if (count > 1) {
+		ret = wsm_release_tx_buffer(hw_priv, count - 1);
+		if (ret < 0)
+			return ret;
+		else if (ret > 0)
+			bes2600_bh_wakeup(hw_priv);
+	}
+	priv = cw12xx_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+	if (priv) {
+		bes2600_debug_txed_multi(priv, count);
+		spin_unlock(&priv->vif_lock);
+	}
+	for (i = 0; i < count; ++i) {
+		if(i < count - 1)
+			bes2600_bh_dec_pending_count(hw_priv, 0);
+
+		ret = wsm_tx_confirm(hw_priv, buf, interface_link_id);
+		if (ret)
+			return ret;
+	}
+	return ret;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+
+static int wsm_join_confirm(struct bes2600_common *hw_priv,
+				struct wsm_join *arg,
+				struct wsm_buf *buf)
+{
+	u32 status = WSM_GET32(buf);
+
+	wsm_oper_unlock(hw_priv);
+
+	if (status != WSM_STATUS_SUCCESS) {
+		bes2600_warn(BES2600_DBG_WSM, "wsm_join_confirm ret %u\n", status);
+		return -EINVAL;
+	}
+
+	arg->minPowerLevel = WSM_GET32(buf);
+	arg->maxPowerLevel = WSM_GET32(buf);
+
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+int wsm_join(struct bes2600_common *hw_priv, struct wsm_join *arg,
+		 int if_id)
+/*TODO: combo: make it work per vif.*/
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_oper_lock(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT(buf, &arg->bssid[0], sizeof(arg->bssid));
+	WSM_PUT16(buf, arg->atimWindow);
+	WSM_PUT8(buf, arg->preambleType);
+	WSM_PUT8(buf, arg->probeForJoin);
+	WSM_PUT8(buf, arg->dtimPeriod);
+	WSM_PUT8(buf, arg->flags);
+	WSM_PUT32(buf, arg->ssidLength);
+	WSM_PUT(buf, &arg->ssid[0], sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT32(buf, arg->basicRateSet);
+
+	hw_priv->tx_burst_idx = -1;
+	ret = wsm_cmd_send(hw_priv, buf, arg, 0x000B, WSM_CMD_JOIN_TIMEOUT,
+			   if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_oper_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_bss_params(struct bes2600_common *hw_priv,
+			const struct wsm_set_bss_params *arg,
+			int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, 0);
+	WSM_PUT8(buf, arg->beaconLostCount);
+	WSM_PUT16(buf, arg->aid);
+	WSM_PUT32(buf, arg->operationalRateSet);
+	WSM_PUT32(buf, hw_priv->ht_info.ht_cap.mcs.rx_mask[0] << 14);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0011, WSM_CMD_TIMEOUT,
+			if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_add_key(struct bes2600_common *hw_priv, const struct wsm_add_key *arg,
+			int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, arg, sizeof(*arg));
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x000C, WSM_CMD_TIMEOUT,
+				if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_remove_key(struct bes2600_common *hw_priv,
+		   const struct wsm_remove_key *arg, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->entryIndex);
+	WSM_PUT8(buf, 0);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x000D, WSM_CMD_TIMEOUT,
+			   if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_tx_queue_params(struct bes2600_common *hw_priv,
+				const struct wsm_set_tx_queue_params *arg,
+				u8 id, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u8 queue_id_to_wmm_aci[] = {3, 2, 0, 1};
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, queue_id_to_wmm_aci[id]);
+	WSM_PUT8(buf, 0);
+	WSM_PUT8(buf, arg->ackPolicy);
+	WSM_PUT8(buf, 0);
+	WSM_PUT32(buf, arg->maxTransmitLifetime);
+	WSM_PUT16(buf, arg->allowedMediumTime);
+	WSM_PUT16(buf, 0);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0012, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_edca_params(struct bes2600_common *hw_priv,
+				const struct wsm_edca_params *arg,
+				int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	/* Implemented according to specification. */
+
+	WSM_PUT16(buf, arg->params[3].cwMin);
+	WSM_PUT16(buf, arg->params[2].cwMin);
+	WSM_PUT16(buf, arg->params[1].cwMin);
+	WSM_PUT16(buf, arg->params[0].cwMin);
+
+	WSM_PUT16(buf, arg->params[3].cwMax);
+	WSM_PUT16(buf, arg->params[2].cwMax);
+	WSM_PUT16(buf, arg->params[1].cwMax);
+	WSM_PUT16(buf, arg->params[0].cwMax);
+
+	WSM_PUT8(buf, arg->params[3].aifns);
+	WSM_PUT8(buf, arg->params[2].aifns);
+	WSM_PUT8(buf, arg->params[1].aifns);
+	WSM_PUT8(buf, arg->params[0].aifns);
+
+	WSM_PUT16(buf, arg->params[3].txOpLimit);
+	WSM_PUT16(buf, arg->params[2].txOpLimit);
+	WSM_PUT16(buf, arg->params[1].txOpLimit);
+	WSM_PUT16(buf, arg->params[0].txOpLimit);
+
+	WSM_PUT32(buf, arg->params[3].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[2].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[1].maxReceiveLifetime);
+	WSM_PUT32(buf, arg->params[0].maxReceiveLifetime);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0013, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_switch_channel(struct bes2600_common *hw_priv,
+			   const struct wsm_switch_channel *arg,
+			   int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	wsm_lock_tx(hw_priv);
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->channelMode | 0x80);
+	WSM_PUT8(buf, arg->channelSwitchCount);
+	WSM_PUT16(buf, arg->newChannelNumber);
+
+	hw_priv->channel_switch_in_progress = 1;
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0016, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	if (ret) {
+		wsm_unlock_tx(hw_priv);
+		hw_priv->channel_switch_in_progress = 0;
+	}
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	wsm_unlock_tx(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_pm(struct bes2600_common *hw_priv, const struct wsm_set_pm *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->pmMode);
+	WSM_PUT8(buf, arg->fastPsmIdlePeriod);
+	WSM_PUT8(buf, arg->apPsmChangePeriod);
+	WSM_PUT8(buf, arg->minAutoPsPollPeriod);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0010, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_start(struct bes2600_common *hw_priv, const struct wsm_start *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT8(buf, arg->mode);
+	WSM_PUT8(buf, arg->band);
+	WSM_PUT16(buf, arg->channelNumber);
+	WSM_PUT32(buf, arg->CTWindow);
+	WSM_PUT32(buf, arg->beaconInterval);
+	WSM_PUT8(buf, arg->DTIMPeriod);
+	WSM_PUT8(buf, arg->preambleType);
+	WSM_PUT8(buf, arg->probeDelay);
+	WSM_PUT8(buf, arg->ssidLength);
+	WSM_PUT(buf, arg->ssid, sizeof(arg->ssid));
+	WSM_PUT32(buf, arg->basicRateSet);
+
+	hw_priv->tx_burst_idx = -1;
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0017, WSM_CMD_START_TIMEOUT,
+			if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_start_find(struct bes2600_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0019, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+/* ******************************************************************** */
+
+int wsm_stop_find(struct bes2600_common *hw_priv, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x001A, WSM_CMD_TIMEOUT, if_id);
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+}
+
+/* ******************************************************************** */
+
+int wsm_map_link(struct bes2600_common *hw_priv, const struct wsm_map_link *arg,
+		int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	u16 cmd = 0x001C;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT(buf, &arg->mac_addr[0], sizeof(arg->mac_addr));
+
+	if (is_hardware_cw1250(hw_priv) || is_hardware_cw1260(hw_priv)) {
+		WSM_PUT8(buf, arg->unmap);
+		WSM_PUT8(buf, arg->link_id);
+	} else {
+		cmd |= WSM_TX_LINK_ID(arg->link_id);
+		WSM_PUT16(buf, 0);
+	}
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, cmd, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_update_ie(struct bes2600_common *hw_priv,
+		  const struct wsm_update_ie *arg, int if_id)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	WSM_PUT16(buf, arg->what);
+	WSM_PUT16(buf, arg->count);
+	WSM_PUT(buf, arg->ies, arg->length);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x001B, WSM_CMD_TIMEOUT, if_id);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+
+}
+
+int wsm_epta_cmd(struct bes2600_common *hw_priv, struct wsm_epta_msg *arg)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+	static bool epta_lock_tx = false;
+
+	if (arg->hw_epta_enable & (1 << 11))
+		arg->hw_epta_enable &= ~(3 << 10); // force TDD
+	else if (coex_is_fdd_mode())
+		arg->hw_epta_enable |= (1 << 10); //LMAC_COEX_MODE_FDD
+
+	// TODO: This creates a warning, check if it's really supposed to always be true
+	//if (arg->hw_epta_enable != 3 || arg->hw_epta_enable != 4) { //use for wifi connect
+		///TODO: remove this hack. use hardware in disconnect mode
+	if (coex_is_wifi_inactive()) {
+		arg->wlan_duration = 20000;
+		arg->bt_duration = 80000;
+		arg->hw_epta_enable &= ~(0x3);
+	}
+		// if (coex_is_fdd_mode()) {
+		// 	arg->wlan_duration = 100000;
+		// 	arg->bt_duration = 0;
+		// 	arg->hw_epta_enable |= (1 << 10);
+		// } else {
+		// 	if (coex_is_bt_inactive()) {
+		// 		arg->wlan_duration = 100000;
+		// 		arg->bt_duration = 0;
+		// 		arg->hw_epta_enable = 0;
+		// 	}
+		// }
+	//}
+
+	bes2600_info(BES2600_DBG_WSM, "epta cmd: wlan:%d bt:%d enable:%x",
+		arg->wlan_duration, arg->bt_duration, arg->hw_epta_enable);
+
+	/*
+	Should lock tx queue to avoid frame stuck in firmware if wlan_duration is zero.
+	There is no need to distinguish epta mode as the duration reflects requirements of scenarios
+	*/
+	if (arg->wlan_duration == 0 && !epta_lock_tx) {
+		wsm_lock_tx(hw_priv);
+		epta_lock_tx = true;
+	} else if (epta_lock_tx && arg->wlan_duration != 0) {
+		wsm_unlock_tx(hw_priv);
+		epta_lock_tx = false;
+	}
+
+	wsm_cmd_lock(hw_priv);
+	WSM_PUT32(buf, arg->wlan_duration);
+	WSM_PUT32(buf, arg->bt_duration);
+	WSM_PUT32(buf, arg->hw_epta_enable);
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0029, WSM_CMD_TIMEOUT, 0);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+int wsm_epta_wifi_chan_cmd(struct bes2600_common *hw_priv, uint32_t channel, uint32_t type)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	/* cmd type */
+	WSM_PUT32(buf, BES2600_RF_CMD_CH_INFO);
+
+	WSM_PUT32(buf, channel);
+	WSM_PUT16(buf, type);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0C27, WSM_CMD_TIMEOUT, 0);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+int wsm_wifi_status_cmd(struct bes2600_common *hw_priv, uint32_t status)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	/* cmd type */
+	WSM_PUT32(buf, BES2600_RF_CMD_WIFI_STATUS);
+	WSM_PUT32(buf, status);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0C27, WSM_CMD_TIMEOUT, 0);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+int wsm_cpu_usage_cmd(struct bes2600_common *hw_priv)
+{
+	int ret;
+	struct wsm_buf *buf = &hw_priv->wsm_cmd_buf;
+
+	wsm_cmd_lock(hw_priv);
+
+	/* cmd type */
+	WSM_PUT32(buf, BES2600_RF_CMD_CPU_USAGE);
+
+	ret = wsm_cmd_send(hw_priv, buf, NULL, 0x0C27, WSM_CMD_TIMEOUT, 0);
+
+	wsm_cmd_unlock(hw_priv);
+	return ret;
+
+nomem:
+	wsm_cmd_unlock(hw_priv);
+	return -ENOMEM;
+}
+
+/* ******************************************************************** */
+
+int wsm_set_keepalive_filter(struct bes2600_vif *priv, bool enable)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	priv->rx_filter.keepalive = enable;
+	return wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+}
+
+int wsm_set_probe_responder(struct bes2600_vif *priv, bool enable)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+
+	priv->rx_filter.probeResponder = enable;
+	return wsm_set_rx_filter(hw_priv, &priv->rx_filter, priv->if_id);
+}
+/* ******************************************************************** */
+/* WSM indication events implementation					*/
+
+static int wsm_startup_indication(struct bes2600_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	u16 status;
+	char fw_label[129];
+	static const char * const fw_types[] = {
+		"ETF",
+		"WFM",
+		"WSM",
+		"HI test",
+		"Platform test"
+	};
+
+	hw_priv->wsm_caps.numInpChBufs	= WSM_GET16(buf);
+	hw_priv->wsm_caps.sizeInpChBuf	= WSM_GET16(buf);
+	hw_priv->wsm_caps.hardwareId	= WSM_GET16(buf);
+	hw_priv->wsm_caps.hardwareSubId	= WSM_GET16(buf);
+	status				= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareCap	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareType	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareApiVer	= WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareBuildNumber = WSM_GET16(buf);
+	hw_priv->wsm_caps.firmwareVersion	= WSM_GET16(buf);
+	WSM_GET(buf, &fw_label[0], sizeof(fw_label) - 1);
+	fw_label[sizeof(fw_label) - 1] = 0; /* Do not trust FW too much. */
+
+	if (WARN_ON(status))
+		return -EINVAL;
+
+	if (WARN_ON(hw_priv->wsm_caps.firmwareType > 4))
+		return -EINVAL;
+
+	bes2600_dbg(BES2600_DBG_INIT, "BES2600 WSM init done.\n"
+		"   Input buffers: %d x %d bytes\n"
+		"   Hardware: %d.%d\n"
+		"   %s firmware [%s], ver: %d, build: %d,"
+			" api: %d, cap: 0x%.4X\n",
+		hw_priv->wsm_caps.numInpChBufs,
+		hw_priv->wsm_caps.sizeInpChBuf,
+		hw_priv->wsm_caps.hardwareId,
+		hw_priv->wsm_caps.hardwareSubId,
+		fw_types[hw_priv->wsm_caps.firmwareType],
+		&fw_label[0],
+		hw_priv->wsm_caps.firmwareVersion,
+		hw_priv->wsm_caps.firmwareBuildNumber,
+		hw_priv->wsm_caps.firmwareApiVer,
+		hw_priv->wsm_caps.firmwareCap);
+
+	hw_priv->wsm_caps.firmwareReady = 1;
+
+	wake_up(&hw_priv->wsm_startup_done);
+
+	return 0;
+
+underflow:
+	WARN_ON(1);
+	return -EINVAL;
+}
+
+static int wsm_receive_indication(struct bes2600_common *hw_priv,
+					int interface_link_id,
+					struct wsm_buf *buf,
+					struct sk_buff **skb_p)
+{
+	struct bes2600_vif *priv;
+
+	hw_priv->rx_timestamp = jiffies;
+	if (hw_priv->wsm_cbc.rx) {
+		struct wsm_rx rx;
+		struct ieee80211_hdr *hdr;
+		size_t hdr_len;
+		__le16 fctl;
+
+		rx.status = WSM_GET32(buf);
+		rx.channelNumber = WSM_GET16(buf);
+		rx.rxedRate = WSM_GET8(buf);
+		rx.rcpiRssi = WSM_GET8(buf);
+		rx.flags = WSM_GET32(buf);
+		buf->data+=16; // 2019-10-25, for lmac wsm data ind struct update
+
+		/* TODO:COMBO: Frames received from scanning are received
+		* with interface ID == 2 */
+		if (is_hardware_cw1250(hw_priv) || is_hardware_cw1260(hw_priv)) {
+			if (interface_link_id == CW12XX_GENERIC_IF_ID) {
+				/* Frames received in response to SCAN
+				 * Request */
+				interface_link_id =
+					get_interface_id_scanning(hw_priv);
+				if (interface_link_id == -1) {
+					interface_link_id = hw_priv->roc_if_id;
+				}
+			}
+			/* linkid (peer sta id is encoded in bit 25-28 of
+			   flags field */
+			rx.link_id = ((rx.flags & (0xf << 25)) >> 25);
+			rx.if_id = interface_link_id;
+		} else {
+			rx.link_id = interface_link_id;
+			rx.if_id = 0;
+		}
+
+		if(rx.if_id == -1) {
+			bes2600_info(BES2600_DBG_WSM, "%s: intf is not match\n", __func__);
+			return 0;
+		}
+
+		priv = cw12xx_hwpriv_to_vifpriv(hw_priv, rx.if_id);
+		if (!priv) {
+			bes2600_info(BES2600_DBG_WSM, "%s: NULL priv drop frame\n", __func__);
+			return 0;
+		}
+
+		/* FW Workaround: Drop probe resp or
+		beacon when RSSI is 0 */
+		hdr = (struct ieee80211_hdr *) buf->data;
+
+		if (!rx.rcpiRssi &&
+			(ieee80211_is_probe_resp(hdr->frame_control) ||
+			ieee80211_is_beacon(hdr->frame_control))) {
+			spin_unlock(&priv->vif_lock);
+			return 0;
+		}
+
+		/* If no RSSI subscription has been made,
+		* convert RCPI to RSSI here */
+		if (!priv->cqm_use_rssi)
+			rx.rcpiRssi = rx.rcpiRssi / 2 - 110;
+
+		fctl = *(__le16 *)buf->data;
+		hdr_len = buf->data - buf->begin;
+		skb_pull(*skb_p, hdr_len);
+
+		if (!rx.status &&
+			unlikely(ieee80211_is_deauth(fctl) || ieee80211_is_disassoc(fctl))) {
+			bes2600_dbg(BES2600_DBG_WSM, "rx deauth or disassoc, priv->join_status:%u", priv->join_status);
+			if (priv->join_status == BES2600_JOIN_STATUS_STA &&
+				(ether_addr_equal(hdr->addr3, priv->join_bssid) ||
+				 ether_addr_equal(hdr->addr3, priv->bssid))) {
+				bool ignore = false;
+
+				if (is_multicast_ether_addr(hdr->addr1)) {
+					struct ieee80211_mmie *mmie;
+					bool has_mmie = false;
+					/*
+					 * We may receive broadcast/multicast robust management frame
+					 * when PMF is enabled, in that case, FW has checked the MMIE
+					 * and verified IPN and MIC.
+					 * However, some buggy AP, e.g. Tenda AC6, send broadcast deauth
+					 * with MMIE even when no management frame protection,
+					 * this frame should be ignored and dropped by mac80211.
+					 */
+					if ((*skb_p)->len >= 24 + sizeof(*mmie)) {
+						mmie = (struct ieee80211_mmie *)
+							   ((*skb_p)->data + (*skb_p)->len - sizeof(*mmie));
+						if (mmie->element_id == WLAN_EID_MMIE &&
+							mmie->length == sizeof(*mmie) - 2)
+							has_mmie = true;
+					}
+					bes2600_info(BES2600_DBG_WSM, "[WSM] RX broadcast/multicast deauth: len=%d, has_mmie:%u, pmf=%d\n",
+							(*skb_p)->len, has_mmie, priv->pmf);
+					if (has_mmie ^ priv->pmf)
+						ignore = true;
+				} else if (ether_addr_equal(hdr->addr1, hw_priv->addresses[rx.if_id].addr)) {
+					bool has_protected = ieee80211_has_protected(fctl);
+					bes2600_info(BES2600_DBG_WSM, "[WSM] RX unicast deauth: protected=%d, pmf=%d, connect_in_process=%d\n",
+							has_protected, priv->pmf, atomic_read(&priv->connect_in_process));
+					/*
+					 * We should report unprotected deauth to mac80211 for
+					 * SA query when PMF is enabled, so cannot unjoin here.
+					 * If PMF is disabled, it is unexpected to receive
+					 * a protected unicast deauth.
+					 */
+					if ((has_protected ^ priv->pmf) || atomic_read(&priv->connect_in_process))
+						ignore = true;
+				} else {
+					ignore = true;
+				}
+
+				if (!ignore) {
+					/* Schedule unjoin work */
+					bes2600_info(BES2600_DBG_WSM, "[WSM] Issue unjoin command (RX).\n");
+					wsm_lock_tx_async(hw_priv);
+					if (queue_work(hw_priv->workqueue,
+								   &priv->unjoin_work) <= 0)
+						wsm_unlock_tx(hw_priv);
+				}
+			}
+		}
+		hw_priv->wsm_cbc.rx(priv, &rx, skb_p);
+		if (*skb_p)
+			skb_push(*skb_p, hdr_len);
+		spin_unlock(&priv->vif_lock);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_event_indication(struct bes2600_common *hw_priv,
+				struct wsm_buf *buf,
+				int interface_link_id)
+{
+	int first;
+	struct bes2600_wsm_event *event;
+	struct bes2600_vif *priv;
+
+	if (!is_hardware_cw1250(hw_priv) && !is_hardware_cw1260(hw_priv))
+		interface_link_id = 0;
+
+	priv = cw12xx_hwpriv_to_vifpriv(hw_priv, interface_link_id);
+
+	if (unlikely(!priv)) {
+		bes2600_info(BES2600_DBG_WSM, "[WSM] Not find corresponding interface\n");
+		return 0;
+	}
+
+	if (unlikely(priv->mode == NL80211_IFTYPE_UNSPECIFIED)) {
+		/* STA is stopped. */
+		spin_unlock(&priv->vif_lock);
+		return 0;
+	}
+	spin_unlock(&priv->vif_lock);
+
+	event = kzalloc(sizeof(struct bes2600_wsm_event), GFP_KERNEL);
+
+	event->evt.eventId = __le32_to_cpu(WSM_GET32(buf));
+	event->evt.eventData = __le32_to_cpu(WSM_GET32(buf));
+	event->if_id = interface_link_id;
+
+	bes2600_dbg(BES2600_DBG_WSM, "[WSM] Event: %d(%d)\n",
+		event->evt.eventId, event->evt.eventData);
+
+	spin_lock(&hw_priv->event_queue_lock);
+	first = list_empty(&hw_priv->event_queue);
+	list_add_tail(&event->link, &hw_priv->event_queue);
+	spin_unlock(&hw_priv->event_queue_lock);
+
+	if (first)
+		queue_work(hw_priv->workqueue, &hw_priv->event_handler);
+
+	return 0;
+
+underflow:
+	kfree(event);
+	return -EINVAL;
+}
+
+/* TODO:COMBO:Make this perVIFF once mac80211 support is available */
+static int wsm_channel_switch_indication(struct bes2600_common *hw_priv,
+						struct wsm_buf *buf)
+{
+	wsm_unlock_tx(hw_priv); /* Re-enable datapath */
+	WARN_ON(WSM_GET32(buf));
+
+	hw_priv->channel_switch_in_progress = 0;
+	wake_up(&hw_priv->channel_switch_done);
+
+	if (hw_priv->wsm_cbc.channel_switch)
+		hw_priv->wsm_cbc.channel_switch(hw_priv);
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_set_pm_indication(struct bes2600_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	struct wsm_set_pm_complete arg;
+
+	arg.status = WSM_GET32(buf);
+	arg.psm = WSM_GET8(buf);
+
+	if(arg.status == WSM_STATUS_SUCCESS) {
+		bes2600_pwr_notify_ps_changed(hw_priv, arg.psm);
+	} else {
+		bes2600_err(BES2600_DBG_WSM, "[WSM] PM Ind status:%d psm:%d\n", arg.status, arg.psm);
+	}
+
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_scan_complete_indication(struct bes2600_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	wsm_oper_unlock(hw_priv);
+
+	if (hw_priv->wsm_cbc.scan_complete) {
+		struct wsm_scan_complete arg;
+		arg.status = WSM_GET32(buf);
+		arg.psm = WSM_GET8(buf);
+		arg.numChannels = WSM_GET8(buf);
+		hw_priv->wsm_cbc.scan_complete(hw_priv, &arg);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+static int wsm_find_complete_indication(struct bes2600_common *hw_priv,
+					struct wsm_buf *buf)
+{
+	/* TODO: Implement me. */
+	//STUB();
+	return 0;
+}
+
+static int wsm_suspend_resume_indication(struct bes2600_common *hw_priv,
+					 int interface_link_id,
+					 struct wsm_buf *buf)
+{
+	if (hw_priv->wsm_cbc.suspend_resume) {
+		u32 flags;
+		struct wsm_suspend_resume arg;
+		struct bes2600_vif *priv;
+
+		if (is_hardware_cw1250(hw_priv) ||
+				is_hardware_cw1260(hw_priv)) {
+			int i;
+			arg.if_id = interface_link_id;
+			/* TODO:COMBO: Extract bitmap from suspend-resume
+			* TX indication */
+			bes2600_for_each_vif(hw_priv, priv, i) {
+				if (!priv)
+					continue;
+				if (priv->join_status ==
+						BES2600_JOIN_STATUS_AP) {
+					 arg.if_id = priv->if_id;
+					 break;
+				}
+				arg.link_id = 0;
+			}
+		} else {
+			arg.if_id = 0;
+			arg.link_id = interface_link_id;
+		}
+
+		flags = WSM_GET32(buf);
+		arg.stop = !(flags & 1);
+		arg.multicast = !!(flags & 8);
+		arg.queue = (flags >> 1) & 3;
+
+		priv = cw12xx_hwpriv_to_vifpriv(hw_priv, arg.if_id);
+		if (unlikely(!priv)) {
+			bes2600_dbg(BES2600_DBG_WSM, "[WSM] suspend-resume indication"
+				   " for removed interface!\n");
+			return 0;
+		}
+		hw_priv->wsm_cbc.suspend_resume(priv, &arg);
+		spin_unlock(&priv->vif_lock);
+	}
+	return 0;
+
+underflow:
+	return -EINVAL;
+}
+
+/**
+ * signaling cmd confirm.
+ */
+
+int wsm_driver_rf_cmd_confirm(struct bes2600_common *hw_priv, void *arg, struct wsm_buf *buf)
+{
+	int ret = 0;
+	u32 cmd_type;
+	struct wsm_mcu_hdr *msg_hdr = (struct wsm_mcu_hdr *)(buf->begin);
+
+	cmd_type = __le32_to_cpu(msg_hdr->cmd_type);
+	buf->data += sizeof(struct wsm_mcu_hdr) - sizeof(struct wsm_hdr);
+
+	switch (cmd_type) {
+	case BES2600_RF_CMD_CALI_TXT_TO_FLASH:
+		ret = WSM_GET32(buf);
+		break;
+	default:
+		break;
+	}
+
+	return ret;
+
+underflow:
+	return -EINVAL;
+}
+
+/* ******************************************************************** */
+/* WSM TX								*/
+
+int wsm_cmd_send(struct bes2600_common *hw_priv,
+		 struct wsm_buf *buf,
+		 void *arg, u16 cmd, long tmo, int if_id)
+{
+	size_t buf_len = buf->data - buf->begin;
+	int ret;
+
+	if (cmd == 0x0006) /* Write MIB */
+		bes2600_dbg(BES2600_DBG_WSM, "[WSM] >>> 0x%.4X [MIB: 0x%.4X] (%lu)\n",
+			cmd, __le16_to_cpu(((__le16 *)buf->begin)[2]),
+			(long unsigned)buf_len);
+	else
+		bes2600_dbg(BES2600_DBG_WSM, "[WSM] >>> 0x%.4X (%lu)\n", cmd, (long unsigned)buf_len);
+
+	/* Fill HI message header */
+	/* BH will add sequence number */
+
+	/* TODO:COMBO: Add if_id from  to the WSM header */
+	/* if_id == -1 indicates that command is HW specific,
+	 * eg. wsm_configuration which is called during driver initialzation
+	 *  (mac80211 .start callback called when first ifce is created. )*/
+
+	/* send hw specific commands on if 0 */
+	if (if_id == -1)
+		if_id = 0;
+
+	((__le16 *)buf->begin)[0] = __cpu_to_le16(buf_len);
+	if (IS_DRIVER_TO_MCU_CMD(cmd))
+		((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd);
+	else
+		((__le16 *)buf->begin)[1] = __cpu_to_le16(cmd |
+					((is_hardware_cw1250(hw_priv)|| is_hardware_cw1260(hw_priv)) ?
+						(if_id << 6) : 0));
+
+	if (buf->end >= buf->data + 4)
+		*(u32 *)buf->data = (u32)jiffies_to_msecs(jiffies);
+
+	spin_lock(&hw_priv->wsm_cmd.lock);
+	BUG_ON(hw_priv->wsm_cmd.ptr);
+	hw_priv->wsm_cmd.done = 0;
+	hw_priv->wsm_cmd.ptr = buf->begin;
+	hw_priv->wsm_cmd.len = buf_len;
+	hw_priv->wsm_cmd.arg = arg;
+	hw_priv->wsm_cmd.cmd = cmd;
+	spin_unlock(&hw_priv->wsm_cmd.lock);
+	bes2600_tx_loop_record_wsm_cmd(hw_priv, hw_priv->wsm_cmd.ptr);
+
+	bes2600_bh_wakeup(hw_priv);
+
+	if (unlikely(hw_priv->bh_error)) {
+		/* Do not wait for timeout if BH is dead. Exit immediately. */
+		ret = 0;
+	} else {
+		long rx_timestamp;
+		long wsm_cmd_starttime = jiffies;
+		long wsm_cmd_runtime;
+		long wsm_cmd_max_tmo = WSM_CMD_DEFAULT_TIMEOUT;
+
+		/* Give start cmd a little more time */
+		if (tmo == WSM_CMD_START_TIMEOUT)
+			wsm_cmd_max_tmo = WSM_CMD_START_TIMEOUT;
+		/* Firmware prioritizes data traffic over control confirm.
+		 * Loop below checks if data was RXed and increases timeout
+		 * accordingly. */
+		do {
+			/* It's safe to use unprotected access to
+			 * wsm_cmd.done here */
+			ret = wait_event_timeout(
+					hw_priv->wsm_cmd_wq,
+					hw_priv->wsm_cmd.done, tmo);
+			rx_timestamp = jiffies - hw_priv->rx_timestamp;
+			wsm_cmd_runtime = jiffies - wsm_cmd_starttime;
+			if (unlikely(rx_timestamp < 0) || wsm_cmd_runtime < 0)
+				rx_timestamp = tmo + 1;
+		} while (!ret && rx_timestamp <= tmo &&
+					wsm_cmd_runtime < wsm_cmd_max_tmo);
+	}
+
+	if (unlikely(ret == 0)) {
+		u16 raceCheck;
+
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		raceCheck = hw_priv->wsm_cmd.cmd;
+		hw_priv->wsm_cmd.arg = NULL;
+		hw_priv->wsm_cmd.ptr = NULL;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+
+		/* Race condition check to make sure _confirm is not called
+		 * after exit of _send */
+		if (raceCheck == 0xFFFF) {
+			/* If wsm_handle_rx got stuck in _confirm we will hang
+			 * system there. It's better than silently currupt
+			 * stack or heap, isn't it? */
+			if (wait_event_timeout(
+			    hw_priv->wsm_cmd_wq,
+			    hw_priv->wsm_cmd.done,
+			    WSM_CMD_LAST_CHANCE_TIMEOUT) <= 0)
+			{
+				bes2600_err(BES2600_DBG_WSM, "[WSM] wsm.c:1530 error: race check failed\n");
+			}
+		}
+
+		/* Kill BH thread to report the error to the top layer. */
+		//hw_priv->bh_error = 1;
+		wake_up(&hw_priv->bh_wq);
+		ret = -ETIMEDOUT;
+	} else {
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		hw_priv->wsm_cmd.arg = NULL;
+		hw_priv->wsm_cmd.ptr = NULL;
+		BUG_ON(!hw_priv->wsm_cmd.done);
+		ret = hw_priv->wsm_cmd.ret;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	}
+	bes2600_tx_loop_clear_wsm_cmd(hw_priv);
+	wsm_buf_reset(buf);
+	return ret;
+}
+
+/* ******************************************************************** */
+/* WSM TX port control							*/
+
+void wsm_lock_tx(struct bes2600_common *hw_priv)
+{
+	wsm_cmd_lock(hw_priv);
+	if (atomic_add_return(1, &hw_priv->tx_lock) == 1) {
+		if (wsm_flush_tx(hw_priv))
+			bes2600_dbg(BES2600_DBG_WSM, "[WSM] TX is locked.\n");
+	}
+	wsm_cmd_unlock(hw_priv);
+}
+
+void wsm_vif_lock_tx(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = priv->hw_priv;
+
+	wsm_cmd_lock(hw_priv);
+	if (atomic_add_return(1, &hw_priv->tx_lock) == 1) {
+		if (wsm_vif_flush_tx(priv))
+			bes2600_dbg(BES2600_DBG_WSM, "[WSM] TX is locked for"
+					" if_id %d.\n", priv->if_id);
+	}
+	wsm_cmd_unlock(hw_priv);
+}
+
+void wsm_lock_tx_async(struct bes2600_common *hw_priv)
+{
+	if (atomic_add_return(1, &hw_priv->tx_lock) == 1)
+		bes2600_dbg(BES2600_DBG_WSM, "[WSM] TX is locked (async).\n");
+}
+
+bool wsm_flush_tx(struct bes2600_common *hw_priv)
+{
+	unsigned long timestamp = jiffies;
+	bool pending = false;
+	long timeout;
+	int i;
+
+	/* Flush must be called with TX lock held. */
+	BUG_ON(!atomic_read(&hw_priv->tx_lock));
+
+	/* First check if we really need to do something.
+	 * It is safe to use unprotected access, as hw_bufs_used
+	 * can only decrements. */
+
+	if (!hw_priv->hw_bufs_used)
+		return true;
+
+	if (hw_priv->bh_error) {
+		/* In case of failure do not wait for magic. */
+		bes2600_err(BES2600_DBG_WSM, "[WSM] Fatal error occured, "
+				"will not flush TX.\n");
+		return false;
+	} else {
+		/* Get a timestamp of "oldest" frame */
+		for (i = 0; i < 4; ++i)
+			pending |= bes2600_queue_get_xmit_timestamp(
+					&hw_priv->tx_queue[i],
+					&timestamp, CW12XX_ALL_IFS,
+					0xffffffff);
+		/* It is allowed to lock TX with only a command in the pipe. */
+		if (!pending)
+			return true;
+
+		timeout = timestamp + WSM_CMD_LAST_CHANCE_TIMEOUT - jiffies;
+		if (timeout < 0 || wait_event_timeout(hw_priv->bh_evt_wq,
+				!hw_priv->hw_bufs_used,
+				timeout) <= 0) {
+			/* Hmmm... Not good. Frame had stuck in firmware. */
+			bes2600_chrdev_wifi_force_close(hw_priv, true);
+		}
+
+		/* Ok, everything is flushed. */
+		return true;
+	}
+}
+
+bool wsm_vif_flush_tx(struct bes2600_vif *priv)
+{
+	struct bes2600_common *hw_priv = priv->hw_priv;
+	unsigned long timestamp = jiffies;
+	long timeout;
+	int i;
+	int if_id = priv->if_id;
+
+
+	/* Flush must be called with TX lock held. */
+	BUG_ON(!atomic_read(&hw_priv->tx_lock));
+
+	/* First check if we really need to do something.
+	 * It is safe to use unprotected access, as hw_bufs_used
+	 * can only decrements. */
+
+	if (!hw_priv->hw_bufs_used_vif[priv->if_id])
+		return true;
+
+	if (hw_priv->bh_error) {
+		/* In case of failure do not wait for magic. */
+		bes2600_err(BES2600_DBG_WSM,  "[WSM] Fatal error occured, "
+				"will not flush TX.\n");
+		return false;
+	} else {
+		/* Get a timestamp of "oldest" frame */
+		for (i = 0; i < 4; ++i)
+			bes2600_queue_get_xmit_timestamp(
+					&hw_priv->tx_queue[i],
+					&timestamp, if_id,
+					0xffffffff);
+		/* It is allowed to lock TX with only a command in the pipe. */
+		if (!hw_priv->hw_bufs_used_vif[if_id])
+			return true;
+
+		timeout = timestamp + WSM_CMD_LAST_CHANCE_TIMEOUT - jiffies;
+		if (timeout < 0 || wait_event_timeout(hw_priv->bh_evt_wq,
+				!hw_priv->hw_bufs_used_vif[if_id],
+				timeout) <= 0) {
+
+			/* Hmmm... Not good. Frame had stuck in firmware. */
+			bes2600_chrdev_wifi_force_close(hw_priv, true);
+		}
+
+		/* Ok, everything is flushed. */
+		return true;
+	}
+}
+
+
+void wsm_unlock_tx(struct bes2600_common *hw_priv)
+{
+	int tx_lock;
+	if (hw_priv->bh_error)
+		bes2600_err(BES2600_DBG_WSM, "fatal error occured, unlock is unsafe\n");
+	else {
+		tx_lock = atomic_sub_return(1, &hw_priv->tx_lock);
+		if (tx_lock < 0) {
+			BUG_ON(1);
+		} else if (tx_lock == 0) {
+			bes2600_bh_wakeup(hw_priv);
+			bes2600_dbg(BES2600_DBG_WSM, "[WSM] TX is unlocked.\n");
+		}
+	}
+}
+
+/* ******************************************************************** */
+/* WSM RX								*/
+
+int wsm_handle_exception(struct bes2600_common *hw_priv, u8 *data, size_t len)
+{
+	struct wsm_buf buf;
+	u32 reason;
+	u32 reg[18];
+	char fname[48];
+	size_t i;
+
+	static const char * const reason_str[] = {
+		"undefined instruction",
+		"prefetch abort",
+		"data abort",
+		"unknown error",
+	};
+
+	buf.begin = buf.data = data;
+	buf.end = &buf.begin[len];
+
+	reason = WSM_GET32(&buf);
+	for (i = 0; i < ARRAY_SIZE(reg); ++i)
+		reg[i] = WSM_GET32(&buf);
+	WSM_GET(&buf, fname, sizeof(fname));
+
+	if (reason < 4)
+		wiphy_err(hw_priv->hw->wiphy,
+			"Firmware exception: %s.\n",
+			reason_str[reason]);
+	else
+		wiphy_err(hw_priv->hw->wiphy,
+			"Firmware assert at %.*s, line %d\n",
+			(int)sizeof(fname), fname, (int)reg[1]);
+
+	for (i = 0; i < 12; i += 4)
+		wiphy_err(hw_priv->hw->wiphy,
+			"R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X, R%d: 0x%.8X,\n",
+			(int)i + 0, reg[i + 0], (int)i + 1, reg[i + 1],
+			(int)i + 2, reg[i + 2], (int)i + 3, reg[i + 3]);
+	wiphy_err(hw_priv->hw->wiphy,
+		"R12: 0x%.8X, SP: 0x%.8X, LR: 0x%.8X, PC: 0x%.8X,\n",
+		reg[i + 0], reg[i + 1], reg[i + 2], reg[i + 3]);
+	i += 4;
+	wiphy_err(hw_priv->hw->wiphy,
+		"CPSR: 0x%.8X, SPSR: 0x%.8X\n",
+		reg[i + 0], reg[i + 1]);
+
+	print_hex_dump_bytes("R1: ", DUMP_PREFIX_NONE,
+		fname, sizeof(fname));
+	return 0;
+
+underflow:
+	wiphy_err(hw_priv->hw->wiphy,
+		"Firmware exception.\n");
+	print_hex_dump_bytes("Exception: ", DUMP_PREFIX_NONE,
+		data, len);
+	return -EINVAL;
+}
+EXPORT_SYMBOL(wsm_handle_exception);
+
+int wsm_bt_ts_request(struct bes2600_common *hw_priv, struct wsm_buf *buf)
+{
+	uint32_t type;
+
+	type = __le32_to_cpu(((struct wsm_mcu_hdr *)(buf->begin))->cmd_type);
+	bbt_change_current_status(hw_priv, type);
+	return 0;
+}
+
+int wsm_handle_rx(struct bes2600_common *hw_priv, int id,
+		  struct wsm_hdr *wsm, struct sk_buff **skb_p)
+{
+	int ret = 0;
+	struct wsm_buf wsm_buf;
+//	struct bes2600_vif *priv = NULL;
+//	int i = 0;
+	int interface_link_id = (id >> 6) & 0x0F;
+	u32 ind_confirm_label = 0x0;  /* wsm to mcu cmd ind & cnfirm label */
+
+	/* Strip link id. */
+	id &= ~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+
+	wsm_buf.begin = (u8 *)&wsm[0];
+	wsm_buf.data = (u8 *)&wsm[1];
+	wsm_buf.end = &wsm_buf.begin[__le32_to_cpu(wsm->len)];
+
+	bes2600_dbg(BES2600_DBG_WSM, "[WSM] <<< 0x%.4X (%ld)\n", id,
+			(long)(wsm_buf.end - wsm_buf.begin));
+
+	if (IS_DRIVER_TO_MCU_CMD(id))
+		ind_confirm_label = __le32_to_cpu(((struct wsm_mcu_hdr *)wsm)->handle_label);
+
+	if (id == 0x0C30) {
+		ret = wsm_bt_ts_request(hw_priv, &wsm_buf);
+	} else if (id == 0x404) {
+		ret = wsm_tx_confirm(hw_priv, &wsm_buf, interface_link_id);
+	} else if (id == 0x41E) {
+		ret = wsm_multi_tx_confirm(hw_priv, &wsm_buf,
+					   interface_link_id);
+	} else if (WSM_CONFIRM_CONDITION(id, ind_confirm_label)) {
+		void *wsm_arg;
+		u16 wsm_cmd;
+
+		/* Do not trust FW too much. Protection against repeated
+		 * response and race condition removal (see above). */
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		wsm_arg = hw_priv->wsm_cmd.arg;
+		wsm_cmd = hw_priv->wsm_cmd.cmd &
+				~WSM_TX_LINK_ID(WSM_TX_LINK_ID_MAX);
+		hw_priv->wsm_cmd.cmd = 0xFFFF;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+
+		if (((id & 0x0f00) == 0x0400) && WARN_ON((id & ~0x0400) != wsm_cmd)) {
+			/* Note that any non-zero is a fatal retcode. */
+			ret = -EINVAL;
+			goto out;
+		}
+
+		switch (id) {
+		case 0x0409:
+			/* Note that wsm_arg can be NULL in case of timeout in
+			 * wsm_cmd_send(). */
+			if (likely(wsm_arg))
+				ret = wsm_configuration_confirm(hw_priv,
+								wsm_arg,
+								&wsm_buf);
+			break;
+		case 0x0405:
+			if (likely(wsm_arg))
+				ret = wsm_read_mib_confirm(hw_priv, wsm_arg,
+								&wsm_buf);
+			break;
+		case 0x0406:
+			if (likely(wsm_arg))
+				ret = wsm_write_mib_confirm(hw_priv, wsm_arg,
+								&wsm_buf,
+								interface_link_id);
+			break;
+		case 0x040B:
+			if (likely(wsm_arg))
+				ret = wsm_join_confirm(hw_priv, wsm_arg,
+							   &wsm_buf);
+			break;
+		case 0x0407: /* start-scan */
+		case 0x0408: /* stop-scan */
+		case 0x040A: /* wsm_reset */
+		case 0x040C: /* add_key */
+		case 0x040D: /* remove_key */
+		case 0x0410: /* wsm_set_pm */
+		case 0x0411: /* set_bss_params */
+		case 0x0412: /* set_tx_queue_params */
+		case 0x0413: /* set_edca_params */
+		case 0x0416: /* switch_channel */
+		case 0x0417: /* start */
+		case 0x0418: /* beacon_transmit */
+		case 0x0419: /* start_find */
+		case 0x041A: /* stop_find */
+		case 0x041B: /* update_ie */
+		case 0x041C: /* map_link */
+		case 0x0429: /* epta */
+			WARN_ON(wsm_arg != NULL);
+			ret = wsm_generic_confirm(hw_priv, wsm_arg, &wsm_buf);
+			if (ret)
+				wiphy_warn(hw_priv->hw->wiphy,
+					"wsm_generic_confirm "
+					"failed for request 0x%.4X.\n",
+					id & ~0x0400);
+			break;
+		case 0x0424: /* wifi sleep disable */
+			break;
+		default:
+			bes2600_err(BES2600_DBG_WSM, "[WSM] wsm.c:1867 error: invalid response %i\n", id);
+		}
+
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		hw_priv->wsm_cmd.ret = ret;
+		hw_priv->wsm_cmd.done = 1;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+		ret = 0; /* Error response from device should ne stop BH. */
+
+		wake_up(&hw_priv->wsm_cmd_wq);
+	} else if ((id & 0x0f00) == 0x0800) {
+		switch (id) {
+		case 0x0801:
+			ret = wsm_startup_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0804:
+			ret = wsm_receive_indication(hw_priv, interface_link_id,
+					&wsm_buf, skb_p);
+			break;
+		case 0x0805:
+			ret = wsm_event_indication(hw_priv, &wsm_buf,
+					interface_link_id);
+			break;
+		case 0x080A:
+			ret = wsm_channel_switch_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0809:
+			ret = wsm_set_pm_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x0806:
+			ret = wsm_scan_complete_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x080B:
+			ret = wsm_find_complete_indication(hw_priv, &wsm_buf);
+			break;
+		case 0x080C:
+			ret = wsm_suspend_resume_indication(hw_priv,
+					interface_link_id, &wsm_buf);
+			break;
+		default:
+			//STUB();
+			break;
+		}
+	} else if (WSM_TO_MCU_CMD_IND_CONDITION(id, ind_confirm_label)) {
+		switch (id) {
+		default:
+			break;
+		}
+	} else {
+		WARN_ON(1);
+		ret = -EINVAL;
+	}
+out:
+	return ret;
+}
+EXPORT_SYMBOL(wsm_handle_rx);
+
+static bool wsm_handle_tx_data(struct bes2600_vif *priv,
+				   const struct wsm_tx *wsm,
+				   const struct ieee80211_tx_info *tx_info,
+				   struct bes2600_txpriv *txpriv,
+				   struct bes2600_queue *queue)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	struct bes2600_vif *p2p_if_vif = NULL;
+	bool handled = false;
+	const struct ieee80211_hdr *frame =
+		(struct ieee80211_hdr *) &((u8 *)wsm)[txpriv->offset];
+	__le16 fctl = frame->frame_control;
+	enum {
+		doProbe,
+		doDrop,
+		doJoin,
+		doOffchannel,
+		doWep,
+		doTx,
+	} action = doTx;
+
+	hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	if (priv->if_id == CW12XX_GENERIC_IF_ID)
+		p2p_if_vif = __cw12xx_hwpriv_to_vifpriv(hw_priv, 2);
+	frame =  (struct ieee80211_hdr *) &((u8 *)wsm)[txpriv->offset];
+	fctl  = frame->frame_control;
+
+	switch (priv->mode) {
+	case NL80211_IFTYPE_P2P_DEVICE:
+	case NL80211_IFTYPE_STATION:
+		if (unlikely((priv->join_status == BES2600_JOIN_STATUS_STA) &&
+			ieee80211_is_nullfunc(fctl))) {
+			spin_lock(&priv->bss_loss_lock);
+			if (priv->bss_loss_status == BES2600_BSS_LOSS_CHECKING) {
+				priv->bss_loss_status = BES2600_BSS_LOSS_CONFIRMING;
+				priv->bss_loss_confirm_id = wsm->packetID;
+			}
+			spin_unlock(&priv->bss_loss_lock);
+		} else if (unlikely(
+			(priv->join_status <= BES2600_JOIN_STATUS_MONITOR) ||
+			memcmp(frame->addr1, priv->join_bssid,
+				sizeof(priv->join_bssid)))) {
+			if (p2p_if_vif && (p2p_if_vif->join_status >
+				BES2600_JOIN_STATUS_MONITOR)
+					&& (priv->join_status
+						< BES2600_JOIN_STATUS_MONITOR)) {
+				/*
+					* Post group formation, frame transmission on p2p0
+					* interafce should not use offchannel/generic channel.
+					* Instead, the frame should be transmitted on interafce
+					* 1. This is needed by wsc fw.
+					*/
+				action = doTx;
+				txpriv->raw_if_id = 0;
+			} else if (ieee80211_is_auth(fctl))
+				action = doJoin;
+			else if (ieee80211_is_probe_req(fctl))
+				action = doTx;
+			else if (memcmp(frame->addr1, priv->join_bssid,
+					sizeof(priv->join_bssid)) &&
+					(priv->join_status ==
+					BES2600_JOIN_STATUS_STA) &&
+					(ieee80211_is_data(fctl))) {
+				action = doDrop;
+			}
+			else if (priv->join_status >=
+					BES2600_JOIN_STATUS_MONITOR)
+				action = doTx;
+			else if (get_interface_id_scanning(hw_priv) != -1) {
+				wiphy_warn(priv->hw->wiphy,
+					"Scan ONGOING dropping offchannel"
+					" eligible frame.\n");
+				action = doDrop;
+			}
+			else
+				action = doTx;
+		}
+		break;
+	case NL80211_IFTYPE_AP:
+		if (unlikely(!priv->join_status))
+			action = doDrop;
+		else if (unlikely(!(BIT(txpriv->raw_link_id) &
+				(BIT(0) | priv->link_id_map)))) {
+			wiphy_warn(priv->hw->wiphy,
+					"A frame with expired link id "
+					"is dropped.\n");
+			action = doDrop;
+		}
+		if (bes2600_queue_get_generation(wsm->packetID) >
+				BES2600_MAX_REQUEUE_ATTEMPTS) {
+			/* HACK!!! WSM324 firmware has tendency to requeue
+				* multicast frames in a loop, causing performance
+				* drop and high power consumption of the driver.
+				* In this situation it is better just to drop
+				* the problematic frame. */
+			wiphy_warn(priv->hw->wiphy,
+					"Too many attempts "
+					"to requeue a frame. "
+					"Frame is dropped.\n");
+			action = doDrop;
+		}
+		break;
+	case NL80211_IFTYPE_ADHOC:
+	case NL80211_IFTYPE_MESH_POINT:
+		//STUB();
+	case NL80211_IFTYPE_MONITOR:
+	default:
+		action = doDrop;
+		break;
+	}
+
+	if (action == doTx) {
+		if (unlikely(ieee80211_is_probe_req(fctl))) {
+			action = doProbe;
+		} else if ((fctl & __cpu_to_le32(IEEE80211_FCTL_PROTECTED)) &&
+			tx_info->control.hw_key &&
+			unlikely(tx_info->control.hw_key->keyidx !=
+					priv->wep_default_key_id) &&
+			(tx_info->control.hw_key->cipher ==
+					WLAN_CIPHER_SUITE_WEP40 ||
+			 tx_info->control.hw_key->cipher ==
+					WLAN_CIPHER_SUITE_WEP104))
+			action = doWep;
+	}
+
+	switch (action) {
+	case doProbe:
+	{
+		/* An interesting FW "feature". Device filters
+		 * probe responses.
+		 * The easiest way to get it back is to convert
+		 * probe request into WSM start_scan command. */
+		bes2600_dbg(BES2600_DBG_WSM,
+			"[WSM] Convert probe request to scan.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		queue_delayed_work(hw_priv->workqueue,
+				&hw_priv->scan.probe_work, 0);
+		handled = true;
+	}
+	break;
+	case doDrop:
+	{
+		/* See detailed description of "join" below.
+		 * We are dropping everything except AUTH in non-joined mode. */
+		bes2600_err(BES2600_DBG_WSM, "[WSM] Drop frame (0x%.4X).\n", fctl);
+		BUG_ON(bes2600_queue_remove(queue,
+			__le32_to_cpu(wsm->packetID)));
+		handled = true;
+	}
+	break;
+	case doJoin:
+	{
+		/* There is one more interesting "feature"
+		 * in FW: it can't do RX/TX before "join".
+		 * "Join" here is not an association,
+		 * but just a syncronization between AP and STA.
+		 * priv->join_status is used only in bh thread and does
+		 * not require protection */
+		bes2600_info(BES2600_DBG_WSM, "[WSM] Issue join command.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+
+		if (hw_priv->channel->band != NL80211_BAND_2GHZ)
+			bwifi_change_current_status(hw_priv, BWIFI_STATUS_CONNECTING_5G);
+		else
+			bwifi_change_current_status(hw_priv, BWIFI_STATUS_CONNECTING);
+		if (queue_work(hw_priv->workqueue, &priv->join_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doOffchannel:
+	{
+		bes2600_info(BES2600_DBG_WSM, "[WSM] Offchannel TX request.\n");
+		wsm_lock_tx_async(hw_priv);
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		if (queue_work(hw_priv->workqueue, &priv->offchannel_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doWep:
+	{
+		bes2600_info(BES2600_DBG_WSM,  "[WSM] Issue set_default_wep_key.\n");
+		wsm_lock_tx_async(hw_priv);
+		priv->wep_default_key_id = tx_info->control.hw_key->keyidx;
+		hw_priv->pending_frame_id = __le32_to_cpu(wsm->packetID);
+		if (queue_work(hw_priv->workqueue, &priv->wep_key_work) <= 0)
+			wsm_unlock_tx(hw_priv);
+		handled = true;
+	}
+	break;
+	case doTx:
+	{
+#if 0
+		/* Kept for history. If you want to implement wsm->more,
+		 * make sure you are able to send a frame after that. */
+		wsm->more = (count > 1) ? 1 : 0;
+		if (wsm->more) {
+			/* HACK!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
+			 * It's undocumented in WSM spec, but BES2600 hangs
+			 * if 'more' is set and no TX is performed due to TX
+			 * buffers limitation. */
+			if (priv->hw_bufs_used + 1 ==
+					priv->wsm_caps.numInpChBufs)
+				wsm->more = 0;
+		}
+
+		/* BUG!!! FIXME: we can't use 'more' at all: we don't know
+		 * future. It could be a request from upper layer with TX lock
+		 * requirements (scan, for example). If "more" is set device
+		 * will not send data and wsm_tx_lock() will fail...
+		 * It's not obvious how to fix this deadlock. Any ideas?
+		 * As a workaround more is set to 0. */
+		wsm->more = 0;
+#endif /* 0 */
+
+		if (ieee80211_is_deauth(fctl) &&
+				priv->mode != NL80211_IFTYPE_AP) {
+			/* Shedule unjoin work */
+			bes2600_info(BES2600_DBG_WSM, "[WSM] Issue unjoin command (TX).\n");
+			atomic_set(&priv->connect_in_process, 0);
+
+			bwifi_change_current_status(hw_priv, BWIFI_STATUS_DISCONNECTING);
+			wsm_lock_tx_async(hw_priv);
+			if (queue_work(hw_priv->workqueue,
+					&priv->unjoin_work) <= 0)
+				wsm_unlock_tx(hw_priv);
+		}
+	}
+	break;
+	}
+	return handled;
+}
+
+static int bes2600_get_prio_queue(struct bes2600_vif *priv,
+				 u32 link_id_map, int *total)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	static u32 urgent;
+	struct wsm_edca_queue_params *edca;
+	unsigned score, best = -1;
+	int winner = -1;
+	int queued;
+	int i;
+	urgent = BIT(priv->link_id_after_dtim) | BIT(priv->link_id_uapsd);
+
+	/* search for a winner using edca params */
+	for (i = 0; i < 4; ++i) {
+		queued = bes2600_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[i],
+				link_id_map);
+		if (!queued)
+			continue;
+		*total += queued;
+		edca = &priv->edca.params[i];
+		score = ((edca->aifns + edca->cwMin) << 16) +
+				(edca->cwMax - edca->cwMin) *
+				(get_random_u32() & 0xFFFF);
+		if (score < best && (winner < 0 || i != 3)) {
+			best = score;
+			winner = i;
+		}
+	}
+
+	/* override winner if bursting */
+	if (winner >= 0 && hw_priv->tx_burst_idx >= 0 &&
+			winner != hw_priv->tx_burst_idx &&
+			!bes2600_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[winner],
+				link_id_map & urgent) &&
+			bes2600_queue_get_num_queued(priv,
+				&hw_priv->tx_queue[hw_priv->tx_burst_idx],
+				link_id_map))
+		winner = hw_priv->tx_burst_idx;
+
+	return winner;
+}
+
+static int wsm_get_tx_queue_and_mask(struct bes2600_vif *priv,
+					 struct bes2600_queue **queue_p,
+					 u32 *tx_allowed_mask_p,
+					 bool *more)
+{
+	struct bes2600_common *hw_priv = cw12xx_vifpriv_to_hwpriv(priv);
+	int idx;
+	u32 tx_allowed_mask;
+	int total = 0;
+
+	/* Search for a queue with multicast frames buffered */
+	if (priv->tx_multicast) {
+		tx_allowed_mask = BIT(priv->link_id_after_dtim);
+		idx = bes2600_get_prio_queue(priv,
+				tx_allowed_mask, &total);
+		if (idx >= 0) {
+			*more = total > 1;
+			goto found;
+		}
+	}
+
+	/* Search for unicast traffic */
+	tx_allowed_mask = ~priv->sta_asleep_mask;
+	tx_allowed_mask |= BIT(priv->link_id_uapsd);
+	if (priv->sta_asleep_mask) {
+		tx_allowed_mask |= priv->pspoll_mask;
+		tx_allowed_mask &= ~BIT(priv->link_id_after_dtim);
+	} else {
+		tx_allowed_mask |= BIT(priv->link_id_after_dtim);
+	}
+	idx = bes2600_get_prio_queue(priv,
+			tx_allowed_mask, &total);
+	if (idx < 0)
+		return -ENOENT;
+
+found:
+	*queue_p = &hw_priv->tx_queue[idx];
+	*tx_allowed_mask_p = tx_allowed_mask;
+	return 0;
+}
+
+int wsm_get_tx(struct bes2600_common *hw_priv, u8 **data,
+		   size_t *tx_len, int *burst, int *vif_selected)
+{
+	struct wsm_tx *wsm = NULL;
+	struct ieee80211_tx_info *tx_info;
+	struct bes2600_queue *queue = NULL;
+	int queue_num;
+	u32 tx_allowed_mask = 0;
+	struct bes2600_txpriv *txpriv = NULL;
+	int first = 1;
+	/*
+	 * Count was intended as an input for wsm->more flag.
+	 * During implementation it was found that wsm->more
+	 * is not usable, see details above. It is kept just
+	 * in case you would like to try to implement it again.
+	 */
+	int count = 0;
+	int if_pending = CW12XX_MAX_VIFS - 1;
+
+	/* More is used only for broadcasts. */
+	bool more = false;
+
+	count = bes2600_itp_get_tx(hw_priv, data, tx_len, burst);
+	if (count)
+		return count;
+
+	if (hw_priv->wsm_cmd.ptr) {
+		++count;
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		BUG_ON(!hw_priv->wsm_cmd.ptr);
+		*data = hw_priv->wsm_cmd.ptr;
+		*tx_len = hw_priv->wsm_cmd.len;
+		*burst = 1;
+		*vif_selected = -1;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	} else {
+		for (;;) {
+			int ret;
+			struct bes2600_vif *priv;
+			if (atomic_add_return(0, &hw_priv->tx_lock))
+				break;
+			/* Keep one buffer reserved for commands. Note
+			   that, hw_bufs_used has already been incremented
+			   before reaching here. */
+			if (hw_priv->hw_bufs_used >=
+					hw_priv->wsm_caps.numInpChBufs)
+				break;
+			if (first) {
+				first = 0;
+				hw_priv->if_id_selected = 0;
+			}
+			priv = wsm_get_interface_for_tx(hw_priv);
+			/* go to next interface ID to select next packet */
+			hw_priv->if_id_selected++;
+			if(hw_priv->if_id_selected > 2)
+				hw_priv->if_id_selected = 0;
+
+			/* There might be no interface before add_interface
+			 * call */
+			if (!priv) {
+				if (if_pending) {
+					if_pending--;
+					continue;
+				}
+				break;
+			}
+
+			/* This can be removed probably: bes2600_vif will not
+			 * be in hw_priv->vif_list (as returned from
+			 * wsm_get_interface_for_tx) until it's fully
+			 * enabled, so statement above will take case of that*/
+			if (!atomic_read(&priv->enabled)) {
+				spin_unlock(&priv->vif_lock);
+				break;
+			}
+
+			/* TODO:COMBO: Find the next interface for which
+			* packet needs to be found */
+			spin_lock_bh(&priv->ps_state_lock);
+			ret = wsm_get_tx_queue_and_mask(priv, &queue,
+					&tx_allowed_mask, &more);
+			queue_num = queue - hw_priv->tx_queue;
+
+			if (priv->buffered_multicasts &&
+					(ret || !more) &&
+					(priv->tx_multicast ||
+					 !priv->sta_asleep_mask)) {
+				priv->buffered_multicasts = false;
+				if (priv->tx_multicast) {
+					priv->tx_multicast = false;
+					queue_work(hw_priv->workqueue,
+						&priv->multicast_stop_work);
+				}
+			}
+
+			spin_unlock_bh(&priv->ps_state_lock);
+
+			if (ret) {
+				spin_unlock(&priv->vif_lock);
+				if (if_pending) {
+					if_pending--;
+					continue;
+				}
+				break;
+			}
+
+			if (bes2600_queue_get(queue,
+					priv->if_id,
+					tx_allowed_mask,
+					&wsm, &tx_info, &txpriv)) {
+				spin_unlock(&priv->vif_lock);
+				if_pending = 0;
+				continue;
+			}
+			if (wsm_handle_tx_data(priv, wsm,
+					tx_info, txpriv, queue)) {
+				spin_unlock(&priv->vif_lock);
+				if_pending = 0;
+				continue;  /* Handled by WSM */
+			}
+
+			wsm->hdr.id &= __cpu_to_le16(
+					~WSM_TX_IF_ID(WSM_TX_IF_ID_MAX));
+			if (txpriv->raw_if_id)
+				wsm->hdr.id |= cpu_to_le16(
+					WSM_TX_IF_ID(txpriv->raw_if_id));
+			else
+				wsm->hdr.id |= cpu_to_le16(
+					WSM_TX_IF_ID(priv->if_id));
+
+			*vif_selected = priv->if_id;
+
+			priv->pspoll_mask &= ~BIT(txpriv->raw_link_id);
+
+			*data = (u8 *)wsm;
+			*tx_len = __le16_to_cpu(wsm->hdr.len);
+
+			/* allow bursting if txop is set */
+			if (priv->edca.params[queue_num].txOpLimit)
+				*burst = min(*burst,
+					(int)bes2600_queue_get_num_queued(priv,
+						queue, tx_allowed_mask) + 1);
+			else
+				*burst = 1;
+
+			/* store index of bursting queue */
+			if (*burst > 1)
+				hw_priv->tx_burst_idx = queue_num;
+			else
+				hw_priv->tx_burst_idx = -1;
+
+			if (more) {
+				struct ieee80211_hdr *hdr =
+					(struct ieee80211_hdr *)
+					&((u8 *)wsm)[txpriv->offset];
+				if(strstr(&priv->ssid[0], "6.1.12")) {
+					if(hdr->addr1[0] & 0x01 ) {
+						hdr->frame_control |=
+						cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+					}
+				}
+				else {
+					/* more buffered multicast/broadcast frames
+					*  ==> set MoreData flag in IEEE 802.11 header
+					*  to inform PS STAs */
+					hdr->frame_control |=
+					cpu_to_le16(IEEE80211_FCTL_MOREDATA);
+				}
+			}
+			bes2600_dbg(BES2600_DBG_WSM, "[WSM] >>> 0x%.4X (%lu) %p %c\n",
+				0x0004, (long unsigned)*tx_len, *data,
+				wsm->more ? 'M' : ' ');
+			++count;
+			spin_unlock(&priv->vif_lock);
+			break;
+		}
+	}
+
+	return count;
+}
+
+void wsm_txed(struct bes2600_common *hw_priv, u8 *data)
+{
+	if (data == hw_priv->wsm_cmd.ptr) {
+		spin_lock(&hw_priv->wsm_cmd.lock);
+		hw_priv->wsm_cmd.ptr = NULL;
+		spin_unlock(&hw_priv->wsm_cmd.lock);
+	} else {
+		bes2600_pwr_set_busy_event_async(hw_priv, BES_PWR_LOCK_ON_LMAC_RSP);
+	}
+}
+
+/* ******************************************************************** */
+/* WSM buffer								*/
+
+void wsm_buf_init(struct wsm_buf *buf)
+{
+	BUG_ON(buf->begin);
+	buf->begin = kmalloc(SDIO_BLOCK_SIZE, GFP_KERNEL | GFP_DMA);
+	buf->end = buf->begin ? &buf->begin[SDIO_BLOCK_SIZE] : buf->begin;
+	wsm_buf_reset(buf);
+}
+
+void wsm_buf_deinit(struct wsm_buf *buf)
+{
+	kfree(buf->begin);
+	buf->begin = buf->data = buf->end = NULL;
+}
+
+static void wsm_buf_reset(struct wsm_buf *buf)
+{
+	if (buf->begin) {
+		buf->data = &buf->begin[4];
+		*(u32 *)buf->begin = 0;
+	} else
+		buf->data = buf->begin;
+}
+
+static int wsm_buf_reserve(struct wsm_buf *buf, size_t extra_size)
+{
+	size_t pos = buf->data - buf->begin;
+	size_t size = pos + extra_size;
+
+
+	if (size & (SDIO_BLOCK_SIZE - 1)) {
+		size &= SDIO_BLOCK_SIZE;
+		size += SDIO_BLOCK_SIZE;
+	}
+
+	buf->begin = krealloc(buf->begin, size, GFP_KERNEL | GFP_DMA);
+	if (buf->begin) {
+		buf->data = &buf->begin[pos];
+		buf->end = &buf->begin[size];
+		return 0;
+	} else {
+		buf->end = buf->data = buf->begin;
+		return -ENOMEM;
+	}
+}
+
+static struct bes2600_vif
+	*wsm_get_interface_for_tx(struct bes2600_common *hw_priv)
+{
+	struct bes2600_vif *priv = NULL, *i_priv;
+	int i = hw_priv->if_id_selected;
+
+	if (is_hardware_cw1250(hw_priv) || 1 /*TODO:COMBO*/) {
+		spin_lock(&hw_priv->vif_list_lock);
+		i_priv = hw_priv->vif_list[i] ?
+			cw12xx_get_vif_from_ieee80211(hw_priv->vif_list[i]) : NULL;
+		if (i_priv) {
+			priv = i_priv;
+			spin_lock(&priv->vif_lock);
+		}
+		/* TODO:COMBO:
+		* Find next interface based on TX bitmap announced by the FW
+		* Find next interface based on load balancing */
+		spin_unlock(&hw_priv->vif_list_lock);
+	} else {
+		priv = cw12xx_hwpriv_to_vifpriv(hw_priv, 0);
+	}
+
+	return priv;
+}
+
+static inline int get_interface_id_scanning(struct bes2600_common *hw_priv)
+{
+	if (hw_priv->scan.req)
+		return hw_priv->scan.if_id;
+	else
+		return -1;
+}
diff --git a/drivers/staging/bes2600/wsm.h b/drivers/staging/bes2600/wsm.h
new file mode 100755
index 000000000000..fe3772416392
--- /dev/null
+++ b/drivers/staging/bes2600/wsm.h
@@ -0,0 +1,2091 @@
+/*
+ * WSM host interface (HI) interface for BES2600 mac80211 drivers
+ *
+ * Copyright (c) 2022, Bestechnic
+ * Author:
+ *
+ * Based on BES2600 UMAC WSM API, which is
+ * Copyright (C) SA 2010
+ * Author: Stewart Mathers <stewart.mathers@stericsson.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef BES2600_WSM_H_INCLUDED
+#define BES2600_WSM_H_INCLUDED
+
+#include <linux/spinlock.h>
+
+struct bes2600_common;
+struct bes2600_vif;
+
+/* Bands */
+/* Radio band 2.412 -2.484 GHz. */
+#define WSM_PHY_BAND_2_4G		(0)
+
+/* Radio band 4.9375-5.8250 GHz. */
+#define WSM_PHY_BAND_5G			(1)
+
+/* Transmit rates */
+/* 1   Mbps            ERP-DSSS */
+#define WSM_TRANSMIT_RATE_1		(0)
+
+/* 2   Mbps            ERP-DSSS */
+#define WSM_TRANSMIT_RATE_2		(1)
+
+/* 5.5 Mbps            ERP-CCK, ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_5		(2) */
+
+/* 11  Mbps            ERP-CCK, ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_11		(3) */
+
+/* 22  Mbps            ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_22		(4) */
+
+/* 33  Mbps            ERP-PBCC (Not supported) */
+/* #define WSM_TRANSMIT_RATE_33		(5) */
+
+/* 6   Mbps   (3 Mbps) ERP-OFDM, BPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_6		(6)
+
+/* 9   Mbps (4.5 Mbps) ERP-OFDM, BPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_9		(7)
+
+/* 12  Mbps  (6 Mbps)  ERP-OFDM, QPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_12		(8)
+
+/* 18  Mbps  (9 Mbps)  ERP-OFDM, QPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_18		(9)
+
+/* 24  Mbps (12 Mbps)  ERP-OFDM, 16QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_24		(10)
+
+/* 36  Mbps (18 Mbps)  ERP-OFDM, 16QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_36		(11)
+
+/* 48  Mbps (24 Mbps)  ERP-OFDM, 64QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_48		(12)
+
+/* 54  Mbps (27 Mbps)  ERP-OFDM, 64QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_54		(13)
+
+/* 6.5 Mbps            HT-OFDM, BPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_6		(14)
+
+/* 13  Mbps            HT-OFDM, QPSK coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_13		(15)
+
+/* 19.5 Mbps           HT-OFDM, QPSK coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_19		(16)
+
+/* 26  Mbps            HT-OFDM, 16QAM coding rate 1/2 */
+#define WSM_TRANSMIT_RATE_HT_26		(17)
+
+/* 39  Mbps            HT-OFDM, 16QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_39		(18)
+
+/* 52  Mbps            HT-OFDM, 64QAM coding rate 2/3 */
+#define WSM_TRANSMIT_RATE_HT_52		(19)
+
+/* 58.5 Mbps           HT-OFDM, 64QAM coding rate 3/4 */
+#define WSM_TRANSMIT_RATE_HT_58		(20)
+
+/* 65  Mbps            HT-OFDM, 64QAM coding rate 5/6 */
+#define WSM_TRANSMIT_RATE_HT_65		(21)
+
+/* Scan types */
+/* Foreground scan */
+#define WSM_SCAN_TYPE_FOREGROUND	(0)
+
+/* Background scan */
+#define WSM_SCAN_TYPE_BACKGROUND	(1)
+
+/* Auto scan */
+#define WSM_SCAN_TYPE_AUTO		(2)
+
+/* Scan flags */
+/* Forced background scan means if the station cannot */
+/* enter the power-save mode, it shall force to perform a */
+/* background scan. Only valid when ScanType is */
+/* background scan. */
+#define WSM_SCAN_FLAG_FORCE_BACKGROUND	(BIT(0))
+
+/* The WLAN device scans one channel at a time so */
+/* that disturbance to the data traffic is minimized. */
+#define WSM_SCAN_FLAG_SPLIT_METHOD	(BIT(1))
+
+/* Preamble Type. Long if not set. */
+#define WSM_SCAN_FLAG_SHORT_PREAMBLE	(BIT(2))
+
+/* 11n Tx Mode. Mixed if not set. */
+#define WSM_SCAN_FLAG_11N_GREENFIELD	(BIT(3))
+
+#define WSM_FLAG_MAC_INSTANCE_1	(BIT(4))
+
+#define WSM_FLAG_MAC_INSTANCE_0	(~(BIT(4)))
+
+/* Scan constraints */
+/* Maximum number of channels to be scanned. */
+#define WSM_SCAN_MAX_NUM_OF_CHANNELS	(48)
+
+/* The maximum number of SSIDs that the device can scan for. */
+#define WSM_SCAN_MAX_NUM_OF_SSIDS	(2)
+
+/* Power management modes */
+/* 802.11 Active mode */
+#define WSM_PSM_ACTIVE			(0)
+
+/* 802.11 PS mode */
+#define WSM_PSM_PS			BIT(0)
+
+/* Fast Power Save bit */
+#define WSM_PSM_FAST_PS_FLAG		BIT(7)
+
+/* Dynamic aka Fast power save */
+#define WSM_PSM_FAST_PS			(BIT(0) | BIT(7))
+
+/* Undetermined */
+/* Note : Undetermined status is reported when the */
+/* NULL data frame used to advertise the PM mode to */
+/* the AP at Pre or Post Background Scan is not Acknowledged */
+#define WSM_PSM_UNKNOWN			BIT(1)
+
+/* Queue IDs */
+/* best effort/legacy */
+#define WSM_QUEUE_BEST_EFFORT		(0)
+
+/* background */
+#define WSM_QUEUE_BACKGROUND		(1)
+
+/* video */
+#define WSM_QUEUE_VIDEO			(2)
+
+/* voice */
+#define WSM_QUEUE_VOICE			(3)
+
+/* HT TX parameters */
+/* Non-HT */
+#define WSM_HT_TX_NON_HT		(0)
+
+/* Mixed format */
+#define WSM_HT_TX_MIXED			(1)
+
+/* Greenfield format */
+#define WSM_HT_TX_GREENFIELD		(2)
+
+/* STBC allowed */
+#define WSM_HT_TX_STBC			(BIT(7))
+
+/* EPTA prioirty flags for BT Coex */
+/* default epta priority */
+#define WSM_EPTA_PRIORITY_DEFAULT	4
+/* use for normal data */
+#define WSM_EPTA_PRIORITY_DATA		4
+/* use for connect/disconnect/roaming*/
+#define WSM_EPTA_PRIORITY_MGT		5
+/* use for action frames */
+#define WSM_EPTA_PRIORITY_ACTION	5
+/* use for AC_VI data */
+#define WSM_EPTA_PRIORITY_VIDEO		5
+/* use for AC_VO data */
+#define WSM_EPTA_PRIORITY_VOICE		6
+/* use for EAPOL exchange */
+#define WSM_EPTA_PRIORITY_EAPOL		7
+
+/* TX status */
+/* Frame was sent aggregated */
+/* Only valid for WSM_SUCCESS status. */
+#define WSM_TX_STATUS_AGGREGATION	(BIT(0))
+
+/* Host should requeue this frame later. */
+/* Valid only when status is WSM_REQUEUE. */
+#define WSM_TX_STATUS_REQUEUE		(BIT(1))
+
+/* Normal Ack */
+#define WSM_TX_STATUS_NORMAL_ACK	(0<<2)
+
+/* No Ack */
+#define WSM_TX_STATUS_NO_ACK		(1<<2)
+
+/* No explicit acknowledgement */
+#define WSM_TX_STATUS_NO_EXPLICIT_ACK	(2<<2)
+
+/* Block Ack */
+/* Only valid for WSM_SUCCESS status. */
+#define WSM_TX_STATUS_BLOCK_ACK		(3<<2)
+
+/* RX status */
+/* Unencrypted */
+#define WSM_RX_STATUS_UNENCRYPTED	(0<<0)
+
+/* WEP */
+#define WSM_RX_STATUS_WEP		(1<<0)
+
+/* TKIP */
+#define WSM_RX_STATUS_TKIP		(2<<0)
+
+/* AES */
+#define WSM_RX_STATUS_AES		(3<<0)
+
+/* WAPI */
+#define WSM_RX_STATUS_WAPI		(4<<0)
+
+/* DECRYPTED */
+#define WSM_RX_STATUS_DECRYPTED		(7<<0)
+
+/* Macro to fetch encryption subfield. */
+#define WSM_RX_STATUS_ENCRYPTION(status) ((status) & 0x07)
+
+/* Frame was part of an aggregation */
+#define WSM_RX_STATUS_AGGREGATE		(BIT(3))
+
+/* Frame was first in the aggregation */
+#define WSM_RX_STATUS_AGGREGATE_FIRST	(BIT(4))
+
+/* Frame was last in the aggregation */
+#define WSM_RX_STATUS_AGGREGATE_LAST	(BIT(5))
+
+/* Indicates a defragmented frame */
+#define WSM_RX_STATUS_DEFRAGMENTED	(BIT(6))
+
+/* Indicates a Beacon frame */
+#define WSM_RX_STATUS_BEACON		(BIT(7))
+
+/* Indicates STA bit beacon TIM field */
+#define WSM_RX_STATUS_TIM		(BIT(8))
+
+/* Indicates Beacon frame's virtual bitmap contains multicast bit */
+#define WSM_RX_STATUS_MULTICAST		(BIT(9))
+
+/* Indicates frame contains a matching SSID */
+#define WSM_RX_STATUS_MATCHING_SSID	(BIT(10))
+
+/* Indicates frame contains a matching BSSI */
+#define WSM_RX_STATUS_MATCHING_BSSI	(BIT(11))
+
+/* Indicates More bit set in Framectl field */
+#define WSM_RX_STATUS_MORE_DATA		(BIT(12))
+
+/* Indicates frame received during a measurement process */
+#define WSM_RX_STATUS_MEASUREMENT	(BIT(13))
+
+/* Indicates frame received as an HT packet */
+#define WSM_RX_STATUS_HT		(BIT(14))
+
+/* Indicates frame received with STBC */
+#define WSM_RX_STATUS_STBC		(BIT(15))
+
+/* Indicates Address 1 field matches dot11StationId */
+#define WSM_RX_STATUS_ADDRESS1		(BIT(16))
+
+/* Indicates Group address present in the Address 1 field */
+#define WSM_RX_STATUS_GROUP		(BIT(17))
+
+/* Indicates Broadcast address present in the Address 1 field */
+#define WSM_RX_STATUS_BROADCAST		(BIT(18))
+
+/* Indicates group key used with encrypted frames */
+#define WSM_RX_STATUS_GROUP_KEY		(BIT(19))
+
+/* Macro to fetch encryption key index. */
+#define WSM_RX_STATUS_KEY_IDX(status)	(((status >> 20)) & 0x0F)
+
+/* Frame Control field starts at Frame offset + 2 */
+#define WSM_TX_2BYTES_SHIFT		(BIT(7))
+
+/* Join mode */
+/* IBSS */
+#define WSM_JOIN_MODE_IBSS		(0)
+
+/* BSS */
+#define WSM_JOIN_MODE_BSS		(1)
+
+/* PLCP preamble type */
+/* For long preamble */
+#define WSM_JOIN_PREAMBLE_LONG		(0)
+
+/* For short preamble (Long for 1Mbps) */
+#define WSM_JOIN_PREAMBLE_SHORT		(1)
+
+/* For short preamble (Long for 1 and 2Mbps) */
+#define WSM_JOIN_PREAMBLE_SHORT_2	(2)
+
+/* Join flags */
+/* Unsynchronized */
+#define WSM_JOIN_FLAGS_UNSYNCRONIZED	BIT(0)
+/* The BSS owner is a P2P GO */
+#define WSM_JOIN_FLAGS_P2P_GO		BIT(1)
+/* Force to join BSS with the BSSID and the
+ * SSID specified without waiting for beacons. The
+ * ProbeForJoin parameter is ignored. */
+#define WSM_JOIN_FLAGS_FORCE		BIT(2)
+/* Give probe request/response higher
+ * priority over the BT traffic */
+#define WSM_JOIN_FLAGS_PRIO		BIT(3)
+
+/* Key types */
+#define WSM_KEY_TYPE_WEP_DEFAULT	(0)
+#define WSM_KEY_TYPE_WEP_PAIRWISE	(1)
+#define WSM_KEY_TYPE_TKIP_GROUP		(2)
+#define WSM_KEY_TYPE_TKIP_PAIRWISE	(3)
+#define WSM_KEY_TYPE_AES_GROUP		(4)
+#define WSM_KEY_TYPE_AES_PAIRWISE	(5)
+#define WSM_KEY_TYPE_WAPI_GROUP		(6)
+#define WSM_KEY_TYPE_WAPI_PAIRWISE	(7)
+#define WSM_KEY_TYPE_IGTK_GROUP		(8)
+
+/* Key indexes */
+#define CW1250_WSM_KEY_MAX_INDEX	(15)
+#define WSM_KEY_MAX_INDEX		(10)
+
+/* ACK policy */
+#define WSM_ACK_POLICY_NORMAL		(0)
+#define WSM_ACK_POLICY_NO_ACK		(1)
+
+/* Start modes */
+#define WSM_START_MODE_AP		(0)	/* Mini AP */
+#define WSM_START_MODE_P2P_GO		(1)	/* P2P GO */
+#define WSM_START_MODE_P2P_DEV		(2)	/* P2P device */
+
+/* SetAssociationMode MIB flags */
+#define WSM_ASSOCIATION_MODE_USE_PREAMBLE_TYPE		(BIT(0))
+#define WSM_ASSOCIATION_MODE_USE_HT_MODE		(BIT(1))
+#define WSM_ASSOCIATION_MODE_USE_BASIC_RATE_SET		(BIT(2))
+#define WSM_ASSOCIATION_MODE_USE_MPDU_START_SPACING	(BIT(3))
+#define WSM_ASSOCIATION_MODE_SNOOP_ASSOC_FRAMES		(BIT(4))
+
+/* RcpiRssiThreshold MIB flags */
+#define WSM_RCPI_RSSI_THRESHOLD_ENABLE	(BIT(0))
+#define WSM_RCPI_RSSI_USE_RSSI		(BIT(1))
+#define WSM_RCPI_RSSI_DONT_USE_UPPER	(BIT(2))
+#define WSM_RCPI_RSSI_DONT_USE_LOWER	(BIT(3))
+
+/* Update-ie constants */
+#define WSM_UPDATE_IE_BEACON		(BIT(0))
+#define WSM_UPDATE_IE_PROBE_RESP	(BIT(1))
+#define WSM_UPDATE_IE_PROBE_REQ		(BIT(2))
+
+/* PS Mode Error */
+#define WSM_PS_ERROR_NO_ERROR	                    0
+#define WSM_PS_ERROR_AP_NOT_RESP_TO_POLL	    1
+#define WSM_PS_ERROR_AP_NOT_RESP_TO_UAPSD_TRIGGER   2
+#define WSM_PS_ERROR_AP_SENT_UNICAST_IN_DOZE        3
+#define WSM_PS_ERROR_AP_NO_DATA_AFTER_TIM           4
+
+/* WSM events */
+/* Error */
+#define WSM_EVENT_ERROR			(0)
+
+/* BSS lost */
+#define WSM_EVENT_BSS_LOST		(1)
+
+/* BSS regained */
+#define WSM_EVENT_BSS_REGAINED		(2)
+
+/* Radar detected */
+#define WSM_EVENT_RADAR_DETECTED	(3)
+
+/* RCPI or RSSI threshold triggered */
+#define WSM_EVENT_RCPI_RSSI		(4)
+
+/* BT inactive */
+#define WSM_EVENT_BT_INACTIVE		(5)
+
+/* BT active */
+#define WSM_EVENT_BT_ACTIVE		(6)
+
+#define WSM_EVENT_PS_MODE_ERROR         (7)
+
+#define WSM_EVENT_INACTIVITY		(9)
+
+#define WSM_EVENT_WAKEUP_EVENT		(10)
+
+/* MAC Addr Filter */
+#define WSM_MIB_ID_MAC_ADDR_FILTER	0x1030
+
+/* MIB IDs */
+/* 4.1  dot11StationId */
+#define WSM_MIB_ID_DOT11_STATION_ID		0x0000
+
+/* 4.2  dot11MaxtransmitMsduLifeTime */
+#define WSM_MIB_ID_DOT11_MAX_TRANSMIT_LIFTIME	0x0001
+
+/* 4.3  dot11MaxReceiveLifeTime */
+#define WSM_MIB_ID_DOT11_MAX_RECEIVE_LIFETIME	0x0002
+
+/* 4.4  dot11SlotTime */
+#define WSM_MIB_ID_DOT11_SLOT_TIME		0x0003
+
+/* 4.5  dot11GroupAddressesTable */
+#define WSM_MIB_ID_DOT11_GROUP_ADDRESSES_TABLE	0x0004
+#define WSM_MAX_GRP_ADDRTABLE_ENTRIES		8
+
+/* 4.6  dot11WepDefaultKeyId */
+#define WSM_MIB_ID_DOT11_WEP_DEFAULT_KEY_ID	0x0005
+
+/* 4.7  dot11CurrentTxPowerLevel */
+#define WSM_MIB_ID_DOT11_CURRENT_TX_POWER_LEVEL	0x0006
+
+/* 4.8  dot11RTSThreshold */
+#define WSM_MIB_ID_DOT11_RTS_THRESHOLD		0x0007
+
+/* 4.9  NonErpProtection */
+#define WSM_MIB_ID_NON_ERP_PROTECTION		0x1000
+
+/* 4.10 ArpIpAddressesTable */
+#define WSM_MIB_ID_ARP_IP_ADDRESSES_TABLE	0x1001
+#define WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES	1
+
+/* 4.11 TemplateFrame */
+#define WSM_MIB_ID_TEMPLATE_FRAME		0x1002
+
+/* 4.12 RxFilter */
+#define WSM_MIB_ID_RX_FILTER			0x1003
+
+/* 4.13 BeaconFilterTable */
+#define WSM_MIB_ID_BEACON_FILTER_TABLE		0x1004
+
+/* 4.14 BeaconFilterEnable */
+#define WSM_MIB_ID_BEACON_FILTER_ENABLE		0x1005
+
+/* 4.15 OperationalPowerMode */
+#define WSM_MIB_ID_OPERATIONAL_POWER_MODE	0x1006
+
+/* 4.16 BeaconWakeUpPeriod */
+#define WSM_MIB_ID_BEACON_WAKEUP_PERIOD		0x1007
+
+/* 4.17 RcpiRssiThreshold */
+#define WSM_MIB_ID_RCPI_RSSI_THRESHOLD		0x1009
+
+/* 4.18 StatisticsTable */
+#define WSM_MIB_ID_STATISTICS_TABLE		0x100A
+
+/* 4.19 IbssPsConfig */
+#define WSM_MIB_ID_IBSS_PS_CONFIG		0x100B
+
+/* 4.20 CountersTable */
+#define WSM_MIB_ID_COUNTERS_TABLE		0x100C
+
+/* 4.21 BlockAckPolicy */
+#define WSM_MIB_ID_BLOCK_ACK_POLICY		0x100E
+
+/* 4.22 OverrideInternalTxRate */
+#define WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE	0x100F
+
+/* 4.23 SetAssociationMode */
+#define WSM_MIB_ID_SET_ASSOCIATION_MODE		0x1010
+
+/* 4.24 UpdateEptaConfigData */
+#define WSM_MIB_ID_UPDATE_EPTA_CONFIG_DATA	0x1011
+
+/* 4.25 SelectCcaMethod */
+#define WSM_MIB_ID_SELECT_CCA_METHOD		0x1012
+
+/* 4.26 SetUpasdInformation */
+#define WSM_MIB_ID_SET_UAPSD_INFORMATION	0x1013
+
+/* 4.27 SetAutoCalibrationMode  WBF00004073 */
+#define WSM_MIB_ID_SET_AUTO_CALIBRATION_MODE	0x1015
+
+/* 4.28 SetTxRateRetryPolicy */
+#define WSM_MIB_ID_SET_TX_RATE_RETRY_POLICY	0x1016
+
+/* 4.29 SetHostMessageTypeFilter */
+#define WSM_MIB_ID_SET_HOST_MSG_TYPE_FILTER	0x1017
+
+/* 4.30 P2PFindInfo */
+#define WSM_MIB_ID_P2P_FIND_INFO		0x1018
+
+/* 4.31 P2PPsModeInfo */
+#define WSM_MIB_ID_P2P_PS_MODE_INFO		0x1019
+
+/* 4.32 SetEtherTypeDataFrameFilter */
+#define WSM_MIB_ID_SET_ETHERTYPE_DATAFRAME_FILTER 0x101A
+
+/* 4.33 SetUDPPortDataFrameFilter */
+#define WSM_MIB_ID_SET_UDPPORT_DATAFRAME_FILTER	0x101B
+
+/* 4.34 SetMagicDataFrameFilter */
+#define WSM_MIB_ID_SET_MAGIC_DATAFRAME_FILTER	0x101C
+
+/* This is the end of specification. */
+
+/* 4.35 P2PDeviceInfo */
+#define WSM_MIB_ID_P2P_DEVICE_INFO		0x101D
+
+/* 4.36 SetWCDMABand */
+#define WSM_MIB_ID_SET_WCDMA_BAND		0x101E
+
+/* 4.37 GroupTxSequenceCounter */
+#define WSM_MIB_ID_GRP_SEQ_COUNTER		0x101F
+
+/* 4.38 ProtectedMgmtPolicy */
+#define WSM_MIB_ID_PROTECTED_MGMT_POLICY	0x1020
+
+/* 4.39 SetHtProtection */
+#define WSM_MID_ID_SET_HT_PROTECTION		0x1021
+
+/* 4.40 GPIO Command */
+#define WSM_MIB_ID_GPIO_COMMAND			0x1022
+
+/* 4.41 TSF Counter Value */
+#define WSM_MIB_ID_TSF_COUNTER			0x1023
+
+/* Test Purposes Only */
+#define WSM_MIB_ID_BLOCK_ACK_INFO		0x100D
+
+/* 4.42 UseMultiTxConfMessage */
+#define WSM_MIB_USE_MULTI_TX_CONF		0x1024
+
+/* 4.43 Keep-alive period */
+#define WSM_MIB_ID_KEEP_ALIVE_PERIOD		0x1025
+
+/* 4.44 Disable BSSID filter */
+#define WSM_MIB_ID_DISABLE_BSSID_FILTER		0x1026
+
+/* Inactivity */
+#define WSM_MIB_ID_SET_INACTIVITY		0x1035
+
+/* MAC Addr Filter */
+#define WSM_MIB_ID_MAC_ADDR_FILTER		0x1030
+
+/* IP Addr Filter */
+#define WSM_MIB_ID_IPV4_ADDR_FILTERING           0x1031
+
+#define WSM_MIB_ID_EXT_BASE                         0x1040
+#define WSM_MIB_ID_EXT_RF_ENABLE                    (WSM_MIB_ID_EXT_BASE + 0)  /* Mib to set RF on/off */
+#define WSM_MIB_ID_EXT_TCP_KEEP_ALIVE_FRAME         (WSM_MIB_ID_EXT_BASE + 1)  /* Mib to set tcp keep alive frame */
+#define WSM_MIB_ID_EXT_TCP_KEEP_ALIVE_PERIOD        (WSM_MIB_ID_EXT_BASE + 2)  /* Mib to set tcp keep alive period */
+#define WSM_MIB_ID_EXT_TX_SHORT_GI_ENABLED          (WSM_MIB_ID_EXT_BASE + 3)  /* Mib to set tx short enabled */
+#define WSM_MIB_ID_EXT_TXRX_OPT_PARAM               (WSM_MIB_ID_EXT_BASE + 4)  /* Mib to set tx/rx opt param to enhance wifi throuhput */
+
+/* Frame template types */
+#define WSM_FRAME_TYPE_PROBE_REQUEST	(0)
+#define WSM_FRAME_TYPE_BEACON		(1)
+#define WSM_FRAME_TYPE_NULL		(2)
+#define WSM_FRAME_TYPE_QOS_NULL		(3)
+#define WSM_FRAME_TYPE_PS_POLL		(4)
+#define WSM_FRAME_TYPE_PROBE_RESPONSE	(5)
+#define WSM_FRAME_TYPE_ARP_REPLY        (6)
+
+#define WSM_FRAME_GREENFIELD		(0x80)	/* See 4.11 */
+
+/* Status */
+/* The WSM firmware has completed a request */
+/* successfully. */
+#define WSM_STATUS_SUCCESS              (0)
+
+/* This is a generic failure code if other error codes do */
+/* not apply. */
+#define WSM_STATUS_FAILURE              (1)
+
+/* A request contains one or more invalid parameters. */
+#define WSM_INVALID_PARAMETER           (2)
+
+/* The request cannot perform because the device is in */
+/* an inappropriate mode. */
+#define WSM_ACCESS_DENIED               (3)
+
+/* The frame received includes a decryption error. */
+#define WSM_STATUS_DECRYPTFAILURE       (4)
+
+/* A MIC failure is detected in the received packets. */
+#define WSM_STATUS_MICFAILURE           (5)
+
+/* The transmit request failed due to retry limit being */
+/* exceeded. */
+#define WSM_STATUS_RETRY_EXCEEDED       (6)
+
+/* The transmit request failed due to MSDU life time */
+/* being exceeded. */
+#define WSM_STATUS_TX_LIFETIME_EXCEEDED (7)
+
+/* The link to the AP is lost. */
+#define WSM_STATUS_LINK_LOST            (8)
+
+/* No key was found for the encrypted frame */
+#define WSM_STATUS_NO_KEY_FOUND         (9)
+
+/* Jammer was detected when transmitting this frame */
+#define WSM_STATUS_JAMMER_DETECTED      (10)
+
+/* The message should be requeued later. */
+/* This is applicable only to Transmit */
+#define WSM_REQUEUE                     (11)
+
+/* Advanced filtering options */
+#define WSM_MAX_FILTER_ELEMENTS		(4)
+
+#define WSM_FILTER_ACTION_IGNORE	(0)
+#define WSM_FILTER_ACTION_FILTER_OUT	(1)
+#define WSM_FILTER_ACTION_FILTER_IN	(2)
+
+#define WSM_FILTER_ADDR_MODE_NONE	(0)
+#define WSM_FILTER_ADDR_MODE_A1		(1)
+#define WSM_FILTER_ADDR_MODE_A2		(2)
+#define WSM_FILTER_ADDR_MODE_A3		(3)
+
+#define WSM_FILTER_PORT_TYPE_DST	(0)
+#define WSM_FILTER_PORT_TYPE_SRC	(1)
+
+
+
+struct wsm_hdr {
+	__le16 len;
+	__le16 id;
+};
+
+/* mcu -> driver confirm or indication hdr */
+struct wsm_mcu_hdr {
+	struct wsm_hdr hdr;
+	uint32_t m_reserve; /* reserved member variable */
+	uint32_t handle_label; /* confirm or indication */
+	uint32_t cmd_type;
+};
+
+#define WSM_MSG_ID_MASK		        (0x0C3F)
+#define WSM_MSG_ID_GET(x)		((x) & WSM_MSG_ID_MASK)
+#define WSM_TX_SEQ_MAX			(7)
+#define WSM_TX_SEQ(seq)			\
+		((seq & WSM_TX_SEQ_MAX) << 13)
+#define WSM_MSG_SEQ_GET(x)		(((x) >> 13) & WSM_TX_SEQ_MAX)
+#define WSM_BES2600_CMD_ID_LABLE		(0x0C00)
+#define IS_DRIVER_TO_MCU_CMD(id)		((id & WSM_BES2600_CMD_ID_LABLE) == WSM_BES2600_CMD_ID_LABLE)
+#define WSM_TXRX_SEQ_IDX(id)				\
+		(((id & 0xF00) == WSM_BES2600_CMD_ID_LABLE) ? 1 : 0)
+#define WSM_TO_MCU_CMD_CONFIRM_LABEL		(0x0f)
+#define WSM_TO_MCU_CMD_INDICATION_LABEL		(0xf0)
+
+#define WSM_CONFIRM_CONDITION(id, confirm_label) (((id & 0x0f00) == 0x0400 || \
+		(((id & 0x0f00) == WSM_BES2600_CMD_ID_LABLE) && confirm_label == WSM_TO_MCU_CMD_CONFIRM_LABEL)))
+
+#define WSM_TO_MCU_CMD_IND_CONDITION(id, ind_label) (((id & 0x0f00) == WSM_BES2600_CMD_ID_LABLE) && \
+		ind_label == WSM_TO_MCU_CMD_INDICATION_LABEL)
+
+#define WSM_TX_LINK_ID_MAX		(0x0F)
+#define WSM_TX_LINK_ID(link_id)		\
+		((link_id & WSM_TX_LINK_ID_MAX) << 6)
+
+#define WSM_TX_IF_ID_MAX		(0x0F)
+#define WSM_TX_IF_ID(if_id)		\
+		((if_id & WSM_TX_IF_ID_MAX) << 6)
+
+#define MAX_BEACON_SKIP_TIME_MS 1000
+
+#define WSM_CMD_LAST_CHANCE_TIMEOUT (HZ * 20 / 2)
+#define WSM_CMD_EXTENDED_TIMEOUT (HZ * 20 / 2)
+
+#define WSM_RI_GET_PEER_ID_FROM_FLAGS(_f)         (((_f)&(0xF<<25)>>25))
+
+
+/* ******************************************************************** */
+/* WSM capcbility							*/
+
+struct wsm_caps {
+	u16 numInpChBufs;
+	u16 sizeInpChBuf;
+	u16 hardwareId;
+	u16 hardwareSubId;
+	u16 firmwareCap;
+	u16 firmwareType;
+	u16 firmwareApiVer;
+	u16 firmwareBuildNumber;
+	u16 firmwareVersion;
+	int firmwareReady;
+};
+
+/* ******************************************************************** */
+/* WSM commands								*/
+
+struct wsm_tx_power_range {
+	int min_power_level;
+	int max_power_level;
+	u32 stepping;
+};
+
+/* 3.1 */
+struct wsm_configuration {
+	/* [in] */ u32 dot11MaxTransmitMsduLifeTime;
+	/* [in] */ u32 dot11MaxReceiveLifeTime;
+	/* [in] */ u32 dot11RtsThreshold;
+	/* [in, out] */ u8 *dot11StationId;
+	/* [in] */ const void *dpdData;
+	/* [in] */ size_t dpdData_size;
+	/* [out] */ u8 dot11FrequencyBandsSupported;
+	/* [out] */ u32 supportedRateMask;
+	/* [out] */ struct wsm_tx_power_range txPowerRange[2];
+};
+
+int wsm_configuration(struct bes2600_common *hw_priv,
+		      struct wsm_configuration *arg,
+		      int if_id);
+
+/* 3.3 */
+struct wsm_reset {
+	/* [in] */ int link_id;
+	/* [in] */ bool reset_statistics;
+};
+
+int wsm_reset(struct bes2600_common *hw_priv, const struct wsm_reset *arg,
+	      int if_id);
+
+/* 3.5 */
+int wsm_read_mib(struct bes2600_common *hw_priv, u16 mibId, void *buf,
+		 size_t buf_size);
+
+/* 3.7 */
+int wsm_write_mib(struct bes2600_common *hw_priv, u16 mibId, void *buf,
+		  size_t buf_size, int if_id);
+
+/* 3.9 */
+struct wsm_ssid {
+	u8 ssid[32];
+	u32 length;
+};
+
+struct wsm_scan_ch {
+	u16 number;
+	u32 minChannelTime;
+	u32 maxChannelTime;
+	u32 txPowerLevel;
+};
+
+/* 3.13 */
+struct wsm_scan_complete {
+	/* WSM_STATUS_... */
+	u32 status;
+
+	/* WSM_PSM_... */
+	u8 psm;
+
+	/* Number of channels that the scan operation completed. */
+	u8 numChannels;
+};
+
+typedef void (*wsm_scan_complete_cb) (struct bes2600_common *hw_priv,
+				      struct wsm_scan_complete *arg);
+
+/* 3.9 */
+struct wsm_scan {
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* WSM_SCAN_TYPE_... */
+	/* [in] */ u8 scanType;
+
+	/* WSM_SCAN_FLAG_... */
+	/* [in] */ u8 scanFlags;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u8 maxTransmitRate;
+
+	/* Interval period in TUs that the device shall the re- */
+	/* execute the requested scan. Max value supported by the device */
+	/* is 256s. */
+	/* [in] */ u32 autoScanInterval;
+
+	/* Number of probe requests (per SSID) sent to one (1) */
+	/* channel. Zero (0) means that none is send, which */
+	/* means that a passive scan is to be done. Value */
+	/* greater than zero (0) means that an active scan is to */
+	/* be done. */
+	/* [in] */ u32 numOfProbeRequests;
+
+	/* Number of channels to be scanned. */
+	/* Maximum value is WSM_SCAN_MAX_NUM_OF_CHANNELS. */
+	/* [in] */ u8 numOfChannels;
+
+	/* Number of SSID provided in the scan command (this */
+	/* is zero (0) in broadcast scan) */
+	/* The maximum number of SSIDs is WSM_SCAN_MAX_NUM_OF_SSIDS. */
+	/* [in] */ u8 numOfSSIDs;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* SSIDs to be scanned [numOfSSIDs]; */
+	/* [in] */ struct wsm_ssid *ssids;
+
+	/* Channels to be scanned [numOfChannels]; */
+	/* [in] */ struct wsm_scan_ch *ch;
+};
+
+int wsm_scan(struct bes2600_common *hw_priv, const struct wsm_scan *arg,
+			int if_id);
+
+/* 3.11 */
+int wsm_stop_scan(struct bes2600_common *hw_priv, int if_id);
+
+/* 3.14 */
+struct wsm_tx_confirm {
+	/* Packet identifier used in wsm_tx. */
+	/* [out] */ u32 packetID;
+
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u8 txedRate;
+
+	/* The number of times the frame was transmitted */
+	/* without receiving an acknowledgement. */
+	/* [out] */ u8 ackFailures;
+
+	/* WSM_TX_STATUS_... */
+	/* [out] */ u16 flags;
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission as completed. */
+	/* [out] */ u32 mediaDelay;
+
+	/* The total time in microseconds that the frame spent in */
+	/* the WLAN device before transmission was started. */
+	/* [out] */ u32 txQueueDelay;
+
+	/* [out]*/ u32 link_id;
+
+	/*[out]*/ int if_id;
+};
+
+/* 3.15 */
+typedef void (*wsm_tx_confirm_cb) (struct bes2600_common *hw_priv,
+				   struct wsm_tx_confirm *arg);
+
+/* Note that ideology of wsm_tx struct is different against the rest of
+ * WSM API. wsm_hdr is /not/ a caller-adapted struct to be used as an input
+ * argument for WSM call, but a prepared bytestream to be sent to firmware.
+ * It is filled partly in bes2600_tx, partly in low-level WSM code.
+ * Please pay attention once again: ideology is different.
+ *
+ * Legend:
+ * - [in]: bes2600_tx must fill this field.
+ * - [wsm]: the field is filled by low-level WSM.
+ */
+struct wsm_tx {
+	/* common WSM header */
+	/* [in/wsm] */ struct wsm_hdr hdr;
+
+	/* Packet identifier that meant to be used in completion. */
+	/* [in] */ __le32 packetID;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [in] */ u8 maxTxRate;
+
+	/* WSM_QUEUE_... */
+	/* [in] */ u8 queueId;
+
+	/* True: another packet is pending on the host for transmission. */
+	/* [wsm] */ u8 more;
+
+	/* Bit 0 = 0 - Start expiry time from first Tx attempt (default) */
+	/* Bit 0 = 1 - Start expiry time from receipt of Tx Request */
+	/* Bits 3:1  - PTA Priority */
+	/* Bits 6:4  - Tx Rate Retry Policy */
+	/* Bit 7 - Reserved */
+	/* [in] */ u8 flags;
+
+	/* Should be 0. */
+	/* [in] */ __le32 reserved;
+
+	/* The elapsed time in TUs, after the initial transmission */
+	/* of an MSDU, after which further attempts to transmit */
+	/* the MSDU shall be terminated. Overrides the global */
+	/* dot11MaxTransmitMsduLifeTime setting [optional] */
+	/* Device will set the default value if this is 0. */
+	/* [wsm] */ __le32 expireTime;
+
+	/* WSM_HT_TX_... */
+	/* [in] */ __le32 htTxParameters;
+};
+
+/* = sizeof(generic hi hdr) + sizeof(wsm hdr) + sizeof(alignment) */
+#define WSM_TX_EXTRA_HEADROOM (28)
+
+/* 3.16 */
+struct wsm_rx {
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* Specifies the channel of the received packet. */
+	/* [out] */ u16 channelNumber;
+
+	/* WSM_TRANSMIT_RATE_... */
+	/* [out] */ u8 rxedRate;
+
+	/* This value is expressed in signed Q8.0 format for */
+	/* RSSI and unsigned Q7.1 format for RCPI. */
+	/* [out] */ u8 rcpiRssi;
+
+	/* WSM_RX_STATUS_... */
+	/* [out] */ u32 flags;
+
+	/* An 802.11 frame. */
+	/* [out] */ void *frame;
+
+	/* Size of the frame */
+	/* [out] */ size_t frame_size;
+
+	/* Link ID */
+	/* [out] */ int link_id;
+	/* [out] */ int if_id;
+};
+
+/* = sizeof(generic hi hdr) + sizeof(wsm hdr) */
+#define WSM_RX_EXTRA_HEADROOM (16)
+
+typedef void (*wsm_rx_cb) (struct bes2600_vif *priv, struct wsm_rx *arg,
+			   struct sk_buff **skb_p);
+
+/* 3.17 */
+struct wsm_event {
+	/* WSM_STATUS_... */
+	/* [out] */ u32 eventId;
+
+	/* Indication parameters. */
+	/* For error indication, this shall be a 32-bit WSM status. */
+	/* For RCPI or RSSI indication, this should be an 8-bit */
+	/* RCPI or RSSI value. */
+	/* [out] */ u32 eventData;
+};
+
+struct bes2600_wsm_event {
+	struct list_head link;
+	struct wsm_event evt;
+	u8 if_id;
+};
+
+/* 3.18 - 3.22 */
+/* Measurement. Skipped for now. Irrelevent. */
+
+typedef void (*wsm_event_cb) (struct bes2600_common *hw_priv,
+			      struct wsm_event *arg);
+
+/* 3.23 */
+struct wsm_join {
+	/* WSM_JOIN_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* Specifies the channel number to join. The channel */
+	/* number will be mapped to an actual frequency */
+	/* according to the band */
+	/* [in] */ u16 channelNumber;
+
+	/* Specifies the BSSID of the BSS or IBSS to be joined */
+	/* or the IBSS to be started. */
+	/* [in] */ u8 bssid[6];
+
+	/* ATIM window of IBSS */
+	/* When ATIM window is zero the initiated IBSS does */
+	/* not support power saving. */
+	/* [in] */ u16 atimWindow;
+
+	/* WSM_JOIN_PREAMBLE_... */
+	/* [in] */ u8 preambleType;
+
+	/* Specifies if a probe request should be send with the */
+	/* specified SSID when joining to the network. */
+	/* [in] */ u8 probeForJoin;
+
+	/* DTIM Period (In multiples of beacon interval) */
+	/* [in] */ u8 dtimPeriod;
+
+	/* WSM_JOIN_FLAGS_... */
+	/* [in] */ u8 flags;
+
+	/* Length of the SSID */
+	/* [in] */ u32 ssidLength;
+
+	/* Specifies the SSID of the IBSS to join or start */
+	/* [in] */ u8 ssid[32];
+
+	/* Specifies the time between TBTTs in TUs */
+	/* [in] */ u32 beaconInterval;
+
+	/* A bit mask that defines the BSS basic rate set. */
+	/* [in] */ u32 basicRateSet;
+
+	/* Minimum transmission power level in units of 0.1dBm */
+	/* [out] */ int minPowerLevel;
+
+	/* Maximum transmission power level in units of 0.1dBm */
+	/* [out] */ int maxPowerLevel;
+};
+
+int wsm_join(struct bes2600_common *hw_priv, struct wsm_join *arg, int if_id);
+
+/* 3.25 */
+struct wsm_set_pm {
+	/* WSM_PSM_... */
+	/* [in] */ u8 pmMode;
+
+	/* in unit of 500us; 0 to use default */
+	/* [in] */ u8 fastPsmIdlePeriod;
+
+	/* in unit of 500us; 0 to use default */
+	/* [in] */ u8 apPsmChangePeriod;
+
+	/* in unit of 500us; 0 to disable auto-pspoll */
+	/* [in] */ u8 minAutoPsPollPeriod;
+};
+
+int wsm_set_pm(struct bes2600_common *hw_priv, const struct wsm_set_pm *arg,
+	       int if_id);
+
+
+/* 3.27 */
+struct wsm_set_pm_complete {
+	/* WSM_STATUS_... */
+	/* [out] */ u32 status;
+
+	/* WSM_PSM_... */
+    	/* [out] */u8 psm;
+};
+
+typedef void (*wsm_set_pm_complete_cb) (struct bes2600_common *hw_priv,
+					struct wsm_set_pm_complete *arg);
+
+/* 3.28 */
+struct wsm_set_bss_params {
+	/* The number of lost consecutive beacons after which */
+	/* the WLAN device should indicate the BSS-Lost event */
+	/* to the WLAN host driver. */
+	u8 beaconLostCount;
+
+	/* The AID received during the association process. */
+	u16 aid;
+
+	/* The operational rate set mask */
+	u32 operationalRateSet;
+};
+
+int wsm_set_bss_params(struct bes2600_common *hw_priv,
+		       const struct wsm_set_bss_params *arg, int if_id);
+
+/* 3.30 */
+struct wsm_add_key {
+	u8 type;		/* WSM_KEY_TYPE_... */
+	u8 entryIndex;		/* Key entry index: 0 -- WSM_KEY_MAX_INDEX */
+	u16 reserved;
+	union {
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 reserved;
+			u8 keyLength;		/* Key length in bytes */
+			u8 keyData[16];		/* Key data */
+		} __packed wepPairwiseKey;
+		struct {
+			u8 keyId;		/* Unique per key identifier
+						 * (0..3) */
+			u8 keyLength;		/* Key length in bytes */
+			u16 reserved;
+			u8 keyData[16];		/* Key data */
+		} __packed wepGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 reserved[2];
+			u8 tkipKeyData[16];	/* TKIP key data */
+			u8 rxMicKey[8];		/* Rx MIC key */
+			u8 txMicKey[8];		/* Tx MIC key */
+		} __packed tkipPairwiseKey;
+		struct {
+			u8 tkipKeyData[16];	/* TKIP key data */
+			u8 rxMicKey[8];		/* Rx MIC key */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+			u8 rxSeqCounter[8];	/* Receive Sequence Counter */
+		} __packed tkipGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u16 reserved;
+			u8 aesKeyData[16];	/* AES key data */
+		} __packed aesPairwiseKey;
+		struct {
+			u8 aesKeyData[16];	/* AES key data */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+			u8 rxSeqCounter[8];	/* Receive Sequence Counter */
+		} __packed aesGroupKey;
+		struct {
+			u8 peerAddress[6];	/* MAC address of the
+						 * peer station */
+			u8 keyId;		/* Key ID */
+			u8 reserved;
+			u8 wapiKeyData[16];	/* WAPI key data */
+			u8 micKeyData[16];	/* MIC key data */
+		} __packed wapiPairwiseKey;
+		struct {
+			u8 wapiKeyData[16];	/* WAPI key data */
+			u8 micKeyData[16];	/* MIC key data */
+			u8 keyId;		/* Key ID */
+			u8 reserved[3];
+		} __packed wapiGroupKey;
+		struct {
+			u8 IGTKKeyData[16];
+			u8 keyId;
+			u8 Reserved[3];
+			u8 IPN[8]; /* actual IPN is only 6 bytes long */
+		} __packed igtkGroupKey;
+	} __packed;
+} __packed;
+
+int wsm_add_key(struct bes2600_common *hw_priv, const struct wsm_add_key *arg,
+			int if_id);
+
+/* 3.32 */
+struct wsm_remove_key {
+	/* Key entry index : 0-10 */
+	u8 entryIndex;
+};
+
+int wsm_remove_key(struct bes2600_common *hw_priv,
+		   const struct wsm_remove_key *arg, int if_id);
+
+/* 3.34 */
+struct wsm_set_tx_queue_params {
+	/* WSM_ACK_POLICY_... */
+	u8 ackPolicy;
+
+	/* Medium Time of TSPEC (in 32us units) allowed per */
+	/* One Second Averaging Period for this queue. */
+	u16 allowedMediumTime;
+
+	/* dot11MaxTransmitMsduLifetime to be used for the */
+	/* specified queue. */
+	u32 maxTransmitLifetime;
+};
+
+struct wsm_tx_queue_params {
+	/* NOTE: index is a linux queue id. */
+	struct wsm_set_tx_queue_params params[4];
+};
+
+#define WSM_TX_QUEUE_SET(queue_params, queue, ack_policy, allowed_time,     \
+			 max_life_time)					    \
+do {									    \
+	struct wsm_set_tx_queue_params *p = &(queue_params)->params[queue]; \
+	p->ackPolicy = (ack_policy);				\
+	p->allowedMediumTime = (allowed_time);				\
+	p->maxTransmitLifetime = (max_life_time);			\
+} while (0)
+
+int wsm_set_tx_queue_params(struct bes2600_common *hw_priv,
+			    const struct wsm_set_tx_queue_params *arg,
+			    u8 id, int if_id);
+
+/* 3.36 */
+struct wsm_edca_queue_params {
+	/* CWmin (in slots) for the access class. */
+	/* [in] */ u16 cwMin;
+
+	/* CWmax (in slots) for the access class. */
+	/* [in] */ u16 cwMax;
+
+	/* AIFS (in slots) for the access class. */
+	/* [in] */ u8 aifns;
+
+	/* TX OP Limit (in microseconds) for the access class. */
+	/* [in] */ u16 txOpLimit;
+
+	/* dot11MaxReceiveLifetime to be used for the specified */
+	/* the access class. Overrides the global */
+	/* dot11MaxReceiveLifetime value */
+	/* [in] */ u32 maxReceiveLifetime;
+
+	/* UAPSD trigger support for the access class. */
+	/* [in] */ bool uapsdEnable;
+};
+
+struct wsm_edca_params {
+	/* NOTE: index is a linux queue id. */
+	struct wsm_edca_queue_params params[4];
+};
+
+#define TXOP_UNIT 32
+#define WSM_EDCA_SET(edca, queue, aifs, cw_min, cw_max, txop, life_time,\
+		uapsd)	\
+	do {							\
+		struct wsm_edca_queue_params *p = &(edca)->params[queue]; \
+		p->cwMin = (cw_min);				\
+		p->cwMax = (cw_max);				\
+		p->aifns = (aifs);				\
+		p->txOpLimit = ((txop) * TXOP_UNIT);		\
+		p->maxReceiveLifetime = (life_time);		\
+		p->uapsdEnable = (uapsd);			\
+	} while (0)
+
+int wsm_set_edca_params(struct bes2600_common *hw_priv,
+			const struct wsm_edca_params *arg, int if_id);
+
+int wsm_set_uapsd_param(struct bes2600_common *hw_priv,
+			const struct wsm_edca_params *arg);
+
+/* 3.38 */
+/* Set-System info. Skipped for now. Irrelevent. */
+
+/* 3.40 */
+struct wsm_switch_channel {
+	/* 1 - means the STA shall not transmit any further */
+	/* frames until the channel switch has completed */
+	/* [in] */ u8 channelMode;
+
+	/* Number of TBTTs until channel switch occurs. */
+	/* 0 - indicates switch shall occur at any time */
+	/* 1 - occurs immediately before the next TBTT */
+	/* [in] */ u8 channelSwitchCount;
+
+	/* The new channel number to switch to. */
+	/* Note this is defined as per section 2.7. */
+	/* [in] */ u16 newChannelNumber;
+};
+
+int wsm_switch_channel(struct bes2600_common *hw_priv,
+		       const struct wsm_switch_channel *arg, int if_id);
+
+typedef void (*wsm_channel_switch_cb) (struct bes2600_common *hw_priv);
+
+struct wsm_start {
+	/* WSM_START_MODE_... */
+	/* [in] */ u8 mode;
+
+	/* WSM_PHY_BAND_... */
+	/* [in] */ u8 band;
+
+	/* Channel number */
+	/* [in] */ u16 channelNumber;
+
+	/* Client Traffic window in units of TU */
+	/* Valid only when mode == ..._P2P */
+	/* [in] */ u32 CTWindow;
+
+	/* Interval between two consecutive */
+	/* beacon transmissions in TU. */
+	/* [in] */ u32 beaconInterval;
+
+	/* DTIM period in terms of beacon intervals */
+	/* [in] */ u8 DTIMPeriod;
+
+	/* WSM_JOIN_PREAMBLE_... */
+	/* [in] */ u8 preambleType;
+
+	/* The delay time (in microseconds) period */
+	/* before sending a probe-request. */
+	/* [in] */ u8 probeDelay;
+
+	/* Length of the SSID */
+	/* [in] */ u8 ssidLength;
+
+	/* SSID of the BSS or P2P_GO to be started now. */
+	/* [in] */ u8 ssid[32];
+
+	/* The basic supported rates for the MiniAP. */
+	/* [in] */ u32 basicRateSet;
+};
+
+int wsm_start(struct bes2600_common *hw_priv, const struct wsm_start *arg,
+		int if_id);
+
+int wsm_start_find(struct bes2600_common *hw_priv, int if_id);
+
+int wsm_stop_find(struct bes2600_common *hw_priv, int if_id);
+
+typedef void (*wsm_find_complete_cb) (struct bes2600_common *hw_priv,
+				      u32 status);
+
+struct wsm_suspend_resume {
+	/* See 3.52 */
+	/* Link ID */
+	/* [out] */ int link_id;
+	/* Stop sending further Tx requests down to device for this link */
+	/* [out] */ bool stop;
+	/* Transmit multicast Frames */
+	/* [out] */ bool multicast;
+	/* The AC on which Tx to be suspended /resumed. */
+	/* This is applicable only for U-APSD */
+	/* WSM_QUEUE_... */
+	/* [out] */ int queue;
+	/* [out] */ int if_id;
+};
+
+typedef void (*wsm_suspend_resume_cb) (struct bes2600_vif *priv,
+				       struct wsm_suspend_resume *arg);
+
+/* 3.54 Update-IE request. */
+struct wsm_update_ie {
+	/* WSM_UPDATE_IE_... */
+	/* [in] */ u16 what;
+	/* [in] */ u16 count;
+	/* [in] */ u8 *ies;
+	/* [in] */ size_t length;
+};
+
+int wsm_update_ie(struct bes2600_common *hw_priv,
+		  const struct wsm_update_ie *arg, int if_id);
+
+/* 3.56 */
+struct wsm_map_link {
+	/* MAC address of the remote device */
+	/* [in] */ u8 mac_addr[6];
+	/* [in] */ u8 unmap;
+	/* [in] */ u8 link_id;
+};
+
+int wsm_map_link(struct bes2600_common *hw_priv, const struct wsm_map_link *arg,
+		int if_id);
+
+struct wsm_cbc {
+	wsm_scan_complete_cb scan_complete;
+	wsm_tx_confirm_cb tx_confirm;
+	wsm_rx_cb rx;
+	wsm_event_cb event;
+	wsm_set_pm_complete_cb set_pm_complete;
+	wsm_channel_switch_cb channel_switch;
+	wsm_find_complete_cb find_complete;
+	wsm_suspend_resume_cb suspend_resume;
+};
+
+/* ******************************************************************** */
+/* MIB shortcats							*/
+struct wsm_mib {
+	u16 mibId;
+	void *buf;
+	size_t buf_size;
+};
+
+static inline int wsm_set_output_power(struct bes2600_common *hw_priv,
+				       int power_level, int if_id)
+{
+	__le32 val = __cpu_to_le32(power_level);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_CURRENT_TX_POWER_LEVEL,
+			     &val, sizeof(val), if_id);
+}
+
+static inline int wsm_set_beacon_wakeup_period(struct bes2600_common *hw_priv,
+					       unsigned dtim_interval,
+					       unsigned listen_interval,
+					       int if_id)
+{
+	struct {
+		u8 numBeaconPeriods;
+		u8 reserved;
+		__le16 listenInterval;
+	} val = {
+	dtim_interval, 0, __cpu_to_le16(listen_interval)};
+	if (dtim_interval > 0xFF || listen_interval > 0xFFFF)
+		return -EINVAL;
+	else
+		return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_WAKEUP_PERIOD,
+				     &val, sizeof(val), if_id);
+}
+
+struct wsm_rcpi_rssi_threshold {
+	u8 rssiRcpiMode;	/* WSM_RCPI_RSSI_... */
+	u8 lowerThreshold;
+	u8 upperThreshold;
+	u8 rollingAverageCount;
+};
+
+static inline int wsm_set_rcpi_rssi_threshold(struct bes2600_common *hw_priv,
+					struct wsm_rcpi_rssi_threshold *arg,
+					int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_RCPI_RSSI_THRESHOLD, arg,
+			     sizeof(*arg), if_id);
+}
+
+struct wsm_counters_table {
+	__le32 countPlcpErrors;
+	__le32 countFcsErrors;
+	__le32 countTxPackets;
+	__le32 countRxPackets;
+	__le32 countRxPacketErrors;
+	__le32 countRxDecryptionFailures;
+	__le32 countRxMicFailures;
+	__le32 countRxNoKeyFailures;
+	__le32 countTxMulticastFrames;
+	__le32 countTxFramesSuccess;
+	__le32 countTxFrameFailures;
+	__le32 countTxFramesRetried;
+	__le32 countTxFramesMultiRetried;
+	__le32 countRxFrameDuplicates;
+	__le32 countRtsSuccess;
+	__le32 countRtsFailures;
+	__le32 countAckFailures;
+	__le32 countRxMulticastFrames;
+	__le32 countRxFramesSuccess;
+	__le32 countRxCMACICVErrors;
+	__le32 countRxCMACReplays;
+	__le32 countRxMgmtCCMPReplays;
+};
+
+static inline int wsm_get_counters_table(struct bes2600_common *hw_priv,
+					 struct wsm_counters_table *arg)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_COUNTERS_TABLE,
+			arg, sizeof(*arg));
+}
+
+static inline int wsm_get_station_id(struct bes2600_common *hw_priv, u8 *mac)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_DOT11_STATION_ID, mac,
+			    ETH_ALEN);
+}
+
+struct wsm_rx_filter {
+	bool promiscuous;
+	bool bssid;
+	bool fcs;
+	bool probeResponder;
+	bool keepalive;
+};
+
+static inline int wsm_set_rx_filter(struct bes2600_common *hw_priv,
+				    const struct wsm_rx_filter *arg,
+				    int if_id)
+{
+	__le32 val = 0;
+	if (arg->promiscuous)
+		val |= __cpu_to_le32(BIT(0));
+	if (arg->bssid)
+		val |= __cpu_to_le32(BIT(1));
+	if (arg->fcs)
+		val |= __cpu_to_le32(BIT(2));
+	if (arg->probeResponder)
+		val |= __cpu_to_le32(BIT(3));
+	if (arg->keepalive)
+		val |= __cpu_to_le32(BIT(4));
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_RX_FILTER, &val, sizeof(val),
+			if_id);
+}
+
+int wsm_set_probe_responder(struct bes2600_vif *priv, bool enable);
+int wsm_set_keepalive_filter(struct bes2600_vif *priv, bool enable);
+
+#define WSM_BEACON_FILTER_IE_HAS_CHANGED	BIT(0)
+#define WSM_BEACON_FILTER_IE_NO_LONGER_PRESENT	BIT(1)
+#define WSM_BEACON_FILTER_IE_HAS_APPEARED	BIT(2)
+
+struct wsm_beacon_filter_table_entry {
+	u8	ieId;
+	u8	actionFlags;
+	u8	oui[3];
+	u8	matchData[3];
+} __packed;
+
+struct wsm_beacon_filter_table {
+	__le32 numOfIEs;
+	struct wsm_beacon_filter_table_entry entry[10];
+} __packed;
+
+static inline int wsm_set_beacon_filter_table(struct bes2600_common *hw_priv,
+					struct wsm_beacon_filter_table *ft,
+					int if_id)
+{
+	size_t size = __le32_to_cpu(ft->numOfIEs) *
+		     sizeof(struct wsm_beacon_filter_table_entry) +
+		     sizeof(__le32);
+
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_FILTER_TABLE, ft, size,
+			if_id);
+}
+
+#define WSM_BEACON_FILTER_ENABLE	BIT(0) /* Enable/disable beacon filtering */
+#define WSM_BEACON_FILTER_AUTO_ERP	BIT(1) /* If 1 FW will handle ERP IE changes internally */
+
+struct wsm_beacon_filter_control {
+	int enabled;
+	int bcn_count;
+};
+
+static inline int wsm_beacon_filter_control(struct bes2600_common *hw_priv,
+					struct wsm_beacon_filter_control *arg,
+					int if_id)
+{
+	struct {
+		__le32 enabled;
+		__le32 bcn_count;
+	} val;
+	val.enabled = __cpu_to_le32(arg->enabled);
+	val.bcn_count = __cpu_to_le32(arg->bcn_count);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BEACON_FILTER_ENABLE, &val,
+			     sizeof(val), if_id);
+}
+
+enum wsm_power_mode {
+	wsm_power_mode_active = 0,
+	wsm_power_mode_doze = 1,
+	wsm_power_mode_quiescent = 2,
+};
+
+struct wsm_operational_mode {
+	enum wsm_power_mode power_mode;
+	int disableMoreFlagUsage;
+	int performAntDiversity;
+};
+
+static inline int wsm_set_operational_mode(struct bes2600_common *hw_priv,
+					const struct wsm_operational_mode *arg,
+					int if_id)
+{
+	u32 val = arg->power_mode;
+	if (arg->disableMoreFlagUsage)
+		val |= BIT(4);
+	if (arg->performAntDiversity)
+		val |= BIT(5);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_OPERATIONAL_POWER_MODE, &val,
+			     sizeof(val), if_id);
+}
+
+struct wsm_inactivity {
+	u8 max_inactivity;
+	u8 min_inactivity;
+};
+
+static inline int wsm_set_inactivity(struct bes2600_common *hw_priv,
+					const struct wsm_inactivity *arg,
+					int if_id)
+{
+	struct {
+	       u8	min_inactive;
+	       u8	max_inactive;
+	       u16	reserved;
+	} val;
+
+	val.max_inactive = arg->max_inactivity;
+	val.min_inactive = arg->min_inactivity;
+	val.reserved = 0;
+
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_INACTIVITY, &val,
+			     sizeof(val), if_id);
+}
+
+struct wsm_template_frame {
+	u8 frame_type;
+	u8 rate;
+	bool disable;
+	struct sk_buff *skb;
+};
+
+static inline int wsm_set_template_frame(struct bes2600_common *hw_priv,
+					 struct wsm_template_frame *arg,
+					 int if_id)
+{
+	int ret;
+	u8 *p = skb_push(arg->skb, 4);
+	p[0] = arg->frame_type;
+	p[1] = arg->rate;
+	if (arg->disable)
+		((u16 *) p)[1] = 0;
+	else
+		((u16 *) p)[1] = __cpu_to_le16(arg->skb->len - 4);
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_TEMPLATE_FRAME, p,
+			    arg->skb->len, if_id);
+	skb_pull(arg->skb, 4);
+	return ret;
+}
+
+
+struct wsm_protected_mgmt_policy {
+	bool protectedMgmtEnable;
+	bool unprotectedMgmtFramesAllowed;
+	bool encryptionForAuthFrame;
+};
+
+static inline int
+wsm_set_protected_mgmt_policy(struct bes2600_common *hw_priv,
+			      struct wsm_protected_mgmt_policy *arg,
+			      int if_id)
+{
+	__le32 val = 0;
+	int ret;
+	if (arg->protectedMgmtEnable)
+		val |= __cpu_to_le32(BIT(0));
+	if (arg->unprotectedMgmtFramesAllowed)
+		val |= __cpu_to_le32(BIT(1));
+	if (arg->encryptionForAuthFrame)
+		val |= __cpu_to_le32(BIT(2));
+	ret = wsm_write_mib(hw_priv, WSM_MIB_ID_PROTECTED_MGMT_POLICY, &val,
+			    sizeof(val), if_id);
+	return ret;
+}
+
+static inline int wsm_set_block_ack_policy(struct bes2600_common *hw_priv,
+					   u8 blockAckTxTidPolicy,
+					   u8 blockAckRxTidPolicy,
+					   int if_id)
+{
+	struct {
+		u8 blockAckTxTidPolicy;
+		u8 reserved1;
+		u8 blockAckRxTidPolicy;
+		u8 reserved2;
+	} val = {
+		.blockAckTxTidPolicy = blockAckTxTidPolicy,
+		.blockAckRxTidPolicy = blockAckRxTidPolicy,
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_BLOCK_ACK_POLICY, &val,
+			     sizeof(val), if_id);
+}
+
+struct wsm_association_mode {
+	u8 flags;		/* WSM_ASSOCIATION_MODE_... */
+	u8 preambleType;	/* WSM_JOIN_PREAMBLE_... */
+	u8 greenfieldMode;	/* 1 for greenfield */
+	u8 mpduStartSpacing;
+	__le32 basicRateSet;
+};
+
+static inline int wsm_set_association_mode(struct bes2600_common *hw_priv,
+					   struct wsm_association_mode *arg,
+					   int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_ASSOCIATION_MODE, arg,
+			     sizeof(*arg), if_id);
+}
+
+struct wsm_set_tx_rate_retry_policy_header {
+	u8 numTxRatePolicies;
+	u8 reserved[3];
+} __packed;
+
+struct wsm_set_tx_rate_retry_policy_policy {
+	u8 policyIndex;
+	u8 shortRetryCount;
+	u8 longRetryCount;
+	u8 policyFlags;
+	u8 rateRecoveryCount;
+	u8 reserved[3];
+	__le32 rateCountIndices[3];
+} __packed;
+
+struct wsm_set_tx_rate_retry_policy {
+	struct wsm_set_tx_rate_retry_policy_header hdr;
+	struct wsm_set_tx_rate_retry_policy_policy tbl[8];
+} __packed;
+
+static inline int wsm_set_tx_rate_retry_policy(struct bes2600_common *hw_priv,
+				struct wsm_set_tx_rate_retry_policy *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_set_tx_rate_retry_policy_header) +
+	    arg->hdr.numTxRatePolicies *
+	    sizeof(struct wsm_set_tx_rate_retry_policy_policy);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_TX_RATE_RETRY_POLICY, arg,
+			     size, if_id);
+}
+
+/* 4.32 SetEtherTypeDataFrameFilter */
+struct wsm_ether_type_filter_hdr {
+	u8 nrFilters;		/* Up to WSM_MAX_FILTER_ELEMENTS */
+	u8 reserved[3];
+} __packed;
+
+struct wsm_ether_type_filter {
+	u8 filterAction;	/* WSM_FILTER_ACTION_XXX */
+	u8 reserved;
+	__le16 etherType;	/* Type of ethernet frame */
+} __packed;
+
+static inline int wsm_set_ether_type_filter(struct bes2600_common *hw_priv,
+				struct wsm_ether_type_filter_hdr *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_ether_type_filter_hdr) +
+		arg->nrFilters * sizeof(struct wsm_ether_type_filter);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_ETHERTYPE_DATAFRAME_FILTER,
+		arg, size, if_id);
+}
+
+
+/* 4.33 SetUDPPortDataFrameFilter */
+struct wsm_udp_port_filter_hdr {
+	u8 nrFilters;		/* Up to WSM_MAX_FILTER_ELEMENTS */
+	u8 reserved[3];
+} __packed;
+
+struct wsm_udp_port_filter {
+	u8 filterAction;	/* WSM_FILTER_ACTION_XXX */
+	u8 portType;		/* WSM_FILTER_PORT_TYPE_XXX */
+	__le16 udpPort;		/* Port number */
+} __packed;
+
+static inline int wsm_set_udp_port_filter(struct bes2600_common *hw_priv,
+				struct wsm_udp_port_filter_hdr *arg,
+				int if_id)
+{
+	size_t size = sizeof(struct wsm_udp_port_filter_hdr) +
+		arg->nrFilters * sizeof(struct wsm_udp_port_filter);
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_UDPPORT_DATAFRAME_FILTER,
+		arg, size, if_id);
+}
+
+/* Undocumented MIBs: */
+/* 4.35 P2PDeviceInfo */
+#define D11_MAX_SSID_LEN		(32)
+
+struct wsm_p2p_device_type {
+	__le16 categoryId;
+	u8 oui[4];
+	__le16 subCategoryId;
+} __packed;
+
+struct wsm_p2p_device_info {
+	struct wsm_p2p_device_type primaryDevice;
+	u8 reserved1[3];
+	u8 devNameSize;
+	u8 localDevName[D11_MAX_SSID_LEN];
+	u8 reserved2[3];
+	u8 numSecDevSupported;
+	struct wsm_p2p_device_type secondaryDevices[0];
+} __packed;
+
+/* 4.36 SetWCDMABand - WO */
+struct wsm_cdma_band {
+	u8 WCDMA_Band;
+	u8 reserved[3];
+} __packed;
+
+/* 4.37 GroupTxSequenceCounter - RO */
+struct wsm_group_tx_seq {
+	__le32 bits_47_16;
+	__le16 bits_15_00;
+	__le16 reserved;
+} __packed;
+
+/* 4.39 SetHtProtection - WO */
+#define WSM_DUAL_CTS_PROT_ENB		(1 << 0)
+#define WSM_NON_GREENFIELD_STA_PRESENT	(1 << 1)
+#define WSM_HT_PROT_MODE__NO_PROT	(0 << 2)
+#define WSM_HT_PROT_MODE__NON_MEMBER	(1 << 2)
+#define WSM_HT_PROT_MODE__20_MHZ	(2 << 2)
+#define WSM_HT_PROT_MODE__NON_HT_MIXED	(3 << 2)
+#define WSM_LSIG_TXOP_PROT_FULL		(1 << 4)
+#define WSM_LARGE_L_LENGTH_PROT		(1 << 5)
+
+struct wsm_ht_protection {
+	__le32 flags;
+} __packed;
+
+/* 4.40 GPIO Command - R/W */
+#define WSM_GPIO_COMMAND_SETUP	0
+#define WSM_GPIO_COMMAND_READ	1
+#define WSM_GPIO_COMMAND_WRITE	2
+#define WSM_GPIO_COMMAND_RESET	3
+#define WSM_GPIO_ALL_PINS	0xFF
+
+struct wsm_gpio_command {
+	u8 GPIO_Command;
+	u8 pin;
+	__le16 config;
+} __packed;
+
+/* 4.41 TSFCounter - RO */
+struct wsm_tsf_counter {
+	__le64 TSF_Counter;
+} __packed;
+
+/* 4.43 Keep alive period */
+struct wsm_keep_alive_period {
+	__le16 keepAlivePeriod;
+	u8 reserved[2];
+} __packed;
+
+static inline int wsm_keep_alive_period(struct bes2600_common *hw_priv,
+					int period, int if_id)
+{
+	struct wsm_keep_alive_period arg = {
+		.keepAlivePeriod = __cpu_to_le16(period),
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_KEEP_ALIVE_PERIOD,
+			&arg, sizeof(arg), if_id);
+};
+
+/* BSSID filtering */
+struct wsm_set_bssid_filtering {
+	u8 filter;
+	u8 reserved[3];
+} __packed;
+
+static inline int wsm_set_bssid_filtering(struct bes2600_common *hw_priv,
+					  bool enabled, int if_id)
+{
+	struct wsm_set_bssid_filtering arg = {
+		.filter = !enabled,
+	};
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DISABLE_BSSID_FILTER,
+			&arg, sizeof(arg), if_id);
+}
+
+/* Multicat filtering - 4.5 */
+struct wsm_multicast_filter {
+	__le32 enable;
+	__le32 numOfAddresses;
+	u8 macAddress[WSM_MAX_GRP_ADDRTABLE_ENTRIES][ETH_ALEN];
+} __packed;
+
+/* Mac Addr Filter Info */
+struct wsm_mac_addr_info {
+	u8 filter_mode;
+	u8 address_mode;
+	u8 MacAddr[6];
+} __packed;
+
+/* Mac Addr Filter */
+struct wsm_mac_addr_filter {
+	u8 numfilter;
+	u8 action_mode;
+	u8 Reserved[2];
+	struct wsm_mac_addr_info macaddrfilter[0];
+} __packed;
+
+/* Broadcast Addr Filter */
+struct wsm_broadcast_addr_filter {
+	u8 action_mode;
+	u8 nummacaddr;
+	u8 filter_mode;
+	u8 address_mode;
+	u8 MacAddr[6];
+} __packed;
+
+static inline int wsm_set_multicast_filter(struct bes2600_common *hw_priv,
+					   struct wsm_multicast_filter *fp,
+					   int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_DOT11_GROUP_ADDRESSES_TABLE,
+			     fp, sizeof(*fp), if_id);
+}
+
+/* ARP IPv4 filtering - 4.10 */
+struct wsm_arp_ipv4_filter {
+	__le32 enable;
+	__be32 ipv4Address[WSM_MAX_ARP_IP_ADDRTABLE_ENTRIES];
+} __packed;
+
+struct wsm_ip4_addr_info {
+    u8 filter_mode;
+    u8 address_mode;
+    u8 Reserved[2];
+    u8 ipv4[4];
+};
+
+/* IPV6 Addr Filter */
+struct wsm_ipv4_filter {
+    u8 numfilter;
+    u8 action_mode;
+    u8 Reserved[2];
+    struct wsm_ip4_addr_info ipv4filter[0];
+} __packed;
+
+static inline int wsm_set_arp_ipv4_filter(struct bes2600_common *hw_priv,
+					  struct wsm_arp_ipv4_filter *fp,
+					  int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_ARP_IP_ADDRESSES_TABLE,
+			    fp, sizeof(*fp), if_id);
+}
+
+/* P2P Power Save Mode Info - 4.31 */
+struct wsm_p2p_ps_modeinfo {
+	u8	oppPsCTWindow;
+	u8	count;
+	u8	reserved;
+	u8	dtimCount;
+	__le32	duration;
+	__le32	interval;
+	__le32	startTime;
+} __packed;
+
+static inline int wsm_set_p2p_ps_modeinfo(struct bes2600_common *hw_priv,
+					  struct wsm_p2p_ps_modeinfo *mi,
+					  int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_P2P_PS_MODE_INFO,
+			     mi, sizeof(*mi), if_id);
+}
+
+static inline int wsm_get_p2p_ps_modeinfo(struct bes2600_common *hw_priv,
+					  struct wsm_p2p_ps_modeinfo *mi)
+{
+	return wsm_read_mib(hw_priv, WSM_MIB_ID_P2P_PS_MODE_INFO,
+			    mi, sizeof(*mi));
+}
+
+/* UseMultiTxConfMessage */
+
+static inline int wsm_use_multi_tx_conf(struct bes2600_common *hw_priv,
+					bool enabled, int if_id)
+{
+	__le32 arg = enabled ? __cpu_to_le32(1) : 0;
+
+	return wsm_write_mib(hw_priv, WSM_MIB_USE_MULTI_TX_CONF,
+			&arg, sizeof(arg), if_id);
+}
+
+
+/* 4.26 SetUpasdInformation */
+struct wsm_uapsd_info {
+	__le16 uapsdFlags;
+	__le16 minAutoTriggerInterval;
+	__le16 maxAutoTriggerInterval;
+	__le16 autoTriggerStep;
+};
+
+static inline int wsm_set_uapsd_info(struct bes2600_common *hw_priv,
+				     struct wsm_uapsd_info *arg,
+				     int if_id)
+{
+	/* TODO:COMBO:UAPSD will be supported only on one interface */
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_SET_UAPSD_INFORMATION,
+				arg, sizeof(*arg), if_id);
+}
+
+/* 4.22 OverrideInternalTxRate */
+struct wsm_override_internal_txrate {
+	u8 internalTxRate;
+	u8 nonErpInternalTxRate;
+	u8 reserved[2];
+} __packed;
+
+static inline int
+wsm_set_override_internal_txrate(struct bes2600_common *hw_priv,
+				     struct wsm_override_internal_txrate *arg,
+				     int if_id)
+{
+	return wsm_write_mib(hw_priv, WSM_MIB_ID_OVERRIDE_INTERNAL_TX_RATE,
+				arg, sizeof(*arg), if_id);
+}
+
+/* ******************************************************************** */
+/* WSM TX port control							*/
+
+void wsm_lock_tx(struct bes2600_common *hw_priv);
+void wsm_vif_lock_tx(struct bes2600_vif *priv);
+void wsm_lock_tx_async(struct bes2600_common *hw_priv);
+bool wsm_flush_tx(struct bes2600_common *hw_priv);
+bool wsm_vif_flush_tx(struct bes2600_vif *priv);
+void wsm_unlock_tx(struct bes2600_common *hw_priv);
+
+/* ******************************************************************** */
+/* WSM / BH API								*/
+
+int wsm_handle_exception(struct bes2600_common *hw_priv, u8 * data, size_t len);
+int wsm_handle_rx(struct bes2600_common *hw_priv, int id, struct wsm_hdr *wsm,
+		  struct sk_buff **skb_p);
+
+/* ******************************************************************** */
+/* wsm_buf API								*/
+
+struct wsm_buf {
+	u8 *begin;
+	u8 *data;
+	u8 *end;
+};
+
+void wsm_buf_init(struct wsm_buf *buf);
+void wsm_buf_deinit(struct wsm_buf *buf);
+
+/* ******************************************************************** */
+/* wsm_cmd API								*/
+
+struct wsm_cmd {
+	spinlock_t lock;
+	int done;
+	u8 *ptr;
+	size_t len;
+	void *arg;
+	int ret;
+	u16 cmd;
+};
+
+/* ******************************************************************** */
+/* WSM TX buffer access							*/
+
+int wsm_get_tx(struct bes2600_common *hw_priv, u8 **data,
+	       size_t *tx_len, int *burst, int *vif_selected);
+void wsm_txed(struct bes2600_common *hw_priv, u8 *data);
+
+/* ******************************************************************** */
+/* Queue mapping: WSM <---> linux					*/
+/* Linux: VO VI BE BK							*/
+/* WSM:   BE BK VI VO							*/
+
+static inline u8 wsm_queue_id_to_linux(u8 queueId)
+{
+	static const u8 queue_mapping[] = {
+		2, 3, 1, 0
+	};
+	return queue_mapping[queueId];
+}
+
+static inline u8 wsm_queue_id_to_wsm(u8 queueId)
+{
+	static const u8 queue_mapping[] = {
+		3, 2, 0, 1
+	};
+	return queue_mapping[queueId];
+}
+
+/**
+ *  bes2600 driver signaling and nosignaling cmd
+ */
+enum bes2600_rf_cmd_type {
+	BES2600_RF_CMD_CALI_TXT_TO_FLASH = 0,
+	BES2600_RF_CMD_CH_INFO           = 1,
+	BES2600_RF_CMD_CPU_USAGE         = 2,
+	BES2600_RF_CMD_WIFI_STATUS       = 3,
+	/* add new here */
+
+	BES2600_RF_CMD_MAX,
+};
+
+int wsm_driver_rf_cmd_confirm(struct bes2600_common *hw_priv,
+                              void *arg, struct wsm_buf *buf);
+
+struct wsm_epta_msg {
+    int    wlan_duration;
+    int    bt_duration;
+    int    hw_epta_enable;
+};
+
+#define PROCTECT_MODE_RTS_CTS                              0x1 /* Non retransmission frame with rts/cts procttion*/
+#define PROCTECT_MODE_CTS                                  0x2 /* Non retransmission frame with cts procttion */
+#define PROCTECT_MODE_RTS_CTS_RETRY                        0x4 /* retransmission frame with rts/cts procttion */
+
+typedef struct MIB_TXRX_OPT_PARAM_S
+{
+    /* if rts send ,no cts response, rts can retry max cnt = g_max_rts_retry_limit */
+    u8  rts_retry_limit;
+    /* bit0: Non retransmission rts/cts protion.
+     * bit1: ALL(Non retransmission or retransmission)frame with cts PROTECT.
+     * bit2: retransmission frame with rts/cts PROTECT.
+     * support case1:Non retransmission frame with rts/cts PROTECT
+     *      protect_mode = PROTECT_MODE_RTS_CTS
+     * support case2:ALL(Non retransmission or retransmission)frame with cts PROTECT
+     *      protect_mode = PROTECT_MODE_CTS
+     * support case3:ALL(Non retransmission or retransmission)frame with rts PROTECT
+     *      protect_mode = (PROTECT_MODE_RTS_CTS|PROTECT_MODE_RTS_CTS_RETRY)
+     * support case4:retransmission frame with rts/cts PROTECT
+     *      protect_mode = (PROTECT_MODE_RTS_CTS_RETRY)
+     */
+    u8  protect_mode;
+    u16 rts_duration;
+} MIB_TXRX_OPT_PARAM;
+
+
+int wsm_epta_cmd(struct bes2600_common *hw_priv, struct wsm_epta_msg *arg);
+
+int wsm_epta_wifi_chan_cmd(struct bes2600_common *hw_priv, uint32_t channel, uint32_t type);
+
+int wsm_cpu_usage_cmd(struct bes2600_common *hw_priv);
+
+int wsm_wifi_status_cmd(struct bes2600_common *hw_priv, uint32_t status);
+
+#endif /* BES2600_HWIO_H_INCLUDED */
-- 
2.41.0

